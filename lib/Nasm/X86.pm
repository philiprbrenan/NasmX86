#!/usr/bin/perl -I/home/phil/perl/cpan/DataTableText/lib/ -I. -I/home/phil/perl/cpan/AsmC/lib/
#-------------------------------------------------------------------------------
# Generate X86 assembler code using Perl as a macro pre-processor.
# Philip R Brenan at appaapps dot com, Appa Apps Ltd Inc., 2021
#-------------------------------------------------------------------------------
# podDocumentation (\A.{80})\s+(#.*\Z) \1\2
# tree::print - speed up decision as to whether we are on a tree or not
# 0x401000 from sde-mix-out addresses to get offsets in z.txt
# Make hash accept parameters at: #THash
# if (0) in tests from subroutine conversion
# Document that V > 0 is required to create a boolean test
# Make sure that we are using bts and bzhi as much as possible in mask situations
# Update PrintOut to use V2 every where then rename
package Nasm::X86;
our $VERSION = "20211204";
use warnings FATAL => qw(all);
use strict;
use Carp qw(confess cluck);
use Data::Dump qw(dump);
use Data::Table::Text qw(:all);
use Time::HiRes qw(time);
use feature qw(say current_sub);
use utf8;

makeDieConfess;

my %rodata;                                                                     # Read only data already written
my %rodatas;                                                                    # Read only string already written
my %subroutines;                                                                # Subroutines generated
my @rodata;                                                                     # Read only data
my @data;                                                                       # Data
my @bss;                                                                        # Block started by symbol
my @text;                                                                       # Code
my @extern;                                                                     # External symbols imports for linking with C libraries
my @link;                                                                       # Specify libraries which to link against in the final assembly stage
my $interpreter = q(-I /usr/lib64/ld-linux-x86-64.so.2);                        # The ld command needs an interpreter if we are linking with C.
my $develop     = -e q(/home/phil/);                                            # Developing
my $sdeMixOut   = q(sde-mix-out.txt);                                           # Emulator output file

our $stdin  = 0;                                                                # File descriptor for standard input
our $stdout = 1;                                                                # File descriptor for standard output
our $stderr = 2;                                                                # File descriptor for standard error

my %Registers;                                                                  # The names of all the registers
my %RegisterContaining;                                                         # The largest register containing a register
my @GeneralPurposeRegisters = (qw(rax rbx rcx rdx rsi rdi), map {"r$_"} 8..15); # General purpose registers
my $bitsInByte;                                                                 # The number of bits in a byte
my @declarations;                                                               # Register and instruction declarations

BEGIN{
  $bitsInByte  = 8;                                                             # The number of bits in a byte
  my %r = (    map {$_=>[ 8,  '8'  ]}  qw(al bl cl dl r8b r9b r10b r11b r12b r13b r14b r15b r8l r9l r10l r11l r12l r13l r14l r15l sil dil spl bpl ah bh ch dh));
     %r = (%r, map {$_=>[16,  's'  ]}  qw(cs ds es fs gs ss));
     %r = (%r, map {$_=>[16,  '16' ]}  qw(ax bx cx dx r8w r9w r10w r11w r12w r13w r14w r15w si di sp bp));
     %r = (%r, map {$_=>[32,  '32a']}  qw(eax  ebx ecx edx esi edi esp ebp));
     %r = (%r, map {$_=>[32,  '32b']}  qw(r8d r9d r10d r11d r12d r13d r14d r15d));
     %r = (%r, map {$_=>[80,  'f'  ]}  qw(st0 st1 st2 st3 st4 st5 st6 st7));
     %r = (%r, map {$_=>[64,  '64' ]}  qw(rax rbx rcx rdx r8 r9 r10 r11 r12 r13 r14 r15 rsi rdi rsp rbp rip rflags));
     %r = (%r, map {$_=>[64,  '64m']}  qw(mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7));
     %r = (%r, map {$_=>[128, '128']}  qw(xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 xmm8 xmm9 xmm10 xmm11 xmm12 xmm13 xmm14 xmm15 xmm16 xmm17 xmm18 xmm19 xmm20 xmm21 xmm22 xmm23 xmm24 xmm25 xmm26 xmm27 xmm28 xmm29 xmm30 xmm31));
     %r = (%r, map {$_=>[256, '256']}  qw(ymm0 ymm1 ymm2 ymm3 ymm4 ymm5 ymm6 ymm7 ymm8 ymm9 ymm10 ymm11 ymm12 ymm13 ymm14 ymm15 ymm16 ymm17 ymm18 ymm19 ymm20 ymm21 ymm22 ymm23 ymm24 ymm25 ymm26 ymm27 ymm28 ymm29 ymm30 ymm31));
     %r = (%r, map {$_=>[512, '512']}  qw(zmm0 zmm1 zmm2 zmm3 zmm4 zmm5 zmm6 zmm7 zmm8 zmm9 zmm10 zmm11 zmm12 zmm13 zmm14 zmm15 zmm16 zmm17 zmm18 zmm19 zmm20 zmm21 zmm22 zmm23 zmm24 zmm25 zmm26 zmm27 zmm28 zmm29 zmm30 zmm31));
     %r = (%r, map {$_=>[64,  'm'  ]}  qw(k0 k1 k2 k3 k4 k5 k6 k7));

  %Registers = %r;                                                              # Register names

  my sub registerContaining($@)
   {my ($r, @r) = @_;                                                           # Register, contents
    $RegisterContaining{$r} = $r;                                               # A register contains itself
    $RegisterContaining{$_} = $r for @r;                                        # Registers contained by a register
   }

  registerContaining("k$_")                                            for 0..7;
  registerContaining("zmm$_",   "ymm$_", "xmm$_")                      for 0..31;
  registerContaining("r${_}x", "e${_}x", "${_}x",  "${_}l",  "${_}h")  for qw(a b c d);
  registerContaining("r${_}",  "r${_}l", "r${_}w", "r${_}b", "r${_}d") for 8..15;
  registerContaining("r${_}p", "e${_}p", "${_}p",  "${_}pl")           for qw(s b);
  registerContaining("r${_}i", "e${_}i", "${_}i", "${_}il")            for qw(s d);
  my @i0 = qw(cpuid lahf leave popfq pushfq rdtsc ret syscall);                 # Zero operand instructions

  my @i1 = split /\s+/, <<END;                                                  # Single operand instructions
align bswap call dec div idiv  inc jmp ja jae jb jbe jc jcxz je jecxz jg jge jl jle
jna jnae jnb jnbe jnc jne jng jnge jnl jnle jno jnp jns jnz jo jp jpe jpo jrcxz
js jz loop neg not seta setae setb setbe setc sete setg setge setl setle setna setnae
setnb setnbe setnc setne setng setnge setnl setno setnp setns setnz seto setp
setpe setpo sets setz pop push
END

  my @i2 =  split /\s+/, <<END;                                                 # Double operand instructions
add and bt btc btr bts
cmova cmovae cmovb cmovbe cmovc cmove cmovg cmovge cmovl cmovle
cmovna cmovnae cmovnb cmp
enter
imul
kmov knot kortest ktest lea lzcnt mov movd movdqa
or popcnt sal sar shl shr sub test tzcnt
vcvtudq2pd vcvtuqq2pd vcvtudq2ps vmovdqu vmovdqu32 vmovdqu64 vmovdqu8
vpcompressd vpcompressq vpexpandd vpexpandq xchg xor
vmovd vmovq
mulpd
pslldq psrldq
vpmovb2m vpmovw2m Vpmovd2m vpmovq2m

vsqrtpd
vmovdqa32 vmovdqa64
END
# print STDERR join ' ', sort @i2; exit;

  my @i2qdwb =  split /\s+/, <<END;                                             # Double operand instructions which have qdwb versions
vpmovm2
vpbroadcast
END

  my @i3 =  split /\s+/, <<END;                                                 # Triple operand instructions
andn
bzhi
imul3
kadd kand kandn kor kshiftl kshiftr kunpck kxnor kxor

vdpps
vprolq
vgetmantps
vaddd
vmulpd vaddpd
END

  my @i3qdwb =  split /\s+/, <<END;                                             # Triple operand instructions which have qdwb versions
pinsr pextr valign vpand vpandn vpcmpeq vpor vpxor vptest vporvpcmpeq vpinsr vpextr vpadd vpsub vpmull
END

  my @i4 =  split /\s+/, <<END;                                                 # Quadruple operand instructions
END

  my @i4qdwb =  split /\s+/, <<END;                                             # Quadruple operand instructions which have qdwb versions
vpcmpu
END

  if (1)                                                                        # Add variants to mask instructions
   {my @k2  = grep {m/\Ak/} @i2; @i2  = grep {!m/\Ak/} @i2;
    my @k3  = grep {m/\Ak/} @i3; @i3  = grep {!m/\Ak/} @i3;
    for my $s(qw(b w d q))
     {push @i2, $_.$s for grep {m/\Ak/} @k2;
      push @i3, $_.$s for grep {m/\Ak/} @k3;
     }
   }

  if (1)                                                                        # Add qdwb versions of instructions
   {for my $o(@i2qdwb)
     {push @i2, $o.$_ for qw(b w d q);
     }
    for my $o(@i3qdwb)
     {push @i3, $o.$_ for qw(b w d q);
     }
    for my $o(@i4qdwb)
     {push @i4, $o.$_ for qw(b w d q);
     }
   }

  for my $r(sort keys %r)                                                       # Create register definitions
   {if (1)
     {my $s = "sub $r\{q($r)\}";
      push @declarations, $r;
      eval $s;
      confess "$s$@ "if $@;
     }
    if (1)
     {my $b = $r{$r}[0] / $bitsInByte;
      my $s = "sub ${r}Size\{$b}";
      eval $s;
      confess "$s$@ "if $@;
     }
   }

  my %v = map {$$_[1]=>1} values %r;
  for my $v(sort keys %v)                                                       # Types of register
   {my @r = grep {$r{$_}[1] eq $v} sort keys %r;
    my $s = "sub registers_$v\{".dump(\@r)."}";
    eval $s;
    confess "$s$@" if $@;
   }

  if (1)                                                                        # Instructions that take zero operands
   {my $s = '';
    for my $i(@i0)
      {my $I = ucfirst $i;
       push @declarations, $I;
       $s .= <<END;
       sub $I()
        {\@_ == 0 or confess "No arguments allowed";
         my \$s = '  ' x scalar(my \@d = caller);
         push \@text, qq(\${s}$i\\n);
        }
END
     }
    eval $s;
    confess "$s$@" if $@;
   }

  if (1)                                                                        # Instructions that take one operand
   {my $s = '';
    for my $i(@i1)
      {my $I = ucfirst $i;
       push @declarations, $I;
       $s .= <<END;
       sub $I
        {my (\$target) = \@_;
         \@_ == 1 or confess "One argument required, not ".scalar(\@_);
         my \$s = '  ' x scalar(my \@d = caller);
         push \@text, qq(\${s}$i \$target\\n);
        }
END
     }
    eval $s;
    confess "$s$@" if $@;
   }

  if (1)                                                                        # Instructions that take two operands
   {my $s = '';
    for my $i(@i2)
      {my $I = ucfirst $i;
       push @declarations, $I;
       $s .= <<END;
       sub $I(\@)
        {my (\$target, \$source) = \@_;
         \@_ == 2 or confess "Two arguments required, not ".scalar(\@_);
#TEST         Keep(\$target)    if "$i" =~ m(\\Amov\\Z) and \$Registers{\$target};
#TEST         KeepSet(\$source) if "$i" =~ m(\\Amov\\Z) and \$Registers{\$source};
         my \$s = '  ' x scalar(my \@d = caller);
         push \@text, qq(\${s}$i \$target, \$source\\n);
        }
END
     }
    eval $s;
    confess "$s$@" if $@;
   }

  if (1)                                                                        # Instructions that take three operands
   {my $s = '';
    for my $i(@i3)
      {my $I = ucfirst $i;
       push @declarations, $I;
       my $j = $i =~ s(\d\Z) ()r;                                               # Remove number of parameters designated
       $s .= <<END;
       sub $I(\@)
        {my (\$target, \$source, \$bits) = \@_;
         \@_ == 3 or confess "Three arguments required, not ".scalar(\@_);
         my \$s = '  ' x scalar(my \@d = caller);
         push \@text, qq(\${s}$j \$target, \$source, \$bits\\n);
        }
END
     }
    eval "$s$@";
    confess $@ if $@;
   }

  if (1)                                                                        # Instructions that take four operands
   {my $s = '';
    for my $i(@i4)
      {my $I = ucfirst $i;
       push @declarations, $I;
       $s .= <<END;
       sub $I(\@)
        {my (\$target, \$source, \$bits, \$zero) = \@_;
         \@_ == 4 or confess "Four arguments required, not ".scalar(\@_);
         my \$s = '  ' x scalar(my \@d = caller);
         push \@text, qq(\${s}$i \$target, \$source, \$bits, \$zero\\n);
        }
END
     }
    eval "$s$@";
    confess $@ if $@;
   }
 }

sub byteRegister($)                                                             # The byte register corresponding to a full size register
 {my ($r) = @_;                                                                 # Full size register
  if ($r =~ m(\Ar([abcd])x\Z)) {return $1."l"};
  return dil if $r eq rdi;
  return sil if $r eq rsi;
  $r."b"
 }

sub wordRegister($)                                                             # The word register corresponding to a full size register
 {my ($r) = @_;                                                                 # Full size register
  if ($r =~ m(\Ar([abcd])x\Z)) {return $1."x"};
  return di if $r eq rdi;
  return si if $r eq rsi;
  $r."w"
 }

sub dWordRegister($)                                                            # The double word register corresponding to a full size register
 {my ($r) = @_;                                                                 # Full size register
  if ($r =~ m(\Ar([abcd])x\Z)) {return "e".$1."x"};
  return edi if $r eq rdi;
  return esi if $r eq rsi;
  $r."d"
 }

sub Subroutine(&%);                                                             # Create a subroutine that can be called in assembler code.

#D1 Data                                                                        # Layout data

my $Labels = 0;

sub Label(;$)                                                                   #P Create a unique label or reuse the one supplied.
 {return "l".++$Labels unless @_;                                               # Generate a label
  $_[0];                                                                        # Use supplied label
 }

sub SetLabel(;$)                                                                # Create (if necessary) and set a label in the code section returning the label so set.
 {my ($l) = @_;                                                                 # Label
  $l //= Label;
  push @text, <<END;                                                            # Define bytes
  $l:
END
  $l                                                                            # Return label name
 }

sub Ds(@)                                                                       # Layout bytes in memory and return their label.
 {my (@d) = @_;                                                                 # Data to be laid out
  my $d = join '', @_;
     $d =~ s(') (\')gs;
  my $l = Label;
  push @data, <<END;                                                            # Define bytes
  $l: db  '$d';
END
  $l                                                                            # Return label
 }

sub Rs(@)                                                                       # Layout bytes in read only memory and return their label.
 {my (@d) = @_;                                                                 # Data to be laid out
  my $d = join '', @_;
  my @e;
  for my $e(split //, $d)
   {if ($e !~ m([A-Z0-9])i) {push @e, sprintf("0x%x", ord($e))} else {push @e, qq('$e')}
   }
  my $e = join ', ', @e;
  my $L = $rodatas{$e};
  return $L if defined $L;                                                      # Data already exists so return it
  my $l = Label;                                                                # New label for new data
  $rodatas{$e} = $l;                                                            # Record label
  push @rodata, <<END;                                                          # Define bytes
  $l: db  $e, 0;
END
  $l                                                                            # Return label
 }

sub Rutf8(@)                                                                    # Layout a utf8 encoded string as bytes in read only memory and return their label.
 {my (@d) = @_;                                                                 # Data to be laid out
  confess unless @_;
  my $d = join '', @_; ## No need to join and split
  my @e;
  for my $e(split //, $d)
   {my $o  = ord $e;                                                            # Effectively the utf32 encoding of each character
    my $u  = convertUtf32ToUtf8($o);
    my $x  = sprintf("%08x", $u);
    my $o1 = substr($x, 0, 2);
    my $o2 = substr($x, 2, 2);
    my $o3 = substr($x, 4, 2);
    my $o4 = substr($x, 6, 2);
    if    ($o <= (1 << 7))  {push @e,                $o4}
    elsif ($o <= (1 << 11)) {push @e,           $o3, $o4}
    elsif ($o <= (1 << 16)) {push @e,      $o2, $o3, $o4}
    else                    {push @e, $o1, $o2, $o3, $o4}
   }

  my $e = join ', ',map {"0x$_"}  @e;
  my $L = $rodatas{$e};
  return $L if defined $L;                                                      # Data already exists so return it
  my $l = Label;                                                                # New label for new data
  $rodatas{$e} = $l;                                                            # Record label
  push @rodata, <<END;                                                          # Define bytes
  $l: db  $e, 0;
END
  $l                                                                            # Return label
 }

sub Dbwdq($@)                                                                   #P Layout data.
 {my ($s, @d) = @_;                                                             # Element size, data to be laid out
  my $d = join ', ', @d;
  my $l = Label;
  push @data, <<END;
  $l: d$s $d
END
  $l                                                                            # Return label
 }

sub Db(@)                                                                       # Layout bytes in the data segment and return their label.
 {my (@bytes) = @_;                                                             # Bytes to layout
  Dbwdq 'b', @_;
 }
sub Dw(@)                                                                       # Layout words in the data segment and return their label.
 {my (@words) = @_;                                                             # Words to layout
  Dbwdq 'w', @_;
 }
sub Dd(@)                                                                       # Layout double words in the data segment and return their label.
 {my (@dwords) = @_;                                                            # Double words to layout
  Dbwdq 'd', @_;
 }
sub Dq(@)                                                                       # Layout quad words in the data segment and return their label.
 {my (@qwords) = @_;                                                            # Quad words to layout
  Dbwdq 'q', @_;
 }

sub Rbwdq($@)                                                                   #P Layout data.
 {my ($s, @d) = @_;                                                             # Element size, data to be laid out
  my $d = join ', ', map {$_ =~ m(\A\d+\Z) ? sprintf "0x%x", $_ : $_} @d;       # Data to be laid out
  if (my $c = $rodata{$s}{$d})                                                  # Data already exists so return it
   {return $c
   }
  my $l = Label;                                                                # New data - create a label
  push @rodata, <<END;                                                          # Save in read only data
  $l: d$s $d
END
  $rodata{$s}{$d} = $l;                                                         # Record label
  $l                                                                            # Return label
 }

sub Rb(@)                                                                       # Layout bytes in the data segment and return their label.
 {my (@bytes) = @_;                                                             # Bytes to layout
  Rbwdq 'b', @_;
 }
sub Rw(@)                                                                       # Layout words in the data segment and return their label.
 {my (@words) = @_;                                                             # Words to layout
  Rbwdq 'w', @_;
 }
sub Rd(@)                                                                       # Layout double words in the data segment and return their label.
 {my (@dwords) = @_;                                                            # Double words to layout
  Rbwdq 'd', @_;
 }
sub Rq(@)                                                                       # Layout quad words in the data segment and return their label.
 {my (@qwords) = @_;                                                            # Quad words to layout
  Rbwdq 'q', @_;
 }

my $Pi = "3.141592653589793238462";

sub Pi32 {Rd("__float32__($Pi)")}                                               #P Pi as a 32 bit float.
sub Pi64 {Rq("__float32__($Pi)")}                                               #P Pi as a 64 bit float.

#D1 Registers                                                                   # Operations on registers

#D2 Size                                                                        # Sizes of each register

sub RegisterSize($)                                                             # Return the size of a register.
 {my ($r) = @_;                                                                 # Register
  $r = &registerNameFromNumber($r);
  defined($r) or confess;
  defined($Registers{$r}) or confess "No such registers as: $r";
  eval "${r}Size()";
 }

#D2 Push, Pop, Peek                                                             # Generic versions of push, pop, peek

sub PushRR(@)                                                                   #P Push registers onto the stack without tracking.
 {my (@r) = @_;                                                                 # Register
  my $w = RegisterSize rax;
  for my $r(map {&registerNameFromNumber($_)} @r)
   {my $size = RegisterSize $r;
    $size or confess "No such register: $r";
    if    ($size > $w)                                                          # Wide registers
     {Sub rsp, $size;
      Vmovdqu32 "[rsp]", $r;
     }
    elsif ($r =~ m(\Ak))                                                        # Mask as they do not respond to push
     {Sub rsp, $size;
      Kmovq "[rsp]", $r;
     }
    else                                                                        # Normal register
     {Push $r;
     }
   }
 }

my @PushR;                                                                      # Track pushes

sub PushR(@)                                                                    #P Push registers onto the stack.
 {my (@r) = @_;                                                                 # Registers
  push @PushR, [@r];
# CommentWithTraceBack;
  PushRR   @r;                                                                  # Push
  scalar(@PushR)                                                                # Stack depth
 }

sub PopRR(@)                                                                    #P Pop registers from the stack without tracking.
 {my (@r) = @_;                                                                 # Register
  my $w = RegisterSize rax;
  for my $r(reverse map{&registerNameFromNumber($_)}  @r)                       # Pop registers in reverse order
   {my $size = RegisterSize $r;
    if    ($size > $w)
     {Vmovdqu32 $r, "[rsp]";
      Add rsp, $size;
     }
    elsif ($r =~ m(\Ak))
     {Kmovq $r, "[rsp]";
      Add rsp, $size;
     }
    else
     {Pop $r;
     }
   }
 }

sub PopR(@)                                                                     # Pop registers from the stack. Use the last stored set if none explicitly supplied.  Pops are done in reverse order to match the original pushing order.
 {my (@r) = @_;                                                                 # Register
  @PushR or confess "No stacked registers";
  my $r = pop @PushR;
  dump(\@r) eq dump($r) or confess "Mismatched registers:\n".dump($r, \@r) if @r;
  PopRR @$r;                                                                    # Pop registers from the stack without tracking
# CommentWithTraceBack;
 }

#D2 General                                                                     # Actions specific to general purpose registers

sub registerNameFromNumber($)                                                   # Register name from number where possible
 {my ($r) = @_;                                                                 # Register number
  return "zmm$r" if $r =~ m(\A(16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)\Z);
  return   "r$r" if $r =~ m(\A(8|9|10|11|12|13|14|15)\Z);
  return   "k$r" if $r =~ m(\A(0|1|2|3|4|5|6|7)\Z);
  $r
 }

sub ChooseRegisters($@)                                                         # Choose the specified numbers of registers excluding those on the specified list.
 {my ($number, @registers) = @_;                                                # Number of registers needed, Registers not to choose
  my %r = (map {$_=>1} map {"r$_"} 8..15);
  delete $r{$_} for @registers;
  $number <= keys %r or confess "Not enough registers available";
  sort keys %r
 }

sub InsertZeroIntoRegisterAtPoint($$)                                           # Insert a zero into the specified register at the point indicated by another general purpose or mask register moving the higher bits one position to the left.
 {my ($point, $in) = @_;                                                        # Register with a single 1 at the insertion point, register to be inserted into.

  ref($point) and confess "Point must be a register";

  PushR my ($mask, $low, $high) = ChooseRegisters(3, $in, $point);              # Choose three work registers and push them
  if (&CheckMaskRegister($point))                                               # Mask register showing point
   {Kmovq $mask, $point;
   }
  else                                                                          # General purpose register showing point
   {Mov  $mask, $point;
   }

  Dec  $mask;                                                                   # Fill mask to the right of point with ones
  Andn $high, $mask, $in;                                                       # Part of in be shifted
  Shl  $high, 1;                                                                # Shift high part
  And  $in,  $mask;                                                             # Clear high part of target
  Or   $in,  $high;                                                             # Or in new shifted high part
  PopR;                                                                         # Restore stack
 }

sub InsertOneIntoRegisterAtPoint($$)                                            # Insert a one into the specified register at the point indicated by another register.
 {my ($point, $in) = @_;                                                        # Register with a single 1 at the insertion point, register to be inserted into.
  InsertZeroIntoRegisterAtPoint($point, $in);                                   # Insert a zero
  if (&CheckIfMaskRegisterNumber($point))                                       # Mask register showing point
   {my ($r) = ChooseRegisters(1, $in);                                          # Choose a general purpose register to place the mask in
    PushR $r;
    Kmovq $r, $point;
    Or   $in, $r;                                                               # Make the zero a one
    PopR;
   }
  else                                                                          # General purpose register showing point
   {Or $in, $point;                                                             # Make the zero a one
   }
 }

#D2 Save and Restore                                                            # Saving and restoring registers via the stack

my @syscallSequence = qw(rax rdi rsi rdx r10 r8 r9);                            # The parameter list sequence for system calls

sub SaveFirstFour(@)                                                            # Save the first 4 parameter registers making any parameter registers read only.
 {my (@keep) = @_;                                                              # Registers to mark as read only
  my $N = 4;
  PushRR $_ for @syscallSequence[0..$N-1];
  $N * &RegisterSize(rax);                                                      # Space occupied by push
 }

sub RestoreFirstFour()                                                          # Restore the first 4 parameter registers.
 {my $N = 4;
  PopRR $_ for reverse @syscallSequence[0..$N-1];
 }

sub RestoreFirstFourExceptRax()                                                 # Restore the first 4 parameter registers except rax so it can return its value.
 {my $N = 4;
  PopRR $_ for reverse @syscallSequence[1..$N-1];
  Add rsp, 1*RegisterSize(rax);
 }

sub RestoreFirstFourExceptRaxAndRdi()                                           # Restore the first 4 parameter registers except rax  and rdi so we can return a pair of values.
 {my $N = 4;
  PopRR $_ for reverse @syscallSequence[2..$N-1];
  Add rsp, 2*RegisterSize(rax);
 }

sub SaveFirstSeven()                                                            # Save the first 7 parameter registers.
 {my $N = 7;
  PushRR $_ for @syscallSequence[0..$N-1];
  $N * 1*RegisterSize(rax);                                                     # Space occupied by push
 }

sub RestoreFirstSeven()                                                         # Restore the first 7 parameter registers.
 {my $N = 7;
  PopRR $_ for reverse @syscallSequence[0..$N-1];
 }

sub RestoreFirstSevenExceptRax()                                                # Restore the first 7 parameter registers except rax which is being used to return the result.
 {my $N = 7;
  PopRR $_ for reverse @syscallSequence[1..$N-1];
  Add rsp, 1*RegisterSize(rax);
 }

sub RestoreFirstSevenExceptRaxAndRdi()                                          # Restore the first 7 parameter registers except rax and rdi which are being used to return the results.
 {my $N = 7;
  PopRR $_ for reverse @syscallSequence[2..$N-1];
  Add rsp, 2*RegisterSize(rax);                                                 # Skip rdi and rax
 }

sub ClearRegisters(@)                                                           # Clear registers by setting them to zero.
 {my (@registers) = @_;                                                         # Registers
  my $w = RegisterSize rax;
  for my $r(map{registerNameFromNumber $_} @registers)                          # Each register
   {my $size = RegisterSize $r;
    Xor    $r, $r     if $size == $w and $r !~ m(\Ak);
    Kxorq  $r, $r, $r if $size == $w and $r =~ m(\Ak);
    Vpxorq $r, $r, $r if $size  > $w;
   }
 }

sub SetZF()                                                                     # Set the zero flag.
 {Cmp rax, rax;
 }

sub ClearZF()                                                                   # Clear the zero flag.
 {PushR rax;
  Mov rax, 1;
  Cmp rax, 0;
  PopR rax;
 }

#D2 x, y, zmm                                                                   # Actions specific to mm registers

sub xmm(@)                                                                      # Add xmm to the front of a list of register expressions.
 {my (@r) = @_;                                                                 # Register numbers
  map {"xmm$_"} @_;
 }

sub ymm(@)                                                                      # Add ymm to the front of a list of register expressions.
 {my (@r) = @_;                                                                 # Register numbers
  map {"ymm$_"} @_;
 }

sub zmm(@)                                                                      # Add zmm to the front of a list of register expressions.
 {my (@r) = @_;                                                                 # Register numbers
  map {"zmm$_"} @_;
 }

sub zmmM($$)                                                                    # Add zmm to the front of a register number and a mask after it
 {my ($z, $m) = @_;                                                             # Zmm number, mask register
  "zmm$z\{k$m}"
 }

sub zmmMZ($$)                                                                   # Add zmm to the front of a register number and mask and zero after it
 {my ($z, $m) = @_;                                                             # Zmm number, mask register number
  "zmm$z\{k$m}\{z}"
 }

sub LoadZmm($@)                                                                 # Load a numbered zmm with the specified bytes.
 {my ($zmm, @bytes) = @_;                                                       # Numbered zmm, bytes
  my $b = Rb(@bytes);
  Vmovdqu8 "zmm$zmm", "[$b]";
 }

sub checkZmmRegister($)                                                         # Check that a register is a zmm register
 {my ($z) = @_;                                                                 # Parameters
  $z =~ m(\A(0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)\Z) or confess "$z is not the number of a zmm register";
 }

sub bRegFromZmm($$$)                                                            # Load the specified register from the byte at the specified offset located in the numbered zmm.
 {my ($register, $zmm, $offset) = @_;                                           # Register to load, numbered zmm register to load from, constant offset in bytes
  @_ == 3 or confess "Three parameters";
  my $z = registerNameFromNumber $zmm;
  $offset >= 0 && $offset <= RegisterSize zmm0 or
    confess "Offset $offset Out of range";

  PushRR $z;                                                                    # Push source register

  my $b = byteRegister $register;                                               # Corresponding byte register

  Mov $b, "[rsp+$offset]";                                                      # Load byte register from offset
  Add rsp, RegisterSize $z;                                                     # Pop source register
 }

sub bRegIntoZmm($$$)                                                            # Put the byte content of the specified register into the byte in the numbered zmm at the specified offset in the zmm.
 {my ($register,  $zmm, $offset) = @_;                                          # Register to load, numbered zmm register to load from, constant offset in bytes
  @_ == 3 or confess "Three parameters";
  $offset >= 0 && $offset <= RegisterSize zmm0 or confess "Out of range";

  PushR "zmm$zmm";                                                              # Push source register

  my $b = byteRegister $register;                                               # Corresponding byte register

  Mov "[rsp+$offset]", $b;                                                      # Save byte at specified offset
  PopR "zmm$zmm";                                                               # Reload zmm
 }

sub wRegFromZmm($$$)                                                            # Load the specified register from the word at the specified offset located in the numbered zmm.
 {my ($register, $zmm, $offset) = @_;                                           # Register to load, numbered zmm register to load from, constant offset in bytes
  @_ == 3 or confess "Three parameters";
  my $z = registerNameFromNumber $zmm;
  $offset >= 0 && $offset <= RegisterSize zmm0 or
    confess "Offset $offset Out of range";

  PushRR $z;                                                                    # Push source register

  my $w = wordRegister $register;                                               # Corresponding word register

  Mov $w, "[rsp+$offset]";                                                      # Load word register from offset
  Add rsp, RegisterSize $z;                                                     # Pop source register
 }

sub wRegIntoZmm($$$)                                                            # Put the specified register into the word in the numbered zmm at the specified offset in the zmm.
 {my ($register,  $zmm, $offset) = @_;                                          # Register to load, numbered zmm register to load from, constant offset in bytes
  @_ == 3 or confess "Three parameters";
  $offset >= 0 && $offset <= RegisterSize zmm0 or confess "Out of range";

  PushR "zmm$zmm";                                                              # Push source register

  my $w = wordRegister $register;                                               # Corresponding word register

  Mov "[rsp+$offset]", $w;                                                      # Save word at specified offset
  PopR "zmm$zmm";                                                               # Reload zmm
 }

sub LoadRegFromMm($$$)                                                          # Load the specified register from the numbered zmm at the quad offset specified as a constant number.
 {my ($mm, $offset, $reg) = @_;                                                 # Mm register, offset in quads, general purpose register to load
  @_ == 3 or confess "Three parameters";
  my $w = RegisterSize rax;                                                     # Size of rax
  my $W = RegisterSize $mm;                                                     # Size of mm register
  Vmovdqu64 "[rsp-$W]", $mm;                                                    # Write below the stack
  Mov $reg, "[rsp+$w*$offset-$W]";                                              # Load register from offset
 }

sub SaveRegIntoMm($$$)                                                          # Save the specified register into the numbered zmm at the quad offset specified as a constant number.
 {my ($mm, $offset, $reg) = @_;                                                 # Mm register, offset in quads, general purpose register to load
  @_ == 3 or confess "Three parameters";
  my $w = RegisterSize rax;                                                     # Size of rax
  my $W = RegisterSize $mm;                                                     # Size of mm register
  Vmovdqu64 "[rsp-$W]", $mm;                                                    # Write below the stack
  Mov "[rsp+$w*$offset-$W]", $reg;                                              # Save register into offset
  Vmovdqu64 $mm, "[rsp-$W]";                                                    # Reload from the stack
 }

sub getBwdqFromMm($$$)                                                          # Get the numbered byte|word|double word|quad word from the numbered zmm register and return it in a variable.
 {my ($size, $mm, $offset) = @_;                                                # Size of get, mm register, offset in bytes either as a constant or as a variable
  @_ == 3 or confess "Three parameters";

  my $o;                                                                        # The offset into the mm register
  if (ref($offset))                                                             # The offset is being passed in a variable
   {$offset->setReg($o = rsi);
   }
  else                                                                          # The offset is being passed as a register expression
   {$o = $offset;
   }

  my $w = RegisterSize $mm;                                                     # Size of mm register
  Vmovdqu32 "[rsp-$w]", $mm;                                                    # Write below the stack

  ClearRegisters rdi if $size !~ m(q|d);                                        # Clear the register if necessary
  Mov  byteRegister(rdi), "[rsp+$o-$w]" if $size =~ m(b);                       # Load byte register from offset
  Mov  wordRegister(rdi), "[rsp+$o-$w]" if $size =~ m(w);                       # Load word register from offset
  Mov dWordRegister(rdi), "[rsp+$o-$w]" if $size =~ m(d);                       # Load double word register from offset
  Mov rdi,                "[rsp+$o-$w]" if $size =~ m(q);                       # Load register from offset

  V("$size at offset $offset in $mm", rdi);                                     # Create variable
 }

sub bFromX($$)                                                                  # Get the byte from the numbered xmm register and return it in a variable.
 {my ($xmm, $offset) = @_;                                                      # Numbered xmm, offset in bytes
  getBwdqFromMm('b', "xmm$xmm", $offset)                                        # Get the numbered byte|word|double word|quad word from the numbered xmm register and return it in a variable
 }

sub wFromX($$)                                                                  # Get the word from the numbered xmm register and return it in a variable.
 {my ($xmm, $offset) = @_;                                                      # Numbered xmm, offset in bytes
  getBwdqFromMm('w', "xmm$xmm", $offset)                                        # Get the numbered byte|word|double word|quad word from the numbered xmm register and return it in a variable
 }

sub dFromX($$)                                                                  # Get the double word from the numbered xmm register and return it in a variable.
 {my ($xmm, $offset) = @_;                                                      # Numbered xmm, offset in bytes
  getBwdqFromMm('d', "xmm$xmm", $offset)                                        # Get the numbered byte|word|double word|quad word from the numbered xmm register and return it in a variable
 }

sub qFromX($$)                                                                  # Get the quad word from the numbered xmm register and return it in a variable.
 {my ($xmm, $offset) = @_;                                                      # Numbered xmm, offset in bytes
  getBwdqFromMm('q', "xmm$xmm", $offset)                                        # Get the numbered byte|word|double word|quad word from the numbered xmm register and return it in a variable
 }

sub bFromZ($$)                                                                  # Get the byte from the numbered zmm register and return it in a variable.
 {my ($zmm, $offset) = @_;                                                      # Numbered zmm, offset in bytes
  getBwdqFromMm('b', "zmm$zmm", $offset)                                        # Get the numbered byte|word|double word|quad word from the numbered zmm register and return it in a variable
 }

sub wFromZ($$)                                                                  # Get the word from the numbered zmm register and return it in a variable.
 {my ($zmm, $offset) = @_;                                                      # Numbered zmm, offset in bytes
  getBwdqFromMm('w', "zmm$zmm", $offset)                                        # Get the numbered byte|word|double word|quad word from the numbered zmm register and return it in a variable
 }

sub dFromZ($$)                                                                  # Get the double word from the numbered zmm register and return it in a variable.
 {my ($zmm, $offset) = @_;                                                      # Numbered zmm, offset in bytes
  getBwdqFromMm('d', "zmm$zmm", $offset)                                        # Get the numbered byte|word|double word|quad word from the numbered zmm register and return it in a variable
 }

sub qFromZ($$)                                                                  # Get the quad word from the numbered zmm register and return it in a variable.
 {my ($zmm, $offset) = @_;                                                      # Numbered zmm, offset in bytes
  getBwdqFromMm('q', "zmm$zmm", $offset)                                        # Get the numbered byte|word|double word|quad word from the numbered zmm register and return it in a variable
 }

#D2 Mask                                                                        # Operations on mask registers

sub CheckMaskRegister($)                                                        # Check that a register is in fact a numbered mask register
 {my ($reg) = @_;                                                               # Register to check
  @_ == 1 or confess "One parameter";
  $Registers{$reg} && $reg =~ m(\Ak[0-7]\Z)
 }

sub CheckIfMaskRegisterNumber($)                                                # Check that a register is in fact a mask register.
 {my ($mask) = @_;                                                              # Mask register to check
  @_ == 1 or confess "One parameter";
  $mask =~ m(\Ak?[0-7]\Z)
 }

sub CheckMaskRegisterNumber($)                                                  # Check that a register is in fact a mask register and confess if it is not.
 {my ($mask) = @_;                                                              # Mask register to check
  @_ == 1 or confess "One parameter";
  $mask =~ m(\Ak?[0-7]\Z) or confess "Not the number of a mask register: $mask";
 }

sub SetMaskRegister($$$)                                                        # Set the mask register to ones starting at the specified position for the specified length and zeroes elsewhere.
 {my ($mask, $start, $length) = @_;                                             # Number of mask register to set, register containing start position or 0 for position 0, register containing end position
  @_ == 3 or confess "Three parameters";
  CheckMaskRegisterNumber($mask);

  PushR (r15, r14);
  Mov r15, -1;
  if ($start)                                                                   # Non zero start
   {Mov  r14, $start;
    Bzhi r15, r15, r14;
    Not  r15;
    Add  r14, $length;
   }
  else                                                                          # Starting at zero
   {Mov r14, $length;
   }
  Bzhi r15, r15, r14;
  Kmovq "k$mask", r15;
  PopR;
 }

sub LoadConstantIntoMaskRegister($$)                                            # Set a mask register equal to a constant.
 {my ($mask, $value) = @_;                                                      # Number of mask register to load, constant to load
  @_ == 2 or confess "Two parameters";
  CheckMaskRegisterNumber $mask;
  $mask     = registerNameFromNumber $mask;
  Mov rdi, $value;                                                              # Load mask into a general purpose register
  Kmovq $mask, rdi;                                                             # Load mask register from general purpose register
 }

sub createBitNumberFromAlternatingPattern($@)                                   # Create a number from a bit pattern.
 {my ($prefix, @values) = @_;                                                   # Prefix bits, +n 1 bits -n 0 bits
  @_ > 1 or confess "Four or more parameters required";                         # Must have some values

  $prefix =~ m(\A[01]*\Z) or confess "Prefix must be binary";                   # Prefix must be binary
  grep {$_ == 0} @values and confess "Values must not be zero";                 # No value may be zero

  for my $i(0..$#values-1)                                                      # Check values alternate
   {($values[$i] > 0 && $values[$i+1] > 0  or
     $values[$i] < 0 && $values[$i+1] < 0) and confess "Signs must alternate";
   }

  my $b = "0b$prefix";
  for my $v(@values)                                                            # String representation of bit string
   {$b .= '1' x +$v if $v > 0;
    $b .= '0' x -$v if $v < 0;
   }

  my $n = eval $b;
  confess $@ if $@;
  $n
 }

sub LoadBitsIntoMaskRegister($$@)                                               # Load a bit string specification into a mask register in two clocks.
 {my ($mask, $prefix, @values) = @_;                                            # Number of mask register to load, prefix bits, +n 1 bits -n 0 bits
  @_ > 2 or confess "Three or more parameters required";                        # Must have some values

  LoadConstantIntoMaskRegister                                                  # Load the specified binary constant into a mask register
    ($mask, createBitNumberFromAlternatingPattern $prefix, @values)
 }

#D1 Comparison codes                                                            # The codes used to specify what sort of comparison to perform

my $Vpcmp = genHash("NasmX86::CompareCodes",                                    # Compare codes for "Vpcmp"
  eq=>0,                                                                        # Equal
  lt=>1,                                                                        # Less than
  le=>2,                                                                        # Less than or equals
  ne=>4,                                                                        # Not equals
  ge=>5,                                                                        # Greater than or equal
  gt=>6,                                                                        # Greater than
 );

#D1 Structured Programming                                                      # Structured programming constructs

sub If($$;$)                                                                    # If statement.
 {my ($jump, $then, $else) = @_;                                                # Jump op code of variable, then - required , else - optional
  @_ >= 2 && @_ <= 3 or confess;

  ref($jump) or $jump =~ m(\AJ(c|e|g|ge|gt|h|l|le|nc|ne|ns|nz|s|z)\Z)
             or confess "Invalid jump: $jump";

  if (ref($jump))                                                               # Variable expression,  if it is non zero perform the then block else the else block
   { __SUB__->(q(Jnz), $then, $else);
   }
  elsif (!$else)                                                                # No else
   {my $end = Label;
    push @text, <<END;
    $jump $end;
END
    &$then;
    SetLabel $end;
   }
  else                                                                          # With else
   {my $endIf     = Label;
    my $startElse = Label;
    push @text, <<END;
    $jump $startElse
END
    &$then;
    Jmp $endIf;
    SetLabel $startElse;
    &$else;
    SetLabel  $endIf;
   }
 }

sub Then(&)                                                                     # Then block for an If statement.
 {my ($block) = @_;                                                             # Then block
  $block;
 }

sub Else(&)                                                                     # Else block for an If statement.
 {my ($block) = @_;                                                             # Else block
  $block;
 }

sub Ef(&$;$)                                                                    # Else if block for an If statement.
 {my ($condition, $then, $else) = @_;                                           # Condition, then block, else block
  sub
  {If (&$condition, $then, $else);
  }
 }

sub IfEq($;$)                                                                   # If equal execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jne), $then, $else);                                                     # Opposite code
 }

sub IfNe($;$)                                                                   # If not equal execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Je), $then, $else);                                                      # Opposite code
 }

sub IfNz($;$)                                                                   # If the zero flag is not set then execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jz), $then, $else);                                                      # Opposite code
 }

sub IfZ($;$)                                                                    # If the zero flag is set then execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jnz), $then, $else);                                                     # Opposite code
 }

sub IfC($;$)                                                                    # If the carry flag is set then execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jnc), $then, $else);                                                     # Opposite code
 }

sub IfNc($;$)                                                                   # If the carry flag is not set then execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jc), $then, $else);                                                      # Opposite code
 }

sub IfLt($;$)                                                                   # If less than execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jge), $then, $else);                                                     # Opposite code
 }

sub IfLe($;$)                                                                   # If less than or equal execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jg), $then, $else);                                                      # Opposite code
 }

sub IfGt($;$)                                                                   # If greater than execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jle), $then, $else);                                                     # Opposite code
 }

sub IfGe($;$)                                                                   # If greater than or equal execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jl), $then, $else);                                                      # Opposite code
 }

sub IfS($;$)                                                                    # If signed greater than or equal execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Jns), $then, $else);                                                     # Opposite code
 }

sub IfNs($;$)                                                                   # If signed less than execute the then block else the else block.
 {my ($then, $else) = @_;                                                       # Then - required , else - optional
  If(q(Js), $then, $else);                                                      # Opposite code
 }

sub Pass(&)                                                                     # Pass block for an L<OrBlock>.
 {my ($block) = @_;                                                             # Block
  $block;
 }

sub Fail(&)                                                                     # Fail block for an L<AndBlock>.
 {my ($block) = @_;                                                             # Block
  $block;
 }

sub Block(&)                                                                    # Execute a block of code with labels supplied for the start and end of this code
 {my ($code) = @_;                                                              # Block of code
  @_ == 1 or confess "One parameter";
  SetLabel(my $start = Label);                                                  # Start of block
  my $end  = Label;                                                             # End of block
  &$code($end, $start);                                                         # Code with labels supplied
  SetLabel $end;                                                                # End of block
 }

sub AndBlock(&;$)                                                               # Short circuit B<and>: execute a block of code to test conditions which, if all of them pass, allows the first block to continue successfully else if one of the conditions fails we execute the optional fail block.
 {my ($test, $fail) = @_;                                                       # Block, optional failure block
  @_ == 1 or @_ == 2 or confess "One or two parameters";
  SetLabel(my $start = Label);                                                  # Start of test block
  my $Fail = @_ == 2 ? Label : undef;                                           # Start of fail block
  my $end  = Label;                                                             # End of both blocks
  &$test(($Fail // $end), $end, $start);                                        # Test code plus success code
  if ($fail)
   {Jmp $end;                                                                   # Skip the fail block if we succeed in reaching the end of the test block which is the expected behavior for short circuited B<and>.
    SetLabel $Fail;
    &$fail($end, $Fail, $start);                                                # Execute when true
   }
  SetLabel $end;                                                                # Exit block
 }

sub OrBlock(&;$)                                                                # Short circuit B<or>: execute a block of code to test conditions which, if one of them is met, leads on to the execution of the pass block, if all of the tests fail we continue withe the test block.
 {my ($test, $pass) = @_;                                                       # Tests, optional block to execute on success
  @_ == 1 or @_ == 2 or confess "One or two parameters";
  SetLabel(my $start = Label);                                                  # Start of test block
  my $Pass = @_ == 2 ? Label : undef;                                           # Start of pass block
  my $end  = Label;                                                             # End of both blocks
  &$test(($Pass // $end), $end, $start);                                        # Test code plus fail code
  if ($pass)
   {Jmp $end;                                                                   # Skip the pass block if we succeed in reaching the end of the test block which is the expected behavior for short circuited B<or>.
    SetLabel $Pass;
    &$pass($end, $Pass, $start);                                                # Execute when true
   }
  SetLabel $end;                                                                # Exit block
 }

sub For(&$$;$)                                                                  # For - iterate the block as long as register is less than limit incrementing by increment each time. Nota Bene: The register is not explicitly set to zero as you might want to start at some other number.
 {my ($block, $register, $limit, $increment) = @_;                              # Block, register, limit on loop, increment on each iteration
  @_ == 3 or @_ == 4 or confess;
  $increment //= 1;                                                             # Default increment
  my $next = Label;                                                             # Next iteration
  &Comment("For $register $limit");
  my $start = Label;
  my $end   = Label;
  SetLabel $start;
  Cmp $register, $limit;
  Jge $end;

  &$block($start, $end, $next);                                                 # Start, end and next labels

  SetLabel $next;                                                               # Next iteration starting with after incrementing
  if ($increment == 1)
   {Inc $register;
   }
  else
   {Add $register, $increment;
   }
  Jmp $start;                                                                   # Restart loop
  SetLabel $end;                                                                # Exit loop
 }

sub ForIn(&$$$$)                                                                # For - iterate the full block as long as register plus increment is less than than limit incrementing by increment each time then increment the last block for the last non full block.
 {my ($full, $last, $register, $limitRegister, $increment) = @_;                # Block for full block, block for last block , register, register containing upper limit of loop, increment on each iteration
  @_ == 5 or confess;
  my $start = Label;
  my $end   = Label;

  SetLabel $start;                                                              # Start of loop
  PushR $register;                                                              # Save the register so we can test that there is still room
  Add   $register, $increment;                                                  # Add increment
  Cmp   $register, $limitRegister;                                              # Test that we have room for increment
  PopR  $register;                                                              # Remove increment
  Jge   $end;

  &$full;

  Add $register, $increment;                                                    # Increment for real
  Jmp $start;
  SetLabel $end;

  Sub $limitRegister, $register;                                                # Size of remainder
  IfNz                                                                          # Non remainder
  Then
   {&$last;                                                                     # Process remainder
   }
 }

sub ForEver(&)                                                                  # Iterate for ever.
 {my ($block) = @_;                                                             # Block to iterate
  @_ == 1 or confess "One parameter";
  &Comment("ForEver");
  my $start = Label;                                                            # Start label
  my $end   = Label;                                                            # End label

  SetLabel $start;                                                              # Start of loop

  &$block($start, $end);                                                        # End of loop

  Jmp $start;                                                                   # Restart loop
  SetLabel $end;                                                                # End of loop
 }

#D2 Call                                                                        # Call a subroutine

my @VariableStack = (1);                                                        # Counts the number of parameters and variables on the stack in each invocation of L<Subroutine>.  There is at least one variable - the first holds the traceback.

sub SubroutineStartStack()                                                      # Initialize a new stack frame.  The first quad of each frame has the address of the name of the sub in the low dword, and the parameter count in the upper byte of the quad.  This field is all zeroes in the initial frame.
 {push @VariableStack, 1;                                                       # Counts the number of variables on the stack in each invocation of L<Subroutine>.  The first quad provides the traceback.
 }

sub Nasm::X86::Sub::callTo($$$@)                                                #P Call a sub passing it some parameters.
 {my ($sub, $mode, $label, @parameters) = @_;                                   # Subroutine descriptor, mode 0 - direct call or 1 - indirect call, label of sub, parameter variables

  my %p;
  while(@parameters)                                                            # Copy parameters supplied by the caller
   {my $p = shift @parameters;                                                  # Check parameters provided by caller
    my $n = ref($p) ? $p->name : $p;
    defined($n) or confess "No name or variable";
    my $v = ref($p) ? $p       : shift @parameters;                             # Each actual parameter is a variable or an expression that can loaded into a register
    unless ($sub->args->{$n})                                                   # Describe valid parameters using a table
     {my @t;
      push @t, map {[$_]} keys $sub->args->%*;
      my $t = formatTable([@t], [qw(Name)]);
      confess "Invalid parameter: '$n'\n$t";
     }
    $p{$n} = ref($v) ? $v : V($n, $v);
   }

  my %with = ($sub->options->{with}{variables}//{})->%*;                        # The list of arguments the containing subroutine was called with

  if (1)                                                                        # Check for missing arguments
   {my %m = $sub->args->%*;                                                     # Formal arguments
    delete $m{$_} for sort keys %p;                                             # Remove actual arguments
    delete $m{$_} for sort keys %with;                                          # Remove arguments from calling environment if supplied
    keys %m and confess "Missing arguments ".dump([sort keys %m]);              # Print missing parameter names
   }

  if (1)                                                                        # Check for misnamed arguments
   {my %m = %p;                                                                 # Actual arguments
    delete $m{$_} for sort keys($sub->args->%*), sort keys(%with);              # Remove formal arguments
    keys %m and confess "Invalid arguments ".dump([sort keys %m]);              # Print misnamed arguments
   }

  my $w = RegisterSize r15;
  PushR 15;                                                                     # Use this register to transfer between the current frame and the next frame
  Mov "dword[rsp  -$w*3]", $sub->nameString;                                    # Point to name
  Mov "byte [rsp-1-$w*2]", scalar $sub->parameters->@*;                         # Number of parameters to enable traceback with parameters

  if (1)                                                                        # Transfer parameters by copying them to the base of the stack frame
   {my %a = (%with, %p);                                                        # The consolidated argument list
    for my $a(sort keys %a)                                                     # Transfer parameters from current frame to next frame
     {my $label = $a{$a}->label;                                                # Source in current frame
      if ($a{$a}->reference)                                                    # Source is a reference
       {Mov r15, "[$label]";
       }
      else                                                                      # Source is not a reference
       {Lea r15, "[$label]";
       }
      my $q = $sub->variables->{$a}->label;
         $q =~ s(rbp) (rsp);                                                    # Labels are based off the stack frame but we are building a new stack frame here so we must rename the stack pointer.
      Mov "[$q-$w*2]", r15;                                                     # Step over subroutine name pointer and previous frame pointer.
     }
   }

  if ($mode)                                                                    # Dereference and call subroutine
   {Mov r15, $label;
    Mov r15, "[r15]";
    Call r15;
   }
  else                                                                          # Call via label
   {Call $label;
   }
  PopR;
 }

sub Nasm::X86::Sub::call($@)                                                    # Call a sub passing it some parameters.
 {my ($sub, @parameters) = @_;                                                  # Subroutine descriptor, parameter variables
  $sub->callTo(0, $sub->start, @parameters);                                    # Call the subroutine
 }

sub Nasm::X86::Sub::via($$@)                                                    # Call a sub by reference passing it some parameters.
 {my ($sub, $ref, @parameters) = @_;                                            # Subroutine descriptor, variable containing a reference to the sub, parameter variables
  PushR 14, 15;
  if ($ref->reference)                                                          # Dereference address of subroutine.
   {Mov r14, "[$$ref{label}]";                                                  # Reference
   }
  else
   {Lea r14, "[$$ref{label}]";                                                  # Direct
   }
  $sub->callTo(1, r14, @parameters);                                            # Call the subroutine
  PopR;
 }

sub Nasm::X86::Sub::V($)                                                        # Put the address of a subroutine into a stack variable so that it can be passed as a parameter.
 {my ($sub) = @_;                                                               # Subroutine descriptor
  V('call', $sub->start);                                                       # Address subroutine via a stack variable
 }

sub Nasm::X86::Sub::dispatch($)                                                 # Jump into the specified subroutine so that code of the target subroutine is executed instead of the code of the current subroutine allowing the target subroutine to be dispatched to process the parameter list of the current subroutine.  When the target subroutine returns it returns to the caller of the current sub, not to the current subroutine.
 {my ($sub) = @_;                                                               # Subroutine descriptor of target subroutine
  @_ == 1 or confess "One parameter";
  $sub->V()->setReg(rdi);                                                       # Start of sub routine
  Add rdi, 4;                                                                   # Skip initial enter as to prevent a new stack from being created
  Jmp rdi;                                                                      # Start h specified sub - when it exits it will return to the code that called us.
 }

sub Nasm::X86::Sub::dispatchV($$)                                               # L<Dispatch|/Nasm::X86::Sub::dispatch> the variable subroutine using the specified register.
 {my ($sub, $reference) = @_;                                                   # Subroutine descriptor, variable referring to the target subroutine
  @_ == 2 or confess "Two parameters";
  $reference->setReg(rdi);                                                      # Start of sub routine
  Add rdi, 4;                                                                   # Skip initial enter as to prevent a new stack from being created
  Jmp rdi;                                                                      # Start h specified sub - when it exits it will return to the code that called us.
 }

sub PrintTraceBack($)                                                           # Trace the call stack.
 {my ($channel) = @_;                                                           # Channel to write on

  Subroutine
   {PushR my @save = (rax, rdi, r9, r10, r8, r12, r13, r14, r15);
    my $stack     = r15;
    my $count     = r14;
    my $index     = r13;
    my $parameter = r12;                                                        # Number of parameters
    my $maxCount  = r8;                                                         # Maximum number of parameters - should be r11 when we have found out why r11 does not print correctly.
    my $depth     = r10;                                                        # Depth of trace back
    ClearRegisters @save;

    Mov $stack, rbp;                                                            # Current stack frame
    AndBlock                                                                    # Each level
     {my ($fail, $end, $start) = @_;                                            # Fail block, end of fail block, start of test block
      Mov $stack, "[$stack]";                                                   # Up one level
      Mov rax, "[$stack-8]";
      Mov $count, rax;
      Shr $count, 56;                                                           # Top byte contains the parameter count
      Cmp $count, $maxCount;                                                    # Compare this count with maximum so far
      Cmovg $maxCount, $count;                                                  # Update count if greater
      Shl rax, 8; Shr rax, 8;                                                   # Remove parameter count
      Je $end;                                                                  # Reached top of stack if rax is zero
      Inc $depth;                                                               # Depth of trace back
      Jmp $start;                                                               # Next level
     };

    Mov $stack, rbp;                                                            # Current stack frame
    &PrintNL($channel);                                                         # Print title
    &PrintString($channel, "Subroutine trace back, depth: ");
    PushR rax;
    Mov rax, $depth;
    &PrintRaxRightInDec(V(width=>2), $channel);
    PopR rax;
    &PrintNL($channel);

    AndBlock                                                                    # Each level
     {my ($fail, $end, $start) = @_;                                            # Fail block, end of fail block, start of test block
      Mov $stack, "[$stack]";                                                   # Up one level
      Mov rax, "[$stack-8]";
      Mov $count, rax;
      Shr $count, 56;                                                           # Top byte contains the parameter count
      Shl rax, 8; Shr rax, 8;                                                   # Remove parameter count
      Je $end;                                                                  # Reached top of stack
      Cmp $count, 0;                                                            # Check for parameters
      IfGt
      Then                                                                      # One or more parameters
       {Mov $index, 0;
        For
         {my ($start, $end, $next) = @_;
          Mov $parameter, $index;
          Add $parameter, 2;                                                    # Skip traceback
          Shl $parameter, 3;                                                    # Each parameter is a quad
          Neg $parameter;                                                       # Offset from stack
          Add $parameter, $stack;                                               # Position on stack
          Mov $parameter, "[$parameter]";                                       # Parameter reference to variable
          Push rax;
          Mov rax, "[$parameter]";                                              # Variable content
          &PrintRaxInHex($channel);
          Pop rax;
          &PrintSpace($channel, 4);
         } $index, $count;
        For                                                                     # Vertically align subroutine names
         {my ($start, $end, $next) = @_;
          &PrintSpace($channel, 23);
         } $index, $maxCount;
       };

      StringLength(&V(string => rax))->setReg(rdi);                             # Length of name of subroutine
      &PrintMemoryNL($channel);                                                 # Print name of subroutine
      Jmp $start;                                                               # Next level
     };
    &PrintNL($channel);
    PopR;
   } name => "SubroutineTraceBack_$channel", call=>1;
 }

sub PrintErrTraceBack($)                                                        # Print sub routine track back on stderr and then exit with a message.
 {my ($message) = @_;                                                           # Reason why we are printing the trace back and then stopping
  &PrintErrStringNL($message);
  PrintTraceBack($stderr);
  Exit(1);
 }

sub PrintOutTraceBack($)                                                        # Print sub routine track back on stdout and then exit with a message.
 {my ($message) = @_;                                                           # Reason why we are printing the trace back and then stopping
  &PrintOutStringNL($message);
  PrintTraceBack($stdout);
  Exit(1);
 }

sub OnSegv()                                                                    # Request a trace back followed by exit on a B<segv> signal.
 {my $s = Subroutine                                                            # Subroutine that will cause an error to occur to force a trace back to be printed
   {my $end = Label;
    Jmp $end;                                                                   # Jump over subroutine definition
    my $start = SetLabel;
    Enter 0, 0;                                                                 # Inline code of signal handler
    Mov r15, rbp;                                                               # Preserve the new stack frame
    Mov rbp, "[rbp]";                                                           # Restore our last stack frame
    PrintOutTraceBack 'Segmentation error';                                     # Print our trace back
    Mov rbp, r15;                                                               # Restore supplied stack frame
    Exit(0);                                                                    # Exit so we do not trampoline. Exit with code zero to show that the program is functioning correctly, else L<Assemble> will report an error.
    Leave;
    Ret;
    SetLabel $end;

    Mov r15, 0;                                                                 # Push sufficient zeros onto the stack to make a structure B<sigaction> as described in: https://www.man7.org/linux/man-pages/man2/sigaction.2.html
    Push r15 for 1..16;

    Mov r15, $start;                                                            # Actual signal handler
    Mov "[rsp]", r15;                                                           # Show as signal handler
    Mov "[rsp+0x10]", r15;                                                      # Add as trampoline as well - which is fine because we exit in the handler so this will never be called
    Mov r15, 0x4000000;                                                         # Mask to show we have a trampoline which is, apparently, required on x86
    Mov "[rsp+0x8]", r15;                                                       # Confirm we have a trampoline

    Mov rax, 13;                                                                # B<Sigaction> from B<kill -l>
    Mov rdi, 11;                                                                # Confirmed B<SIGSEGV = 11> from B<kill -l> and tracing with B<sde64>
    Mov rsi, rsp;                                                               # Structure B<sigaction> structure on stack
    Mov rdx, 0;                                                                 # Confirmed by trace
    Mov r10, 8;                                                                 # Found by tracing B<signal.c> with B<sde64> it is the width of the signal set and mask. B<signal.c> is reproduced below.
    Syscall;
    Add rsp, 128;
   } [], name=>"on segv";

  $s->call;
 }

# Subroutine                                                                    # Define and call subroutines

sub copyStructureMinusVariables($)                                              # Copy a non recursive structure ignoring variables
 {my ($s) = @_;                                                                 # Structure to copy

  my %s = %$s;
  for my $k(sort keys %s)                                                       # Look for sub structures
   {if (my $r = ref($s{$k}))
     {$s{$k} = __SUB__->($s{$k}) unless $r =~ m(\AVariable\Z);                  # We do not want to copy the variables yet because we are going to make them into references.
     }
   }

  bless \%s, ref $s;                                                            # Return a copy of the structure
 }

sub Subroutine(&%)                                                              # Create a subroutine that can be called in assembler code.
 {my ($block, %options) = @_;                                                   # Block of code as a sub, options
  @_ >= 1 or confess "Subroutine requires at least a block";

  if (1)                                                                        # Validate options
   {my %o = %options;
    delete $o{$_} for qw(parameters structures name call);
    if (my @i = sort keys %o)
     {confess "Invalid parameters: ".join(', ',@i);
     }
   }

  my $run = sub                                                                 # We can call and run the sub immediately if it has just structure parameter (which can be single variables) and no other parameters
   {my ($s) = @_;                                                               # Parameters
    if ($s->options->{call})                                                    # Call and run the existing copy of the subroutine if it only requires structure arguments which can include just variables.
     {if (!$s->options->{parameters})                                           # Cannot run -as the subroutine requires parameters as well as structures.
       {$s->call(structures=>$s->options->{structures});                        # Call the subroutine
        return $s                                                               # Return the label of a pre-existing copy of the code. Make sure that the name is different for different subs as otherwise the unexpected results occur.
       }
      else                                                                      # Cannot call and run the subroutine as it requires parameters which we do not have yet.  However, we can use strucutures which can be just variables.
       {confess "Cannot run subroutine as it has parameters, uses structures instead";
       }
     }
    else                                                                        # Run not requested
     {return $s                                                                 # Return the label of a pre-existing copy of the code. Make sure that the name is different for different subs as otherwise the unexpected results occur.
     }
   };

  my $name = $options{name};                                                    # Subroutine name
  $name or confess "Name required for subroutine, use name=>";
  if ($name and my $s = $subroutines{$name})                                    # Return the label of a pre-existing copy of the code possibly after running the subroutine. Make sure that the subroutine name is different for different subs as otherwise the unexpected results occur.
   {return &$run($s);
   }

  my $parameters = $options{parameters};                                        # Optional parameters block
  if (1)                                                                        # Check for duplicate parameters
   {my %c;
    $c{$_}++ && confess "Duplicate parameter $_" for @$parameters;
   }

  SubroutineStartStack;                                                         # Open new stack layout with references to parameters
  my %parameters = map {$_ => R($_)} @$parameters;                              # Create a reference for each parameter.

  my %structureCopies;                                                          # Copies of the structures being passed that can be use inside the subroutine to access their variables in the stack frame of the subroutine
  if (my $structures = $options{structures})                                    # Structure provided in the parameter list
   {for my $name(sort keys %$structures)                                        # Each structure passed
     {$structureCopies{$name} = copyStructureMinusVariables($$structures{$name})# A new copy of the structure with its variables left in place
     }
   }

  my $end   =    Label; Jmp $end;                                               # End label.  Subroutines are only ever called - they are not executed in-line so we jump over the implementation of the subroutine.  This can cause several forward jumps in a row if a number of subroutines are defined together.
  my $start = SetLabel;                                                         # Start label

  my $s = $subroutines{$name} = genHash(__PACKAGE__."::Subroutine",             # Subroutine definition
    start              => $start,                                               # Start label for this subroutine which includes the enter instruction used to create a new stack frame
    end                => $end,                                                 # End label for this subroutine
    name               => $name,                                                # Name of the subroutine from which the entry label is located
    variables          => {%parameters},                                        # Map parameters to references at known positions in the sub
    structureCopies    => \%structureCopies,                                    # Copies of the structures passed to this subroutine with their variables replaced with references
    structureVariables => {},                                                   # Map structure variables to references at known positions in the sub
    options            => \%options,                                            # Options used by the author of the subroutine
    parameters         => $parameters,                                          # Parameters definitions supplied by the author of the subroutine which get mapped in to parameter variables.
    vars               => $VariableStack[-1],                                   # Number of variables in subroutine
    nameString         => Rs($name),                                            # Name of the sub as a string constant in read only storage
   );

  if (my $structures = $options{structures})                                    # Map structures
   {$s->mapStructureVariables(\%structureCopies);
   }

  my $E = @text;                                                                # Code entry that will contain the Enter instruction
  Enter 0, 0;                                                                   # The Enter instruction is 4 bytes long
  &$block({%parameters}, {%structureCopies}, $s);                               # Code with parameters and structures

  my $V = pop @VariableStack;                                                   # Number of variables in subroutine stack frame. As parameters and structures are mapped into variables in the subroutine stack frame these variables will be included in the count as well.

  Leave if $V;                                                                  # Remove frame if there was one
  Ret;                                                                          # Return from the sub
  SetLabel $end;                                                                # The end point of the sub where we return to normal code
  my $w = RegisterSize rax;
  $text[$E] = $V ? <<END : '';                                                  # Rewrite enter instruction now that we know how much stack space we need
  Enter $V*$w, 0
END

  &$run($s)                                                                     # Run subroutine if requested and return its definition definition
 }

sub Nasm::X86::Subroutine::mapStructureVariables($$@)                           # Find the paths to variables in the copies of the structures passed as parameters and replace those variables with references so that in the subroutine we can refer to these variables regardless of where they are actually defined
 {my ($sub, $S, @P) = @_;                                                       # Sub definition, copies of source structures, path through copies of source structures to a variable that becomes a reference
  for my $s(sort keys %$S)                                                      # Source keys
   {my $e = $$S{$s};
    my $r = ref $e;
    next unless $r;

    if ($r =~ m(Variable)i)                                                     # Replace a variable with a reference in the copy of a structure passed in as a parameter
     {push @P, $s;
      my $R = $sub->structureVariables->{dump([@P])} = $$S{$s} = R($e->name);   # Path to a reference in the copy of a structure passed as as a parameter
      pop @P;
     }
    else                                                                        # A reference to something else - for the moment we assume that structures are built from non recursive hash references
     {push @P, $s;                                                              # Extend path
      $sub->mapStructureVariables($e, @P);                                      # Map structure variable
      pop @P;
     }
   }
 }

sub Nasm::X86::Subroutine::uploadStructureVariablesToNewStackFrame($$@)         # Create references to variables in parameter structures from variables in the stack frame of the subroutine.
 {my ($sub, $S, @P) = @_;                                                       # Sub definition, Source tree of input structures, path through sourtce structures tree

  for my $s(sort keys %$S)                                                      # Source keys
   {my $e = $$S{$s};
    my $r = ref $e;
    next unless $r;                                                             # Element in structure is not a variable or another hash describing a sub structure
    if ($r =~ m(Variable)i)                                                     # Variable located
     {push @P, $s;                                                              # Extend path
      my $p = dump([@P]);                                                       # Path as string
      my $R = $sub->structureVariables->{$p};                                   # Reference
      if (defined($R))
       {$sub->uploadToNewStackFrame($e, $R);                                    # Reference to structure variable from subroutine stack frame
       }
      else                                                                      # Unable to locate the corresponding reference
       {confess "No entry for $p in structure variables";
       }
      pop @P;
     }
    else                                                                        # A hash that is not a variable and is therefore assumed to be a non recursive substructure
     {push @P, $s;
      $sub->uploadStructureVariablesToNewStackFrame($e, @P);
      pop @P;
     }
   }
 }

sub Nasm::X86::Subroutine::uploadToNewStackFrame($$$)                           #P Map a variable in the current stack into a reference in the next stack frame being the one that will be used by this sub
 {my ($sub, $source, $target) = @_;                                             # Subroutine descriptor, source variable in the current stack frame, the reference in the new stack frame
  my $label = $source->label;                                                   # Source in current frame

  if ($source->reference)                                                       # Source is a reference
   {Mov r15, "[$label]";
   }
  else                                                                          # Source is not a reference
   {Lea r15, "[$label]";
   }

  my $q = $target->label;
     $q =~ s(rbp) (rsp);                                                        # Labels are based off the stack frame but we are building a new stack frame here so we must rename the stack pointer.
  my $w = RegisterSize r15;
  Mov "[$q-$w*2]", r15;                                                         # Step over subroutine name pointer and previous frame pointer.
 }

sub Nasm::X86::Subroutine::call($%)                                             #P Call a sub optionally passing it parameters.
 {my ($sub, %options) = @_;                                                     # Subroutine descriptor, options

  if (1)                                                                        # Validate options
   {my %o = %options;
    delete $o{$_} for qw(parameters structures);
    if (my @i = sort keys %o)
     {confess "Invalid parameters: ".join(', ',@i);
     }
   }

  my $parameters = $options{parameters};                                        # Parameters hash
  !$parameters or ref($parameters) =~ m(hash)i or confess
    "Parameters must be formatted as a hash";

  my $structures = $options{structures};                                        # Structures hash
  !$structures or ref($structures) =~ m(hash)i or confess
    "Structures must be formatted as a hash";

  if ($parameters)                                                              # Check for invalid or missing parameters
   {my %p = map {$_=>1} $sub->parameters->@*;
    my @m;
    for my $p(sort keys %$parameters)
     {push @m, "Invalid parameter: '$p'" unless $p{$p};
     }
    for my $p(sort keys %p)
     {push @m, "Missing parameter: '$p'" unless defined $$parameters{$p};
     }
    if (@m)
     {push @m, "Valid parameters : ";
           $m[-1] .= join ", ", map {"'$_'"} sort $sub->parameters->@*;
      confess join '', map {"$_\n"} @m;
     }
   }

  if ($structures)                                                              # Check for invalid or missing structures
   {my %s = $sub->options->{structures}->%*;
    my @m;
    for my $s(sort keys %$structures)
     {push @m, "Invalid structure: '$s'" unless $s{$s};
     }
    for my $s(sort keys %s)
     {push @m, "Missing structure: '$s'" unless $$structures{$s};
     }
    if (@m)
     {push @m, "Valid structures : ";
           $m[-1] .= join ", ", map {"'$_'"} sort keys %s;
      confess join '', map {"$_\n"} @m;
     }
   }

  my $w = RegisterSize r15;
  PushR 15;                                                                     # Use this register to transfer between the current frame and the next frame
  Mov "dword[rsp  -$w*3]", $sub->nameString;                                    # Point to subroutine name
  Mov "byte [rsp-1-$w*2]", $sub->vars;                                          # Number of parameters to enable trace back with parameters

  for my $name(sort keys $parameters->%*)                                       # Upload the variables referenced by the parameters to the new stack frame
   {my $s = $$parameters{$name};
    my $t = $sub->variables->{$name};
    $sub->uploadToNewStackFrame($s, $t);
   }

  if ($structures)                                                              # Upload the variables of each referenced structure to the new stack frame
   {$sub->uploadStructureVariablesToNewStackFrame($structures);
   }

  my $mode = 0;   # Assume call by address for the moment
  if ($mode)                                                                    # Dereference and call subroutine
   {Mov r15, $sub->start;
    Mov r15, "[r15]";
    Call r15;
   }
  else                                                                          # Call via label
   {Call $sub->start;
   }
  PopR;
 }

#D1 Comments                                                                    # Inserts comments into the generated assember code.

sub CommentWithTraceBack(@)                                                     # Insert a comment into the assembly code with a traceback showing how it was generated.
 {my (@comment) = @_;                                                           # Text of comment
  my $c = join "", @comment;
#  eval {confess};
#  my $p = dump($@);
  my $p = &subNameTraceBack =~ s(Nasm::X86::) ()gsr;
  push @text, <<END;
; $c  $p
END
 }

sub Comment(@)                                                                  # Insert a comment into the assembly code.
 {my (@comment) = @_;                                                           # Text of comment
  my $c = join "", @comment;
  my ($p, $f, $l) = caller;
  push @text, <<END;
; $c at $f line $l
END
 }

sub DComment(@)                                                                 # Insert a comment into the data segment.
 {my (@comment) = @_;                                                           # Text of comment
  my $c = join "", @comment;
  push @data, <<END;
; $c
END
 }

sub RComment(@)                                                                 # Insert a comment into the read only data segment.
 {my (@comment) = @_;                                                           # Text of comment
  my $c = join "", @comment;
  push @data, <<END;
; $c
END
 }

#D1 Print                                                                       # Print

sub PrintNL($)                                                                  # Print a new line to stdout  or stderr.
 {my ($channel) = @_;                                                           # Channel to write on
  @_ == 1 or confess "One parameter";

  Subroutine
   {SaveFirstFour;
    Mov rax, 1;
    Mov rdi, $channel;                                                          # Write below stack
    my $w = RegisterSize rax;
    Lea  rsi, "[rsp-$w]";
    Mov "QWORD[rsi]", 10;
    Mov rdx, 1;
    Syscall;
    RestoreFirstFour()
   } name => qq(PrintNL_$channel), call=>1;
 }

sub PrintErrNL()                                                                # Print a new line to stderr.
 {@_ == 0 or confess;
  PrintNL($stderr);
 }

sub PrintOutNL()                                                                # Print a new line to stderr.
 {@_ == 0 or confess;
  PrintNL($stdout);
 }

sub PrintString($@)                                                             # Print a constant string to the specified channel.
 {my ($channel, @string) = @_;                                                  # Channel, Strings
  @_ >= 2 or confess "Two or more parameters";

  my $c = join ' ', @string;
  my $l = length($c);
  my $a = Rs($c);

  Subroutine
   {SaveFirstFour;
    Mov rax, 1;
    Mov rdi, $channel;
    Lea rsi, "[$a]";
    Mov rdx, $l;
    Syscall;
    RestoreFirstFour();
   } name => "PrintString_${channel}_${c}", call=>1;
 }

sub PrintStringNL($@)                                                           # Print a constant string to the specified channel followed by a new line.
 {my ($channel, @string) = @_;                                                  # Channel, Strings
  PrintString($channel, @string);
  PrintNL    ($channel);
 }

sub PrintErrString(@)                                                           # Print a constant string to stderr.
 {my (@string) = @_;                                                            # String
  PrintString($stderr, @string);
 }

sub PrintErrStringNL(@)                                                         # Print a constant string to stderr followed by a new line.
 {my (@string) = @_;                                                            # String
  PrintErrString(@string);
  PrintErrNL;
 }

sub PrintOutString(@)                                                           # Print a constant string to stdout.
 {my (@string) = @_;                                                            # String
  PrintString($stdout, @string);
 }

sub PrintOutStringNL(@)                                                         # Print a constant string to stdout followed by a new line.
 {my (@string) = @_;                                                            # String
  PrintOutString(@string);
  PrintOutNL;
 }

sub PrintCString($$)                                                            # Print a zero terminated C style string addressed by a variable on the specified channel.
 {my ($channel, $string) = @_;                                                  # Channel, String

  PushR rax, rdi;
  my $length = &StringLength($string);                                          # Length of string
  $string->setReg(rax);
  $length->setReg(rdi);
  &PrintOutMemory();                                                            # Print string
  PopR;
 }

sub PrintCStringNL($$)                                                          # Print a zero terminated C style string addressed by a variable on the specified channel followed by a new line.
 {my ($channel, $string) = @_;                                                  # Channel, Strings
  PrintCString($channel, $string);
  PrintNL     ($channel);
 }

sub PrintSpace($;$)                                                             # Print a constant number of spaces to the specified channel.
 {my ($channel, $spaces) = @_;                                                  # Channel, number of spaces if not one.
  PrintString($channel, ' ' x ($spaces // 1));
 }

sub PrintErrSpace(;$)                                                           # Print  a constant number of spaces to stderr.
 {my ($spaces) = @_;                                                            # Number of spaces if not one.
  PrintErrString(' ', $spaces);
 }

sub PrintOutSpace(;$)                                                           # Print a constant number of spaces to stdout.
 {my ($spaces) = @_;                                                            # Number of spaces if not one.
  PrintOutString(' ' x $spaces);
 }


sub hexTranslateTable                                                           #P Create/address a hex translate table and return its label.
 {my $h = '0123456789ABCDEF';
  my @t;
  for   my $i(split //, $h)
   {for my $j(split //, $h)
     {my $h = "$i$j";
         $h =~ s(\A00) (..);
         $h =~ s(\A0)  (.);
      push @t, $h;
     }
   }
   Rs @t                                                                        # Constant strings are only saved if they are unique, else a read only copy is returned.
 }

sub PrintRaxInHex($;$)                                                          # Write the content of register rax in hexadecimal in big endian notation to the specified channel.
 {my ($channel, $end) = @_;                                                     # Channel, optional end byte
  @_ == 1 or @_ == 2 or confess "One or two parameters";
  my $hexTranslateTable = hexTranslateTable;
  $end //= 7;                                                                   # Default end byte

  Subroutine
   {SaveFirstFour rax;                                                          # Rax is a parameter
    Mov rdx, rax;                                                               # Content to be printed
    Mov rdi, 2;                                                                 # Length of a byte in hex

    for my $i((7-$end)..7)                                                      # Each byte
     {my $s = $bitsInByte*$i;
      Mov rax, rdx;
      Shl rax, $s;                                                              # Push selected byte high
      Shr rax, (RegisterSize(rax) - 1) * $bitsInByte;                           # Push select byte low
      Shl rax, 1;                                                               # Multiply by two because each entry in the translation table is two bytes long
      Lea rsi, "[$hexTranslateTable]";
      Add rax, rsi;
      PrintMemory($channel);                                                    # Print memory addressed by rax for length specified by rdi
      PrintString($channel, ' ') if $i % 2 and $i < 7;
     }
    RestoreFirstFour;
   } name => "PrintOutRaxInHexOn-$channel-$end", call=>1;
 }

sub PrintErrRaxInHex()                                                          # Write the content of register rax in hexadecimal in big endian notation to stderr.
 {@_ == 0 or confess;
  PrintRaxInHex($stderr);
 }

sub PrintErrRaxInHexNL()                                                        # Write the content of register rax in hexadecimal in big endian notation to stderr followed by a new line.
 {@_ == 0 or confess;
  PrintRaxInHex($stderr);
  PrintErrNL;
 }

sub PrintOutRaxInHex()                                                          # Write the content of register rax in hexadecimal in big endian notation to stout.
 {@_ == 0 or confess;
  PrintRaxInHex($stdout);
 }

sub PrintOutRaxInHexNL()                                                        # Write the content of register rax in hexadecimal in big endian notation to stdout followed by a new line.
 {@_ == 0 or confess;
  PrintRaxInHex($stdout);
  PrintOutNL;
 }

sub PrintRax_InHex($;$)                                                         # Write the content of register rax in hexadecimal in big endian notation to the specified channel replacing zero bytes with __.
 {my ($channel, $end) = @_;                                                     # Channel, optional end byte
  @_ == 1 or @_ == 2 or confess "One or two parameters";
  my $hexTranslateTable = hexTranslateTable;
  $end //= 7;                                                                   # Default end byte

  Subroutine
   {SaveFirstFour rax;                                                          # Rax is a parameter
    Mov rdx, rax;                                                               # Content to be printed
    Mov rdi, 2;                                                                 # Length of a byte in hex

    for my $i((7-$end)..7)                                                      # Each byte
     {my $s = $bitsInByte*$i;
      Mov rax, rdx;
      Shl rax, $s;                                                              # Push selected byte high
      Shr rax, (RegisterSize(rax) - 1) * $bitsInByte;                           # Push select byte low
      Cmp rax, 0;
      IfEq                                                                      # Print __ for zero bytes
      Then
       {PrintString($channel, "__");
       },
      Else                                                                      # Print byte in hexadecimal otherwise
       {Shl rax, 1;                                                             # Multiply by two because each entry in the translation table is two bytes long
        Lea rsi, "[$hexTranslateTable]";
        Add rax, rsi;
        PrintMemory($channel);                                                  # Print memory addressed by rax for length specified by rdi
       };
      PrintString($channel, ' ') if $i % 2 and $i < 7;
     }
    RestoreFirstFour;
   } name => "PrintOutRax_InHexOn-$channel-$end", call=>1;
 }

sub PrintErrRax_InHex()                                                         # Write the content of register rax in hexadecimal in big endian notation to stderr.
 {@_ == 0 or confess;
  PrintRax_InHex($stderr);
 }

sub PrintErrRax_InHexNL()                                                       # Write the content of register rax in hexadecimal in big endian notation to stderr followed by a new line.
 {@_ == 0 or confess;
  PrintRax_InHex($stderr);
  PrintErrNL;
 }

sub PrintOutRax_InHex()                                                         # Write the content of register rax in hexadecimal in big endian notation to stout.
 {@_ == 0 or confess;
  PrintRax_InHex($stdout);
 }

sub PrintOutRax_InHexNL()                                                       # Write the content of register rax in hexadecimal in big endian notation to stdout followed by a new line.
 {@_ == 0 or confess;
  PrintRax_InHex($stdout);
  PrintOutNL;
 }

sub PrintOutRaxInReverseInHex                                                   # Write the content of register rax to stderr in hexadecimal in little endian notation.
 {@_ == 0 or confess;
  Comment "Print Rax In Reverse In Hex";
  Push rax;
  Bswap rax;
  PrintOutRaxInHex;
  Pop rax;
 }

sub PrintOneRegisterInHex($$)                                                   # Print the named register as a hex string.
 {my ($channel, $r) = @_;                                                       # Channel to print on, register to print
  @_ == 2 or confess "Two parameters";

  my $s = Subroutine
   {if   ($r =~ m(\Ar))                                                         # General purpose register
     {if ($r =~ m(\Arax\Z))                                                     # General purpose register - rax
       {PrintRaxInHex($channel);
       }
      else                                                                      # General purpose register not rax
       {PushR rax;
        Mov rax, $r;
        PrintRaxInHex($channel);
        PopR;
       }
     }
    elsif ($r =~ m(\Ak))                                                        # Mask register
     {PushR rax;
      Kmovq rax, $r;
      PrintRaxInHex($channel);
      PopR;
     }
    elsif ($r =~ m(\Axmm))                                                      # Xmm register
     {PushR rax, $r, 7;
      Mov rax, 0b10;
      Kmovq k7, rax;
      Vpcompressq "$r\{k7}", $r;
      Vmovq rax, $r;
      PrintRaxInHex($channel);
      PopR;

      PrintString($channel, "  ");                                              # Separate blocks of bytes with a space
      PushR rax;
      Vmovq rax, $r;
      PrintRaxInHex($channel);
      PopR;
     }
    elsif ($r =~ m(\Aymm))                                                      # Ymm register
     {PushR rax, $r, 7;
      Mov rax, 0b1100;
      Kmovq k7, rax;
      Vpcompressq "$r\{k7}", $r;
      PrintOneRegisterInHex($channel, $r =~ s(\Ay) (x)r);                       # Upper half
      PopR;

      PrintString($channel, " - ");                                             # Separate blocks of bytes with a space

      PrintOneRegisterInHex($channel, $r =~ s(\Ay) (x)r);                       # Lower half
     }
    elsif ($r =~ m(\Azmm))                                                      # Zmm register
     {PushR rax, $r, 7;
      Mov rax, 0b11110000;
      Kmovq k7, rax;
      Vpcompressq "$r\{k7}", $r;
      PrintOneRegisterInHex($channel, $r =~ s(\Az) (y)r);                       # Upper half
      PopR;

      PrintString($channel, " + ");                                             # Separate blocks of bytes with a space
      PrintOneRegisterInHex($channel, $r =~ s(\Az) (y)r);                       # Lower half
     }
   } name => "PrintOneRegister${r}InHexOn$channel";                             # One routine per register printed

  PushR $r;
  $s->call;
  PopR;
 }

sub PrintErrOneRegisterInHex($)                                                 # Print the named register as a hex string on stderr.
 {my ($r) = @_;                                                                 # Register to print
  @_ == 1 or confess "One parameter";
  PrintOneRegisterInHex($stderr, $r)
 }

sub PrintErrOneRegisterInHexNL($)                                               # Print the named register as a hex string on stderr followed by new line.
 {my ($r) = @_;                                                                 # Register to print
  @_ == 1 or confess "One parameter";
  PrintOneRegisterInHex($stderr, $r);
  PrintErrNL;
 }

sub PrintOutOneRegisterInHex($)                                                 # Print the named register as a hex string on stdout.
 {my ($r) = @_;                                                                 # Register to print
  @_ == 1 or confess "One parameter";
  PrintOneRegisterInHex($stdout, $r)
 }

sub PrintOutOneRegisterInHexNL($)                                               # Print the named register as a hex string on stdout followed by new line.
 {my ($r) = @_;                                                                 # Register to print
  @_ == 1 or confess "One parameter";
  PrintOneRegisterInHex($stdout, $r);
  PrintOutNL;
 }

sub PrintRegisterInHex($@)                                                      # Print the named registers as hex strings.
 {my ($channel, @r) = @_;                                                       # Channel to print on, names of the registers to print
  @_ >= 2 or confess "Two or more parameters required";

  for my $r(map{registerNameFromNumber $_} @r)                                  # Each register to print
   {PrintString($channel,  sprintf("%6s: ", $r));                               # Register name
    PrintOneRegisterInHex $channel, $r;
    PrintNL($channel);
   }
 }

sub PrintErrRegisterInHex(@)                                                    # Print the named registers as hex strings on stderr.
 {my (@r) = @_;                                                                 # Names of the registers to print
  PrintRegisterInHex $stderr, @r;
 }

sub PrintOutRegisterInHex(@)                                                    # Print the named registers as hex strings on stdout.
 {my (@r) = @_;                                                                 # Names of the registers to print
  PrintRegisterInHex $stdout, @r;
 }

sub PrintOutRipInHex                                                            #P Print the instruction pointer in hex.
 {@_ == 0 or confess;
  my @regs = qw(rax);
  Subroutine
   {PushR @regs;
    my $l = Label;
    push @text, <<END;
$l:
END
    Lea rax, "[$l]";                                                            # Current instruction pointer
    PrintOutString "rip: ";
    PrintOutRaxInHex;
    PrintOutNL;
    PopR @regs;
   } name=> "PrintOutRipInHex", call => 1;
 }

sub PrintOutRflagsInHex                                                         #P Print the flags register in hex.
 {@_ == 0 or confess;
  my @regs = qw(rax);

  Subroutine
   {PushR @regs;
    Pushfq;
    Pop rax;
    PrintOutString "rfl: ";
    PrintOutRaxInHex;
    PrintOutNL;
    PopR @regs;
   } name=> "PrintOutRflagsInHex", call => 1;
 }

sub PrintOutRegistersInHex                                                      # Print the general purpose registers in hex.
 {@_ == 0 or confess "No parameters required";

  Subroutine
   {#PrintOutRipInHex;
    PrintOutRflagsInHex;

    my @regs = qw(rax);
    PushR @regs;

    my $w = registers_64();
    for my $r(sort @$w)
     {next if $r =~ m(rip|rflags|rbp|rsp);                                      # Modified by print routines so pointless to print
      if ($r eq rax)
       {Pop rax;
        Push rax
       }
      PrintOutString reverse(pad(reverse($r), 3)).": ";
      Mov rax, $r;
      PrintOutRaxInHex;
      PrintOutNL;
     }
    PopR @regs;
   } name=> "PrintOutRegistersInHex", call => 1;
 }

sub PrintErrZF                                                                  # Print the zero flag without disturbing it on stderr.
 {@_ == 0 or confess;

  Pushfq;
  IfNz Then {PrintErrStringNL "ZF=0"}, Else {PrintErrStringNL "ZF=1"};
  Popfq;
 }

sub PrintOutZF                                                                  # Print the zero flag without disturbing it on stdout.
 {@_ == 0 or confess "No parameters";

  Pushfq;
  IfNz Then {PrintOutStringNL "ZF=0"}, Else {PrintOutStringNL "ZF=1"};
  Popfq;
 }

#D2 Print hexadecimal                                                           # Print numbers in hexadecimal right justified in a field

sub PrintRightInHex($$$)                                                        # Print out a number in hex right justified in a field of specified width on the specified channel
 {my ($channel, $number, $width) = @_;                                          # Channel, number as a variable, width of output field as a variable
  @_ == 3 or confess "Three parameters required";

  $channel =~ m(\A(1|2)\Z) or confess "Invalid channel should be stderr or stdout";
  ref($number) =~ m(variable)i or confess "number must be a variable";
  ref($width)  =~ m(variable)i or confess "width must be a variable";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    PushR rax, rdi, r14, r15, xmm0;
    ClearRegisters xmm0;
    $$p{number}->setReg(14);

    K(loop => 16)->for(sub
     {Mov r15, r14;                                                             # Load xmm0 with hexadecimal digits
      And r15, 0xf;
      Cmp r15, 9;
      IfGt
      Then
       {Add r15, ord('A') - 10;
       },
      Else
       {Add r15, ord('0');
       };
      Pslldq xmm0, 1;
      Pinsrb xmm0, r15b, 0;
      Shr r14, 4;
     });

    Block                                                                       # Translate leading zeros to spaces
     {my ($end) = @_;
      for my $i(0..14)
       {Pextrb r15, xmm0, $i;
        Cmp r15b, ord('0');
        Jne $end;
        Mov r15, ord(' ');
        Pinsrb xmm0, r15b, $i;
       }
     };

    PushR xmm0;                                                                 # Print xmm0 within the width of the field
    Mov rax, rsp;
    $$p{width}->setReg(rdi);
    Add rax, 16;
    Sub rax, rdi;
    &PrintOutMemory();
    PopR;
    PopR;
   } name => "PrintRightInHex_${channel}",
     parameters=>[qw(width number)];

  $s->call(parameters => {number => $number, width=>$width});
 }

sub PrintErrRightInHex($$)                                                      # Write the specified variable in hexadecimal right justified in a field of specified width on stderr.
 {my ($number, $width) = @_;                                                    # Number as a variable, width of output field as a variable
  @_ == 2 or confess "Two parameters required";
  PrintRightInHex($stderr, $number, $width);
 }

sub PrintErrRightInHexNL($$)                                                    # Write the specified variable in hexadecimal right justified in a field of specified width on stderr followed by a new line.
 {my ($number, $width) = @_;                                                    # Number as a variable, width of output field as a variable
  @_ == 2 or confess "Two parameters required";
  PrintRightInHex($stderr, $number, $width);
  PrintErrNL;
 }

sub PrintOutRightInHex($$)                                                      # Write the specified variable in hexadecimal right justified in a field of specified width on stdout.
 {my ($number, $width) = @_;                                                    # Number as a variable, width of output field as a variable
  @_ == 2 or confess "Two parameters required";
  PrintRightInHex($stdout, $number, $width);
 }

sub PrintOutRightInHexNL($$)                                                    # Write the specified variable in hexadecimal right justified in a field of specified width on stdout followed by a new line.
 {my ($number, $width) = @_;                                                    # Number as a variable, width of output field as a variable
  @_ == 2 or confess "Two parameters required";
  PrintRightInHex($stdout, $number, $width);
  PrintOutNL;
 }

#D2 Print binary                                                                # Print numbers in binary right justified in a field

sub PrintRightInBin($$$)                                                        # Print out a number in hex right justified in a field of specified width on the specified channel
 {my ($channel, $number, $width) = @_;                                          # Channel, number as a variable, width of output field as a variable
  @_ == 3 or confess "Three parameters required";

  $channel =~ m(\A(1|2)\Z) or confess "Invalid channel should be stderr or stdout";
  ref($number) =~ m(variable)i or confess "number must be a variable";
  ref($width)  =~ m(variable)i or confess "width must be a variable";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    PushR rax, rdi, rsi, r14, r15;
    $$p{number}->setReg(rax);
    Mov rsi, rsp;
    my $bir = RegisterSize(rax) * $bitsInByte;
    Mov r14, rsi;
    Sub rsp, $bir;                                                              # Allocate space on the stack for the maximum length bit string written out as characters

    K(loop => $bir)->for(sub                                                    # Load bits onto stack as characters
     {Dec r14;
      Mov r15, rax;
      And r15, 1;
      Cmp r15, 0;
      IfNe
      Then
       {Mov "byte[r14]", ord('1');
       },
      Else
       {Mov "byte[r14]", ord('0');
       };
      Shr rax, 1;
     });

    K(loop => $bir)->for(sub                                                    # Replace leading zeros with spaces
     {my ($index, $start, $next, $end) = @_;
      Cmp "byte[r14]",ord('0');
      IfEq
      Then
       {Mov "byte[r14]", ord(' ');
       },
      Else
       {Jmp $end;
       };
      Inc r14;
     });

    Mov rax, rsp;                                                               # Write stack in a field of specified width
    $$p{width}->setReg(rdi);
    Add rax, $bir;
    Sub rax, rdi;
    PrintMemory($channel);
    Mov rsp, rsi;                                                               # Restore stack
    PopR;
   } name => "PrintRightInBin_${channel}",
     parameters=>[qw(width number)];

  $s->call(parameters => {number => $number, width=>$width});
 }

sub PrintErrRightInBin($$)                                                      # Write the specified variable in binary right justified in a field of specified width on stderr.
 {my ($number, $width) = @_;                                                    # Number as a variable, width of output field as a variable
  @_ == 2 or confess "Two parameters required";
  PrintRightInBin($stderr, $number, $width);
 }

sub PrintErrRightInBinNL($$)                                                    # Write the specified variable in binary right justified in a field of specified width on stderr followed by a new line.
 {my ($number, $width) = @_;                                                    # Number as a variable, width of output field as a variable
  @_ == 2 or confess "Two parameters required";
  PrintRightInBin($stderr, $number, $width);
  PrintErrNL;
 }

sub PrintOutRightInBin($$)                                                      # Write the specified variable in binary right justified in a field of specified width on stdout.
 {my ($number, $width) = @_;                                                    # Number as a variable, width of output field as a variable
  @_ == 2 or confess "Two parameters required";
  PrintRightInBin($stdout, $number, $width);
 }

sub PrintOutRightInBinNL($$)                                                    # Write the specified variable in binary right justified in a field of specified width on stdout followed by a new line.
 {my ($number, $width) = @_;                                                    # Number as a variable, width of output field as a variable
  @_ == 2 or confess "Two parameters required";
  PrintRightInBin($stdout, $number, $width);
  PrintOutNL;
 }

#D2 Print in decimal                                                            # Print numbers in decimal right justified in fields of specified width.

sub PrintRaxInDec($)                                                            # Print rax in decimal on the specified channel.
 {my ($channel) = @_;                                                           # Channel to write on
  @_ == 1 or confess "One parameter";

  Subroutine
   {PushR rax, rdi, rdx, r9, r10;
    Mov r9, 0;                                                                  # Number of decimal digits
    Mov r10, 10;                                                                # Base of number system
    my $convert = SetLabel;
      Mov rdx, 0;                                                               # Rdx must be clear to receive remainder
      Idiv r10;                                                                 # Remainder after integer division by 10
      Add rdx, 48;                                                              # Convert remainder to ascii
      Push rdx;                                                                 # Save remainder
      Inc r9;                                                                   # Number of digits
      Cmp rax, 0;
    Jnz $convert;

    Mov rdi, 1;                                                                 # Length of each write

    my $print = SetLabel;                                                       # Print digits
      Mov rax, rsp;
      PrintMemory($channel);
      Dec r9;                                                                   # Number of digits
      Pop rax;                                                                  # Remove digit from stack
    Jnz $print;

    PopR;
   } name => "PrintRaxInDec_$channel", call=>1;
 }

sub PrintOutRaxInDec                                                            # Print rax in decimal on stdout.
 {PrintRaxInDec($stdout);
 }

sub PrintOutRaxInDecNL                                                          # Print rax in decimal on stdout followed by a new line.
 {PrintOutRaxInDec;
  PrintOutNL;
 }

sub PrintErrRaxInDec                                                            # Print rax in decimal on stderr.
 {PrintRaxInDec($stderr);
 }

sub PrintErrRaxInDecNL                                                          # Print rax in decimal on stderr followed by a new line.
 {PrintErrRaxInDec;
  PrintErrNL;
 }

sub PrintRaxRightInDec($$)                                                      # Print rax in decimal right justified in a field of the specified width on the specified channel.
 {my ($width, $channel) = @_;                                                   # Width, channel

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    PushR rax, rdi, rdx, r9, r10;
    Mov r9, 0;                                                                  # Number of decimal digits
    Mov r10, 10;                                                                # Base of number system
    my $convert = SetLabel;
      Mov rdx, 0;                                                               # Rdx must be clear to receive remainder
      Idiv r10;                                                                 # Remainder after integer division by 10
      Add rdx, 48;                                                              # Convert remainder to ascii
      Push rdx;                                                                 # Save remainder
      Inc r9;                                                                   # Number of digits
      Cmp rax, 0;
    Jnz $convert;

    Mov rdi, 1;                                                                 # Length of each write
    $$p{width}->setReg(10);                                                     # Pad to this width if necessary
    Cmp r9, r10;
    IfLt
    Then                                                                        # Padding required
     {(V(width => r10) - V(actual => r9))->spaces($channel);
     };

    my $print = SetLabel;                                                       # Print digits
      Mov rax, rsp;
      PrintMemory($channel);
      Dec r9;                                                                   # Number of digits
      Pop rax;                                                                  # Remove digit from stack
    Jnz $print;

    PopR;
   } parameters=>[qw(width)], name => "PrintRaxRightInDec_${channel}";

  $s->call(parameters=>{width => $width});
 }

sub PrintErrRaxRightInDec($)                                                    # Print rax in decimal right justified in a field of the specified width on stderr.
 {my ($width) = @_;                                                             # Width
  PrintRaxRightInDec($width, $stderr);
 }

sub PrintErrRaxRightInDecNL($)                                                  # Print rax in decimal right justified in a field of the specified width on stderr followed by a new line.
 {my ($width) = @_;                                                             # Width
  PrintRaxRightInDec($width, $stderr);
  PrintErrNL;
 }

sub PrintOutRaxRightInDec($)                                                    # Print rax in decimal right justified in a field of the specified width on stdout.
 {my ($width) = @_;                                                             # Width
  PrintRaxRightInDec($width, $stdout);
 }

sub PrintOutRaxRightInDecNL($)                                                  # Print rax in decimal right justified in a field of the specified width on stdout followed by a new line.
 {my ($width) = @_;                                                             # Width
  PrintRaxRightInDec($width, $stdout);
  PrintOutNL;
 }

sub PrintRaxAsText($)                                                           # Print the string in rax on the specified channel.
 {my ($channel) = @_;                                                           # Channel to write on
  @_ == 1 or confess "One parameter";

  my $w = RegisterSize rax;
  PushR rdi, rdx, rax;
  Lzcnt rdi, rax;
  Shr rdi, 3;
  Mov rdx, rdi;
  Mov rdi, 8;
  Sub rdi, rdx;

  Mov rax, rsp;
  PrintMemory($channel);
  PopR;
 }

sub PrintOutRaxAsText                                                           # Print rax as text on stdout.
 {PrintRaxAsText($stdout);
 }

sub PrintOutRaxAsTextNL                                                         # Print rax as text on stdout followed by a new line.
 {PrintRaxAsText($stdout);
  PrintOutNL;
 }

sub PrintErrRaxAsText                                                           # Print rax as text on stderr.
 {PrintRaxAsText($stderr);
 }

sub PrintErrRaxAsTextNL                                                         # Print rax as text on stderr followed by a new line.
 {PrintRaxAsText($stderr);
  PrintOutNL;
 }

sub PrintRaxAsChar($)                                                           # Print the ascii character in rax on the specified channel.
 {my ($channel) = @_;                                                           # Channel to write on
  @_ == 1 or confess "One parameter";

  PushR rdi, rax;
  Mov rax, rsp;
  Mov rdi, 1;
  PrintMemory($channel);
  PopR;
 }

sub PrintOutRaxAsChar                                                           # Print the character in on stdout.
 {PrintRaxAsChar($stdout);
 }

sub PrintOutRaxAsCharNL                                                         # Print the character in on stdout followed by a new line.
 {PrintRaxAsChar($stdout);
  PrintOutNL;
 }

sub PrintErrRaxAsChar                                                           # Print the character in on stderr.
 {PrintRaxAsChar($stderr);
 }

sub PrintErrRaxAsCharNL                                                         # Print the character in on stderr followed by a new line.
 {PrintRaxAsChar($stderr);
  PrintOutNL;
 }

#D1 Variables                                                                   # Variable definitions and operations

#D2 Definitions                                                                 # Variable definitions

sub Variable($;$%)                                                              # Create a new variable with the specified name initialized via an optional expression.
 {my ($name, $expr, %options) = @_;                                             # Name of variable, optional expression initializing variable, options
  my $size   = 3;                                                               # Size  of variable in bytes as a power of 2
  my $width  = 2**$size;                                                        # Size of variable in bytes
  my $const  = $options{constant}  // 0;                                        # Constant
  my $ref    = $options{reference} // 0;                                        # Reference

  $ref and $const and confess "Reference to constant";

  my $label;
  if ($const)                                                                   # Constant variable
   {defined($expr) or confess "Value required for constant";
    $expr =~ m(r) and confess
     "Cannot use register expression $expr to initialize a constant";
    RComment qq(Constant name: "$name", value $expr);
    $label = Rq($expr);
   }
  else                                                                          # Local variable: Position on stack of variable
   {my $stack = ++$VariableStack[-1];
    $label = "rbp-8*($stack)";

    if (defined $expr)                                                          # Initialize variable if an initializer was supplied
     {if ($Registers{$expr} and $expr =~ m(\Ar))                                # Expression is ready to go
       {Mov "[$label]", $expr;
       }
      else                                                                      # Transfer expression
       {PushR 15;
        Mov r15, $expr;
        Mov "[$label]", r15;
        PopR;
       }
     }
   }

  genHash(__PACKAGE__."::Variable",                                             # Variable definition
    constant  => $const,                                                        # Constant if true
    expr      => $expr,                                                         # Expression that initializes the variable
    label     => $label,                                                        # Address in memory
    name      => $name,                                                         # Name of the variable
#    level     => scalar @VariableStack,                                        # Lexical level
    reference => $options{reference},                                           # Reference to another variable
#    width     => RegisterSize(rax),                                            # Size of the variable in bytes
   );
 }

#sub G(*;$%)                                                                    # Define a global variable. Global variables with the same name are not necessarily the same variable.  Two global variables are identical iff they have have the same label field.
# {my ($name, $expr, %options) = @_;                                            # Name of variable, initializing expression, options
#  &Variable($name, $expr, global => 1, %options);
# }

sub K($$)                                                                       # Define a constant variable.
 {my ($name, $expr) = @_;                                                       # Name of variable, initializing expression
  &Variable(@_, constant => 1)
 }

sub R(*)                                                                        # Define a reference variable.
 {my ($name) = @_;                                                              # Name of variable
  my $r = &Variable($name);                                                     # The referring variable is 64 bits wide
  $r->reference = 1;                                                            # Mark variable as a reference
  $r                                                                            # Size of the referenced variable
 }

sub V($$)                                                                       # Define a variable.
 {my ($name, $expr) = @_;                                                       # Name of variable, initializing expression
  &Variable(@_)
 }

#D2 Print variables                                                             # Print the values of variables or the memory addressed by them

sub Nasm::X86::Variable::dump($$$;$$)                                           #P Dump the value of a variable to the specified channel adding an optional title and new line if requested.
 {my ($left, $channel, $newLine, $title1, $title2) = @_;                        # Left variable, channel, new line required, optional leading title, optional trailing title
  @_ >= 3 or confess;
  PushR rax, rdi;
  my $label = $left->label;                                                     # Address in memory
  Mov rax, "[$label]";
  Mov rax, "[rax]" if $left->reference;
  PrintString  ($channel, $title1//$left->name.": ") unless defined($title1) && $title1 eq '';
  PrintRaxInHex($channel);
  PrintString  ($channel, $title2) if defined $title2;
  PrintNL      ($channel) if $newLine;
  PopR;
 }

sub Nasm::X86::Variable::err($;$$)                                              # Dump the value of a variable on stderr.
 {my ($left, $title1, $title2) = @_;                                            # Left variable, optional leading title, optional trailing title
  $left->dump($stderr, 0, $title1, $title2);
 }

sub Nasm::X86::Variable::out($;$$)                                              # Dump the value of a variable on stdout.
 {my ($left, $title1, $title2) = @_;                                            # Left variable, optional leading title, optional trailing title
  $left->dump($stdout, 0, $title1, $title2);
 }

sub Nasm::X86::Variable::errNL($;$$)                                            # Dump the value of a variable on stderr and append a new line.
 {my ($left, $title1, $title2) = @_;                                            # Left variable, optional leading title, optional trailing title
  $left->dump($stderr, 1, $title1, $title2);
 }

sub Nasm::X86::Variable::d($;$$)                                                # Dump the value of a variable on stderr and append a new line.
 {my ($left, $title1, $title2) = @_;                                            # Left variable, optional leading title, optional trailing title
  $left->dump($stderr, 1, $title1, $title2);
 }

sub Nasm::X86::Variable::outNL($;$$)                                            # Dump the value of a variable on stdout and append a new line.
 {my ($left, $title1, $title2) = @_;                                            # Left variable, optional leading title, optional trailing title
  $left->dump($stdout, 1, $title1, $title2);
 }

sub Nasm::X86::Variable::debug($)                                               # Dump the value of a variable on stdout with an indication of where the dump came from.
 {my ($left) = @_;                                                              # Left variable
  PushR rax, rdi;
  Mov rax, $left->label;                                                        # Address in memory
  Mov rax, "[rax]";
  &PrintErrString(pad($left->name, 32).": ");
  &PrintErrRaxInHex();
  my ($p, $f, $l) = caller(0);                                                  # Position of caller in file
  &PrintErrString("               at $f line $l");
  &PrintErrNL();
  PopR;
 }

#D3 Decimal representation                                                      # Print out a variable as a decimal number

sub Nasm::X86::Variable::errInDec($;$$)                                         # Dump the value of a variable on stderr in decimal.
 {my ($number, $title1, $title2) = @_;                                          # Number as variable, optional leading title, optional trailing title
  PrintErrString($title1 // $number->name.": ");
  PushR rax;
  $number->setReg(rax);
  PrintRaxInDec($stderr);
  PopR;
  PrintErrString($title2) if $title2;
 }

sub Nasm::X86::Variable::errInDecNL($;$$)                                       # Dump the value of a variable on stderr in decimal followed by a new line.
 {my ($number, $title1, $title2) = @_;                                          # Number as variable, optional leading title, optional trailing title
  $number->errInDec($title1, $title2);
  PrintErrNL;
 }

sub Nasm::X86::Variable::outInDec($;$$)                                         # Dump the value of a variable on stdout in decimal.
 {my ($number, $title1, $title2) = @_;                                          # Number as variable, optional leading title, optional trailing title
  PrintOutString($title1 // $number->name.": ");
  PushR rax;
  $number->setReg(rax);
  PrintRaxInDec($stdout);
  PopR;
  PrintOutString($title2) if $title2;
 }

sub Nasm::X86::Variable::outInDecNL($;$$)                                       # Dump the value of a variable on stdout in decimal followed by a new line.
 {my ($number, $title1, $title2) = @_;                                          # Number as variable, optional leading title, optional trailing title
  $number->outInDec($title1, $title2);
  PrintOutNL;
 }

#D3 Decimal representation right justified                                      # Print out a variable as a decimal number right adjusted in a field of specified width

sub Nasm::X86::Variable::rightInDec($$$)                                        # Dump the value of a variable on the specified channel as a decimal  number right adjusted in a field of specified width.
 {my ($number, $channel, $width) = @_;                                          # Number as variable, channel, width
  PushR rax;
  $number->setReg(rax);
  PrintRaxRightInDec($width, $channel);
  PopR;
 }

sub Nasm::X86::Variable::errRightInDec($$)                                      # Dump the value of a variable on stderr as a decimal number right adjusted in a field of specified width.
 {my ($number, $width) = @_;                                                    # Number, width
  $number->rightInDec($stdout, $width);
 }

sub Nasm::X86::Variable::errRightInDecNL($$)                                    # Dump the value of a variable on stderr as a decimal number right adjusted in a field of specified width followed by a new line.
 {my ($number, $width) = @_;                                                    # Number, width
  $number->rightInDec($stdout, $width);
  PrintErrNL;
 }

sub Nasm::X86::Variable::outRightInDec($$)                                      # Dump the value of a variable on stdout as a decimal number right adjusted in a field of specified width.
 {my ($number, $width) = @_;                                                    # Number, width
  $number->rightInDec($stdout, $width);
 }

sub Nasm::X86::Variable::outRightInDecNL($$)                                    # Dump the value of a variable on stdout as a decimal number right adjusted in a field of specified width followed by a new line.
 {my ($number, $width) = @_;                                                    # Number, width
  $number->rightInDec($stdout, $width);
  PrintOutNL;
 }

#D2 Hexadecimal representation, right justified                                 # Print number variables in hexadecimal right justified in fields of specified width.

sub Nasm::X86::Variable::rightInHex($$$)                                        # Write the specified variable number in hexadecimal right justified in a field of specified width to the specified channel.
 {my ($number, $channel, $width) = @_;                                          # Number to print as a variable, channel to print on, width of output field
  @_ == 3 or confess "Three parameters";
  PrintRightInHex($channel, $number, $width);
 }

sub Nasm::X86::Variable::errRightInHex($$)                                      # Write the specified variable number in hexadecimal right justified in a field of specified width to stderr
 {my ($number, $width) = @_;                                                    # Number to print as a variable, width of output field
  @_ == 2 or confess "Two parameters";
  PrintRightInHex($stderr, $number, $width);
 }

sub Nasm::X86::Variable::errRightInHexNL($$)                                    # Write the specified variable number in hexadecimal right justified in a field of specified width to stderr followed by a new line
 {my ($number, $width) = @_;                                                    # Number to print as a variable, width of output field
  @_ == 2 or confess "Two parameters";
  PrintRightInHex($stderr, $number, $width);
  PrintErrNL;
 }

sub Nasm::X86::Variable::outRightInHex($$)                                      # Write the specified variable number in hexadecimal right justified in a field of specified width to stdout
 {my ($number, $width) = @_;                                                    # Number to print as a variable, width of output field
  @_ == 2 or confess "Two parameters";
  PrintRightInHex($stdout, $number, $width);
 }

sub Nasm::X86::Variable::outRightInHexNL($$)                                    # Write the specified variable number in hexadecimal right justified in a field of specified width to stdout followed by a new line
 {my ($number, $width) = @_;                                                    # Number to print as a variable, width of output field
  @_ == 2 or confess "Two parameters";
  PrintRightInHex($stdout, $number, $width);
  PrintOutNL;
 }

#D2 Binary representation, right justified                                      # Print number variables in binary right justified in fields of specified width.

sub Nasm::X86::Variable::rightInBin($$$)                                        # Write the specified variable number in binary right justified in a field of specified width to the specified channel.
 {my ($number, $channel, $width) = @_;                                          # Number to print as a variable, channel to print on, width of output field
  @_ == 3 or confess "Three parameters";
  PrintRightInBin($channel, $number, $width);
 }

sub Nasm::X86::Variable::errRightInBin($$)                                      # Write the specified variable number in binary right justified in a field of specified width to stderr
 {my ($number, $width) = @_;                                                    # Number to print as a variable, width of output field
  @_ == 2 or confess "Two parameters";
  PrintRightInBin($stderr, $number, $width);
 }

sub Nasm::X86::Variable::errRightInBinNL($$)                                    # Write the specified variable number in binary right justified in a field of specified width to stderr followed by a new line
 {my ($number, $width) = @_;                                                    # Number to print as a variable, width of output field
  @_ == 2 or confess "Two parameters";
  PrintRightInBin($stderr, $number, $width);
  PrintErrNL;
 }

sub Nasm::X86::Variable::outRightInBin($$)                                      # Write the specified variable number in binary right justified in a field of specified width to stdout
 {my ($number, $width) = @_;                                                    # Number to print as a variable, width of output field
  @_ == 2 or confess "Two parameters";
  PrintRightInBin($stdout, $number, $width);
 }

sub Nasm::X86::Variable::outRightInBinNL($$)                                    # Write the specified variable number in binary right justified in a field of specified width to stdout followed by a new line
 {my ($number, $width) = @_;                                                    # Number to print as a variable, width of output field
  @_ == 2 or confess "Two parameters";
  PrintRightInBin($stdout, $number, $width);
  PrintOutNL;
 }

#D3 Spaces                                                                      # Print out a variable number of spaces

sub Nasm::X86::Variable::spaces($$)                                             # Print the specified number of spaces to the specified channel.
 {my ($count, $channel) = @_;                                                   # Number of spaces, channel
  $count->for(sub {PrintSpace $channel});
 }

sub Nasm::X86::Variable::errSpaces($)                                           # Print the specified number of spaces to stderr.
 {my ($count) = @_;                                                             # Number of spaces
  $count->spaces($stderr);
 }

sub Nasm::X86::Variable::outSpaces($)                                           # Print the specified number of spaces to stdout.
 {my ($count) = @_;                                                             # Number of spaces
  $count->spaces($stdout);
 }

#D3 C style zero terminated strings                                             # Print out C style zero terminated strings.

sub Nasm::X86::Variable::errCString($)                                          # Print a zero terminated C style string addressed by a variable on stderr.
 {my ($string) = @_;                                                            # String
  PrintCString($stderr, $string);
 }

sub Nasm::X86::Variable::errCStringNL($)                                        # Print a zero terminated C style string addressed by a variable on stderr followed by a new line.
 {my ($string) = @_;                                                            # String
  $string->errCString($string);
  PrintErrNL;
 }

sub Nasm::X86::Variable::outCString($)                                          # Print a zero terminated C style string addressed by a variable on stdout.
 {my ($string) = @_;                                                            # String
  PrintCString($stdout, $string);
 }

sub Nasm::X86::Variable::outCStringNL($)                                        # Print a zero terminated C style string addressed by a variable on stdout followed by a new line.
 {my ($string) = @_;                                                            # String
  $string->outCString;
  PrintOutNL;
 }

#D2 Operations                                                                  # Variable operations

if (1)                                                                          # Define operator overloading for Variables
 {package Nasm::X86::Variable;
  use overload
    '+'  => \&add,
    '-'  => \&sub,
    '*'  => \&times,
    '/'  => \&divide,
    '%'  => \&mod,
   '=='  => \&eq,
   '!='  => \&ne,
   '>='  => \&ge,
    '>'  => \&gt,
   '<='  => \&le,
   '<'   => \&lt,
   '++'  => \&inc,
   '--'  => \&dec,
   '""'  => \&str,
#  '&'   => \&and,                                                              # We use the zero flag as the bit returned by a Boolean operation so we cannot implement '&' or '|' which were previously in use because '&&' and '||' and "and" and "or" are all disallowed in Perl operator overloading.
#  '|'   => \&or,
   '+='  => \&plusAssign,
   '-='  => \&minusAssign,
   '='   => \&equals,
   '<<'  => \&shiftLeft,
   '>>'  => \&shiftRight,
  '!'    => \&not,
 }

sub Nasm::X86::Variable::call($)                                                # Execute the call instruction for a target whose address is held in the specified variable.
 {my ($target) = @_;                                                            # Variable containing the address of the code to call
  $target->setReg(rdi);                                                         # Address of code to call
  Call rdi;                                                                     # Call referenced code
 }

sub Nasm::X86::Variable::address($;$)                                           # Get the address of a variable with an optional offset.
 {my ($left, $offset) = @_;                                                     # Left variable, optional offset
  my $o = $offset ? "+$offset" : "";
  "[".$left-> label."$o]"
 }

sub Nasm::X86::Variable::clone($$)                                              # Clone a variable to make a new variable.
 {my ($variable, $name) = @_;                                                   # Variable to clone, new name for variable
  @_ == 2 or confess "Two parameters";
  my $c = V($name => undef);                                                    # Use supplied name or fall back on existing name
  $c->copy($variable);                                                          # Copy into created variable
  $c                                                                            # Return the clone of the variable
 }

sub Nasm::X86::Variable::copy($$)                                               # Copy one variable into another.
 {my ($left, $right) = @_;                                                      # Left variable, right variable
  @_ == 2 or confess "Two parameters";

  my $l = $left ->address;
  my $r = ref($right) ? $right->address : $right;                               # Variable address or register expression (which might in fact be a constant)

  Mov rdi, $r;                                                                  # Load right hand side

  if (ref($right) and $right->reference)                                        # Dereference a reference
   {Mov rdi, "[rdi]";
   }

  if ($left ->reference)                                                        # Copy a reference
   {Mov rsi, $l;
    Mov "[rsi]", rdi;
   }
  else                                                                          # Copy a non reference
   {Mov $l, rdi;
   }
  $left                                                                         # Return the variable on the left now that it has had the right hand side copied into it.
 }

sub Nasm::X86::Variable::copyRef($$)                                            # Copy a reference to a variable.
 {my ($left, $right) = @_;                                                      # Left variable, right variable
  @_ == 2 or confess "Two parameters";

  $left->reference  or confess "Left hand side must be a reference";

  my $l = $left ->address;
  my $r = $right->address;

  if ($right->reference)                                                        # Right is a reference so we copy its value to create a new reference to the original data
   {Mov rdi, $r;
   }
  else                                                                          # Right is not a reference so we copy its address to make a reference to the data
   {Lea rdi, $r;
   }
  Mov $l, rdi;                                                                  # Save value of address in left

  $left;                                                                        # Chain
 }

sub Nasm::X86::Variable::copyZF($)                                              # Copy the current state of the zero flag into a variable.
 {my ($var) = @_;                                                               # Variable
  @_ == 1 or confess "One parameter";

  my $a = $var->address;                                                        # Address of the variable

  PushR (rax);
  Lahf;                                                                         # Save flags to ah: (SF:ZF:0:AF:0:PF:1:CF)
  Shr ah, 6;                                                                    # Put zero flag in bit zero
  And ah, 1;                                                                    # Isolate zero flag
  Mov $a, ah;                                                                   # Save zero flag
  PopR;
 }

sub Nasm::X86::Variable::copyZFInverted($)                                      # Copy the opposite of the current state of the zero flag into a variable.
 {my ($var) = @_;                                                               # Variable
  @_ == 1 or confess "One parameter";

  my $a = $var->address;                                                        # Address of the variable

  PushR (rax, r15);
  Lahf;                                                                         # Save flags to ah: (SF:ZF:0:AF:0:PF:1:CF)
  Shr ah, 6;                                                                    # Put zero flag in bit zero
  Not ah;                                                                       # Invert zero flag
  And ah, 1;                                                                    # Isolate zero flag
  if ($var->reference)                                                          # Dereference and save
   {PushR rdx;
    Mov rdx, $a;
    Mov "[rdx]", ah;                                                            # Save zero flag
    PopR rdx;
   }
  else                                                                          # Save without dereferencing
   {Mov $a, ah;                                                                 # Save zero flag
   }
  PopR;
 }

sub Nasm::X86::Variable::equals($$$)                                            # Equals operator.
 {my ($op, $left, $right) = @_;                                                 # Operator, left variable,  right variable
  $op
 }

sub Nasm::X86::Variable::assign($$$)                                            # Assign to the left hand side the value of the right hand side.
 {my ($left, $op, $right) = @_;                                                 # Left variable, operator, right variable
  $left->constant and confess "cannot assign to a constant";

  Comment "Variable assign";
  PushR 14, 15;
  Mov r14, $left ->address;
  if ($left->reference)                                                         # Dereference left if necessary
   {Mov r14, "[r14]";
   }
  if (!ref($right))                                                             # Load right constant
   {Mov r15, $right;
   }
  else                                                                          # Load right variable
   {Mov r15, $right->address;
    if ($right->reference)                                                      # Dereference right if necessary
     {Mov r15, "[r15]";
     }
   }
  &$op(r14, r15);
  if ($left->reference)                                                         # Store in reference on left if necessary
   {PushR 13;
    Mov r13, $left->address;
    Mov "[r13]", r14;
    PopR;
   }
  else                                                                          # Store in variable
   {Mov $left ->address, r14;
   }
  PopR;

  $left;
 }

sub Nasm::X86::Variable::plusAssign($$)                                         # Implement plus and assign.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  $left->assign(\&Add, $right);
 }

sub Nasm::X86::Variable::minusAssign($$)                                        # Implement minus and assign.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  $left->assign(\&Sub, $right);
 }

sub Nasm::X86::Variable::arithmetic($$$$)                                       # Return a variable containing the result of an arithmetic operation on the left hand and right hand side variables.
 {my ($op, $name, $left, $right) = @_;                                          # Operator, operator name, Left variable,  right variable

  my $l = $left ->address;
  my $r = ref($right) ? $right->address : $right;                               # Right can be either a variable reference or a constant

  Comment "Arithmetic Start";
  PushR (r14, r15);
  Mov r15, $l;
  if ($left->reference)                                                         # Dereference left if necessary
   {Mov r15, "[r15]";
   }
  Mov r14, $r;
  if (ref($right) and $right->reference)                                        # Dereference right if necessary
   {Mov r14, "[r14]";
   }
  &$op(r15, r14);
  my $v = V(join(' ', '('.$left->name, $name, (ref($right) ? $right->name : $right).')'), r15);
  PopR;
  Comment "Arithmetic End";

  return $v;
 }

sub Nasm::X86::Variable::add($$)                                                # Add the right hand variable to the left hand variable and return the result as a new variable.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  Nasm::X86::Variable::arithmetic(\&Add, q(add), $left, $right);
 }

sub Nasm::X86::Variable::sub($$)                                                # Subtract the right hand variable from the left hand variable and return the result as a new variable.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  Nasm::X86::Variable::arithmetic(\&Sub, q(sub), $left, $right);
 }

sub Nasm::X86::Variable::times($$)                                              # Multiply the left hand variable by the right hand variable and return the result as a new variable.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  Nasm::X86::Variable::arithmetic(\&Imul, q(times), $left, $right);
 }

sub Nasm::X86::Variable::division($$$)                                          # Return a variable containing the result or the remainder that occurs when the left hand side is divided by the right hand side.
 {my ($op, $left, $right) = @_;                                                 # Operator, Left variable,  right variable

  my $l = $left ->address;
  my $r = ref($right) ? $right->address : $right;                               # Right can be either a variable reference or a constant
  PushR rax, rdx, r15;
  Mov rax, $l;
  Mov rax, "[rax]" if $left->reference;
  Mov r15, $r;
  Mov r15, "[r15]" if ref($right) and $right->reference;
  Idiv r15;
  my $v = V(join(' ', '('.$left->name, $op, (ref($right) ? $right->name : '').')'), $op eq "%" ? rdx : rax);
  PopR;
  $v;
 }

sub Nasm::X86::Variable::divide($$)                                             # Divide the left hand variable by the right hand variable and return the result as a new variable.
 {my ($left, $right) = @_;                                                      # Left variable, right variable
  Nasm::X86::Variable::division("/", $left, $right);
 }

sub Nasm::X86::Variable::mod($$)                                                # Divide the left hand variable by the right hand variable and return the remainder as a new variable.
 {my ($left, $right) = @_;                                                      # Left variable, right variable
  Nasm::X86::Variable::division("%", $left, $right);
 }

sub Nasm::X86::Variable::shiftLeft($$)                                          # Shift the left hand variable left by the number of bits specified in the right hand variable and return the result as a new variable.
 {my ($left, $right) = @_;                                                      # Left variable, right variable
  PushR rcx, r15;
  $left ->setReg(15);                                                           # Value to shift
  confess "Variable required not $right" unless ref($right);
  $right->setReg(rcx);                                                          # Amount to shift
  Shl r15, cl;                                                                  # Shift
  my $r = V "shift left" => r15;                                                # Save result in a new variable
  PopR;
  $r
 }

sub Nasm::X86::Variable::shiftRight($$)                                         # Shift the left hand variable right by the number of bits specified in the right hand variable and return the result as a new variable.
 {my ($left, $right) = @_;                                                      # Left variable, right variable
  PushR rcx, r15;
  $left ->setReg(15);                                                           # Value to shift
  confess "Variable required not $right" unless ref($right);
  $right->setReg(rcx);                                                          # Amount to shift
  Shr r15, cl;                                                                  # Shift
  my $r = V "shift right" => r15;                                               # Save result in a new variable
  PopR;
  $r
 }

sub Nasm::X86::Variable::not($)                                                 # Form two complement of left hand side and return it as a variable.
 {my ($left) = @_;                                                              # Left variable
  $left->setReg(rdi);                                                           # Value to negate
  Not rdi;                                                                      # Two's complement
  V "neg" => rdi;                                                               # Save result in a new variable
 }

sub Nasm::X86::Variable::boolean($$$$)                                          # Combine the left hand variable with the right hand variable via a boolean operator.
 {my ($sub, $op, $left, $right) = @_;                                           # Operator, operator name, Left variable,  right variable

  !ref($right) or ref($right) =~ m(Variable) or confess "Variable expected";
  my $r = ref($right) ? $right->address : $right;                               # Right can be either a variable reference or a constant

  Comment "Boolean Arithmetic Start";
  PushR 15;

  Mov r15, $left ->address;
  if ($left->reference)                                                         # Dereference left if necessary
   {Mov r15, "[r15]";
   }
  if (ref($right) and $right->reference)                                        # Dereference on right if necessary
   {PushR 14;
    Mov r14, $right ->address;
    Mov r14, "[r14]";
    Cmp r15, r14;
    PopR;
   }
  elsif (ref($right))                                                           # Variable but not a reference on the right
   {Cmp r15, $right->address;
   }
  else                                                                          # Constant on the right
   {Cmp r15, $right;
   }

  &$sub(sub {Mov  r15, 1}, sub {Mov  r15, 0});
  my $v = V(join(' ', '('.$left->name, $op, (ref($right) ? $right->name : '').')'), r15);

  PopR;
  Comment "Boolean Arithmetic end";

  $v
 }

sub Nasm::X86::Variable::booleanZF($$$$)                                        # Combine the left hand variable with the right hand variable via a boolean operator and indicate the result by setting the zero flag if the result is true.
 {my ($sub, $op, $left, $right) = @_;                                           # Operator, operator name, Left variable,  right variable

  !ref($right) or ref($right) =~ m(Variable) or confess "Variable expected";
  my $r = ref($right) ? $right->address : $right;                               # Right can be either a variable reference or a constant

  Comment "Boolean ZF Arithmetic Start";
  PushR 15;

  Mov r15, $left ->address;
  if ($left->reference)                                                         # Dereference left if necessary
   {Mov r15, "[r15]";
   }
  if (ref($right) and $right->reference)                                        # Dereference on right if necessary
   {PushR 14;
    Mov r14, $right ->address;
    Mov r14, "[r14]";
    Cmp r15, r14;
    PopR;
   }
  elsif (ref($right))                                                           # Variable but not a reference on the right
   {Cmp r15, $right->address;
   }
  else                                                                          # Constant on the right
   {Cmp r15, $right;
   }

  &$sub(sub {Cmp rsp, rsp}, sub {Test rsp, rsp});

  PopR;
  Comment "Boolean ZF Arithmetic end";

  V(empty => undef);                                                            # Return an empty variable so that If regenerates the follow on code
 }

sub Nasm::X86::Variable::booleanC($$$$)                                         # Combine the left hand variable with the right hand variable via a boolean operator using a conditional move instruction.
 {my ($cmov, $op, $left, $right) = @_;                                          # Conditional move instruction name, operator name, Left variable,  right variable

  !ref($right) or ref($right) =~ m(Variable) or confess "Variable expected";
  my $r = ref($right) ? $right->address : $right;                               # Right can be either a variable reference or a constant

  PushR 15;
  Mov r15, $left ->address;
  if ($left->reference)                                                         # Dereference left if necessary
   {Mov r15, "[r15]";
   }
  if (ref($right) and $right->reference)                                        # Dereference on right if necessary
   {PushR 14;
    Mov r14, $right ->address;
    Mov r14, "[r14]";
    Cmp r15, r14;
    PopR;
   }
  elsif (ref($right))                                                           # Variable but not a reference on the right
   {Cmp r15, $right->address;
   }
  else                                                                          # Constant on the right
   {Cmp r15, $right;
   }

  Mov r15, 1;                                                                   # Place a one below the stack
  my $w = RegisterSize r15;
  Mov "[rsp-$w]", r15;
  Mov r15, 0;                                                                   # Assume the result was false
  &$cmov(r15, "[rsp-$w]");                                                      # Indicate true result
  my $v = V(join(' ', '('.$left->name, $op, (ref($right) ? $right->name : '').')'), r15);
  PopR;

  $v
 }

sub Nasm::X86::Variable::eq($$)                                                 # Check whether the left hand variable is equal to the right hand variable.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  Nasm::X86::Variable::booleanZF(\&IfEq, q(eq), $left, $right);
 }

sub Nasm::X86::Variable::ne($$)                                                 # Check whether the left hand variable is not equal to the right hand variable.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  Nasm::X86::Variable::booleanZF(\&IfNe, q(ne), $left, $right);
 }

sub Nasm::X86::Variable::ge($$)                                                 # Check whether the left hand variable is greater than or equal to the right hand variable.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  Nasm::X86::Variable::booleanZF(\&IfGe, q(ge), $left, $right);
 }

sub Nasm::X86::Variable::gt($$)                                                 # Check whether the left hand variable is greater than the right hand variable.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  Nasm::X86::Variable::booleanZF(\&IfGt, q(gt), $left, $right);
 }

sub Nasm::X86::Variable::le($$)                                                 # Check whether the left hand variable is less than or equal to the right hand variable.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  Nasm::X86::Variable::booleanZF(\&IfLe, q(le), $left, $right);
 }

sub Nasm::X86::Variable::lt($$)                                                 # Check whether the left hand variable is less than the right hand variable.
 {my ($left, $right) = @_;                                                      # Left variable,  right variable
  Nasm::X86::Variable::booleanZF(\&IfLt, q(lt), $left, $right);
 }

sub Nasm::X86::Variable::isRef($)                                               # Check whether the specified  variable is a reference to another variable.
 {my ($variable) = @_;                                                          # Variable
  my $n = $variable->name;                                                      # Variable name
  $variable->reference
 }

sub Nasm::X86::Variable::setReg($$)                                             # Set the named registers from the content of the variable.
 {my ($variable, $register) = @_;                                               # Variable, register to load

  my $r = registerNameFromNumber $register;
  if (CheckMaskRegister($r))                                                    # Mask register is being set
   {if ($variable->isRef)
     {confess "Cannot set a mask register to the address of a variable";
     }
    else
     {PushR 15;
      Mov r15, $variable->address;
      Kmovq $r, r15;
      PopR;
     }
   }
  else                                                                          # Set normal register
   {if ($variable->isRef)
     {Mov $r, $variable->address;
      Mov $r, "[$r]";
     }
    else
     {Mov $r, $variable->address;
     }
   }

  $register                                                                     # name of register being set
 }

sub Nasm::X86::Variable::getReg($$)                                             # Load the variable from a register expression.
 {my ($variable, $register) = @_;                                               # Variable, register expression to load
  @_ == 2 or confess "Two parameters";
  my $r = registerNameFromNumber $register;
  if ($variable->isRef)                                                         # Move to the location referred to by this variable
   {Comment "Get variable value from register $r";
    my $p = $r eq r15 ? r14 : r15;
    PushR $p;
    Mov $p, $variable->address;
    Mov "[$p]", $r;
    PopR $p;
   }
  else                                                                          # Move to this variable
   {Mov $variable->address, $r;
   }
  $variable                                                                     # Chain
 }

sub Nasm::X86::Variable::getConst($$)                                           # Load the variable from a constant in effect setting a variable to a specified value.
 {my ($variable, $constant) = @_;                                               # Variable, constant to load
  @_ == 2 or confess "Two parameters";
  Mov rdi, $constant;
  $variable->getReg(rdi);
 }

sub Nasm::X86::Variable::incDec($$)                                             # Increment or decrement a variable.
 {my ($left, $op) = @_;                                                         # Left variable operator, address of operator to perform inc or dec
  $left->constant and confess "Cannot increment or decrement a constant";
  my $l = $left->address;
  if ($left->reference)
   {PushR (rdi, rsi);                                                           # Violates the rdi/rsi rule if removed
    Mov rsi, $l;
    Mov rdi, "[rsi]";
    &$op(rdi);
    Mov "[rsi]", rdi;
    PopR;
    return $left;
   }
  else
   {PushR rsi;
    Mov rsi, $l;
    &$op(rsi);
    Mov $l, rsi;
    PopR;
    return $left;
   }
 }

sub Nasm::X86::Variable::inc($)                                                 # Increment a variable.
 {my ($left) = @_;                                                              # Variable
  $left->incDec(\&Inc);
 }

sub Nasm::X86::Variable::dec($)                                                 # Decrement a variable.
 {my ($left) = @_;                                                              # Variable
  $left->incDec(\&Dec);
 }

sub Nasm::X86::Variable::str($)                                                 # The name of the variable.
 {my ($left) = @_;                                                              # Variable
  $left->name;
 }

sub Nasm::X86::Variable::min($$)                                                # Minimum of two variables.
 {my ($left, $right) = @_;                                                      # Left variable, right variable or constant
  PushR (r12, r14, r15);
  $left->setReg(14);

  if (ref($right))                                                              # Right hand side is a variable
   {$right->setReg(15);
   }
  else                                                                          # Right hand side is a constant
   {Mov r15, $right;
   }

  Cmp r14, r15;
  Cmovg  r12, r15;
  Cmovle r12, r14;
  my $r = V("min", r12);
  PopR;
  $r
 }

sub Nasm::X86::Variable::max($$)                                                # Maximum of two variables.
 {my ($left, $right) = @_;                                                      # Left variable, right variable or constant
  PushR (r12, r14, r15);
  $left->setReg(14);

  if (ref($right))                                                              # Right hand side is a variable
   {$right->setReg(15);
   }
  else                                                                          # Right hand side is a constant
   {Mov r15, $right;
   }

  Cmp r14, r15;
  Cmovg  r12, r14;
  Cmovle r12, r15;

  my $r = V("max", r12);
  PopR;
  $r
 }

sub Nasm::X86::Variable::and($$)                                                # And two variables.
 {my ($left, $right) = @_;                                                      # Left variable, right variable
  PushR (r14, r15);
  Mov r14, 0;
  $left->setReg(15);
  Cmp r15, 0;
  &IfNe (
    sub
     {$right->setReg(15);
      Cmp r15, 0;
      &IfNe(sub {Add r14, 1});
     }
   );
  my $r = V("And(".$left->name.", ".$right->name.")", r14);
  PopR;
  $r
 }

sub Nasm::X86::Variable::or($$)                                                 # Or two variables.
 {my ($left, $right) = @_;                                                      # Left variable, right variable
  PushR (r14, r15);
  Mov r14, 1;
  $left->setReg(15);
  Cmp r15, 0;
  &IfEq (
    sub
     {$right->setReg(15);
      Cmp r15, 0;
      &IfEq(sub {Mov r14, 0});
     }
   );
  my $r = V("Or(".$left->name.", ".$right->name.")", r14);
  PopR;
  $r
 }

sub Nasm::X86::Variable::setMask($$$)                                           # Set the mask register to ones starting at the specified position for the specified length and zeroes elsewhere.
 {my ($start, $length, $mask) = @_;                                             # Variable containing start of mask, variable containing length of mask, mask register
  @_ == 3 or confess "Three parameters";

  PushR (r13, r14, r15);
  Mov r15, -1;
  if ($start)                                                                   # Non zero start
   {$start->setReg(14);
    Bzhi r15, r15, r14;
    Not  r15;
    ref($length) or confess "Not a variable";
    $length->setReg(13);
    Add  r14, r13;
   }
  else                                                                          # Starting at zero
   {confess "Deprecated: use setMaskFirst instead";
     $length->setReg(13);
    Mov r14, $length;
   }
  Bzhi r15, r15, r14;
  Kmovq $mask, r15;
  PopR;
 }

sub Nasm::X86::Variable::setMaskFirst($$)                                       # Set the first bits in the specified mask register.
 {my ($length, $mask) = @_;                                                     # Variable containing length to set, mask register
  @_ == 2 or confess "Two parameters";

  PushR my ($l, $b) = ChooseRegisters(2, $mask);                                # Choose two registers not the mask register
  Mov $b, -1;
  $length->setReg($l);
  Bzhi $b, $b, $l;
  Kmovq $mask, $b if $mask =~ m(\Ak)i;                                          # Set mask register if provided
  Mov   $mask, $b if $mask =~ m(\Ar)i;                                          # Set general purpose register if provided
  PopR;
 }

sub Nasm::X86::Variable::setMaskBit($$)                                         # Set a bit in the specified mask register retaining the other bits.
 {my ($index, $mask) = @_;                                                      # Variable containing bit position to set, mask register
  @_ == 2 or confess "Two parameters";
  $mask =~ m(\Ak)i or confess "Mask register required";
  PushR my ($l, $b) = (r14, r15);
  Kmovq $b, $mask;
  $index->setReg($l);
  Bts $b, $l;
  Kmovq $mask, $b;                                                              # Set mask register if provided
  PopR;
 }

sub Nasm::X86::Variable::clearMaskBit($$)                                       # Clear a bit in the specified mask register retaining the other bits.
 {my ($index, $mask) = @_;                                                      # Variable containing bit position to clear, mask register
  @_ == 2 or confess "Two parameters";
  $mask =~ m(\Ak)i or confess "Mask register required";

  PushR my ($l, $b) = (r14, r15);
  Kmovq $b, $mask;
  $index->setReg($l);
  Btc $b, $l;
  Kmovq $mask, $b;                                                              # Set mask register if provided
  PopR;
 }

sub Nasm::X86::Variable::setBit($$)                                             # Set a bit in the specified register retaining the other bits.
 {my ($index, $mask) = @_;                                                      # Variable containing bit position to set, mask register
  @_ == 2 or confess "Two parameters";

  PushR my ($l) = ChooseRegisters(1, $mask);                                    # Choose a register
  $index->setReg($l);
  Bts $mask, $l;
  PopR;
 }

sub Nasm::X86::Variable::clearBit($$)                                           # Clear a bit in the specified mask register retaining the other bits.
 {my ($index, $mask) = @_;                                                      # Variable containing bit position to clear, mask register
  @_ == 2 or confess "Two parameters";

  PushR my ($l) = ChooseRegisters(1, $mask);                                    # Choose a register
  $index->setReg($l);
  Btc $mask, $l;
  PopR;
 }

sub Nasm::X86::Variable::setZmm($$$$)                                           # Load bytes from the memory addressed by specified source variable into the numbered zmm register at the offset in the specified offset moving the number of bytes in the specified variable.
 {my ($source, $zmm, $offset, $length) = @_;                                    # Variable containing the address of the source, number of zmm to load, variable containing offset in zmm to move to, variable containing length of move
  @_ == 4 or confess;
  ref($offset) && ref($length) or confess "Missing variable";                   # Need variables of offset and length
  Comment "Set Zmm $zmm from Memory";
  PushR (k7, r14, r15);
  $offset->setMask($length, k7);                                                # Set mask for target
  $source->setReg(15);
  $offset->setReg(14);                                                          # Position memory for target
  Sub r15, r14;                                                                 # Position memory for target
  Vmovdqu8 "zmm${zmm}{k7}", "[r15]";                                            # Read from memory
  PopR;
 }

sub Nasm::X86::Variable::loadZmm($$)                                            # Load bytes from the memory addressed by the specified source variable into the numbered zmm register.
 {my ($source, $zmm) = @_;                                                      # Variable containing the address of the source, number of zmm to get
  @_ == 2 or confess "Two parameters";

  $source->setReg(rdi);
  Vmovdqu8 "zmm$zmm", "[rdi]";
 }

sub Nasm::X86::Variable::bFromZ($$$)                                            # Get the byte from the numbered zmm register and put it in a variable.
 {my ($variable, $zmm, $offset) = @_;                                           # Variable, numbered zmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  $variable->copy(getBwdqFromMm 'b', "zmm$zmm", $offset);                       # Get the numbered byte|word|double word|quad word from the numbered zmm register and put it in a variable
 }

sub Nasm::X86::Variable::wFromZ($$$)                                            # Get the word from the numbered zmm register and put it in a variable.
 {my ($variable, $zmm, $offset) = @_;                                           # Variable, numbered zmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  $variable->copy(getBwdqFromMm 'w', "zmm$zmm", $offset);                       # Get the numbered byte|word|double word|quad word from the numbered zmm register and put it in a variable
 }

sub Nasm::X86::Variable::dFromZ($$$)                                            # Get the double word from the numbered zmm register and put it in a variable.
 {my ($variable, $zmm, $offset) = @_;                                           # Variable, numbered zmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  $variable->copy(getBwdqFromMm 'd', "zmm$zmm", $offset);                       # Get the numbered byte|word|double word|quad word from the numbered zmm register and put it in a variable
 }

sub Nasm::X86::Variable::qFromZ($$$)                                            # Get the quad word from the numbered zmm register and put it in a variable.
 {my ($variable, $zmm, $offset) = @_;                                           # Variable, numbered zmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  $variable->copy(getBwdqFromMm 'q', "zmm$zmm", $offset);                       # Get the numbered byte|word|double word|quad word from the numbered zmm register and put it in a variable
 }

sub Nasm::X86::Variable::dFromPointInZ($$)                                      # Get the double word from the numbered zmm register at a point specified by the variable and return it in a variable.
 {my ($point, $zmm) = @_;                                                       # Point, numbered zmm
  PushR 7, 14, 15, $zmm;
  $point->setReg(15);
  Kmovq k7, r15;
  my ($z) = zmm $zmm;
  Vpcompressd "$z\{k7}", $z;
  Vpextrd r15d, xmm($zmm), 0;                                                   # Extract dword from corresponding xmm
  my $r = V d => r15;
  PopR;
  $r;
 }

sub Nasm::X86::Variable::dIntoPointInZ($$$)                                     # Put the variable double word content into the numbered zmm register at a point specified by the variable.
 {my ($point, $zmm, $content) = @_;                                             # Point, numbered zmm, content to be inserted as a variable
  PushR 7, 14, 15;
  $content->setReg(14);
  $point->setReg(15);
  Kmovq k7, r15;
  Vpbroadcastd zmmM($zmm, 7), r14d;                                             # Insert dword at desired location
  PopR;
 }

sub Nasm::X86::Variable::putBwdqIntoMm($$$$)                                    # Place the value of the content variable at the byte|word|double word|quad word in the numbered zmm register.
 {my ($content, $size, $mm, $offset) = @_;                                      # Variable with content, size of put, numbered zmm, offset in bytes
  @_ == 4 or confess "Four parameters";

  my $o;                                                                        # The offset into the mm register
  if (ref($offset))                                                             # The offset is being passed in a variable
   {$offset->setReg($o = rsi);
   }
  else                                                                          # The offset is being passed as a register expression
   {$o = $offset;
    Comment "Put $size at $offset in $mm";
    $offset >= 0 && $offset <= RegisterSize $mm or
      confess "Out of range" if $offset =~ m(\A\d+\Z);                          # Check the offset if it is a number
   }

  $content->setReg(rsi);
  my $w = RegisterSize $mm;                                                     # Size of mm register
  Vmovdqu32 "[rsp-$w]", $mm;                                                    # Write below the stack
  Mov "[rsp+$o-$w]",  byteRegister(rsi) if $size =~ m(b);                       # Write byte register
  Mov "[rsp+$o-$w]",  wordRegister(rsi) if $size =~ m(w);                       # Write word register
  Mov "[rsp+$o-$w]", dWordRegister(rsi) if $size =~ m(d);                       # Write double word register
  Mov "[rsp+$o-$w]", rsi                if $size =~ m(q);                       # Write register
  Vmovdqu32 $mm, "[rsp-$w]";                                                    # Read below the stack
 }

sub Nasm::X86::Variable::bIntoX($$$)                                            # Place the value of the content variable at the byte in the numbered xmm register.
 {my ($content, $xmm, $offset) = @_;                                            # Variable with content, numbered xmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  $content->putBwdqIntoMm('b', "xmm$xmm", $offset)                              # Place the value of the content variable at the word in the numbered xmm register
 }

sub Nasm::X86::Variable::wIntoX($$$)                                            # Place the value of the content variable at the word in the numbered xmm register.
 {my ($content, $xmm, $offset) = @_;                                            # Variable with content, numbered xmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  $content->putBwdqIntoMm('w', "xmm$xmm", $offset)                              # Place the value of the content variable at the byte|word|double word|quad word in the numbered xmm register
 }

sub Nasm::X86::Variable::dIntoX($$$)                                            # Place the value of the content variable at the double word in the numbered xmm register.
 {my ($content, $xmm, $offset) = @_;                                            # Variable with content, numbered xmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  $content->putBwdqIntoMm('d', "xmm$xmm", $offset)                              # Place the value of the content variable at the byte|word|double word|quad word in the numbered xmm register
 }

sub Nasm::X86::Variable::qIntoX($$$)                                            # Place the value of the content variable at the quad word in the numbered xmm register.
 {my ($content, $xmm, $offset) = @_;                                            # Variable with content, numbered xmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  $content->putBwdqIntoMm('q', "xmm$xmm", $offset)                              # Place the value of the content variable at the byte|word|double word|quad word in the numbered xmm register
 }

sub Nasm::X86::Variable::bIntoZ($$$)                                            # Place the value of the content variable at the byte in the numbered zmm register.
 {my ($content, $zmm, $offset) = @_;                                            # Variable with content, numbered zmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  checkZmmRegister($zmm);
  $content->putBwdqIntoMm('b', "zmm$zmm", $offset)                              # Place the value of the content variable at the word in the numbered zmm register
 }

sub Nasm::X86::Variable::putWIntoZmm($$$)                                       # Place the value of the content variable at the word in the numbered zmm register.
 {my ($content, $zmm, $offset) = @_;                                            # Variable with content, numbered zmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  checkZmmRegister($zmm);
  $content->putBwdqIntoMm('w', "zmm$zmm", $offset)                              # Place the value of the content variable at the byte|word|double word|quad word in the numbered zmm register
 }

sub Nasm::X86::Variable::dIntoZ($$$)                                            # Place the value of the content variable at the double word in the numbered zmm register.
 {my ($content, $zmm, $offset) = @_;                                            # Variable with content, numbered zmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  checkZmmRegister($zmm);
  $content->putBwdqIntoMm('d', "zmm$zmm", $offset)                              # Place the value of the content variable at the byte|word|double word|quad word in the numbered zmm register
 }

sub Nasm::X86::Variable::qIntoZ($$$)                                            # Place the value of the content variable at the quad word in the numbered zmm register.
 {my ($content, $zmm, $offset) = @_;                                            # Variable with content, numbered zmm, offset in bytes
  @_ == 3 or confess "Three parameters";
  checkZmmRegister $zmm;
  $content->putBwdqIntoMm('q', "zmm$zmm", $offset)                              # Place the value of the content variable at the byte|word|double word|quad word in the numbered zmm register
 }

#D2 Memory                                                                      # Actions on memory described by variables

sub Nasm::X86::Variable::clearMemory($$)                                        # Clear the memory described in this variable.
 {my ($address, $size) = @_;                                                    # Address of memory to clear, size of the memory to clear
  @_ == 2 or confess "Two parameters";
  &ClearMemory(size=>$size, address=>$address);                                 # Free the memory
 }

sub Nasm::X86::Variable::copyMemory($$$)                                        # Copy from one block of memory to another.
 {my ($target, $source, $size) = @_;                                            # Address of target, address of source, length to copy
  @_ == 3 or confess "Three parameters";
  &CopyMemory(target => $target, source => $source, size => $size);             # Copy the memory
 }

sub Nasm::X86::Variable::printMemoryInHexNL($$$)                                # Write, in hexadecimal, the memory addressed by a variable to stdout or stderr.
 {my ($address, $channel, $size) = @_;                                          # Address of memory, channel to print on, number of bytes to print
  @_ == 3 or confess "Three parameters";
  PushR (rax, rdi);
  $address->setReg(rax);
  $size->setReg(rdi);
  &PrintMemoryInHex($channel);
  &PrintNL($channel);
  PopR;
 }

sub Nasm::X86::Variable::printErrMemoryInHexNL($$)                              # Write the memory addressed by a variable to stderr.
 {my ($address, $size) = @_;                                                    # Address of memory, number of bytes to print
  @_ == 2 or confess "Two parameters";
  $address->printMemoryInHexNL($stderr, $size);
 }

sub Nasm::X86::Variable::printOutMemoryInHexNL($$)                              # Write the memory addressed by a variable to stdout.
 {my ($address, $size) = @_;                                                    # Address of memory, number of bytes to print
  @_ == 2 or confess "Two parameters";
  $address->printMemoryInHexNL($stdout, $size);
 }

sub Nasm::X86::Variable::freeMemory($$)                                         # Free the memory addressed by this variable for the specified length.
 {my ($address, $size) = @_;                                                    # Address of memory to free, size of the memory to free
  @_ == 2 or confess "Two parameters";
  &FreeMemory($address, $size);                                                 # Free the memory
 }

sub Nasm::X86::Variable::allocateMemory($)                                      # Allocate the specified amount of memory via mmap and return its address.
 {my ($size) = @_;                                                              # Size
  @_ == 1 or confess "One parameter";
  AllocateMemory($size);
 }

#D2 Structured Programming with variables                                       # Structured programming operations driven off variables.

sub Nasm::X86::Variable::for($&)                                                # Iterate a block a variable number of times.
 {my ($limit, $block) = @_;                                                     # Number of times, Block
  @_ == 2 or confess "Two parameters";
  Comment "Variable::For $limit";
  my $index = V(q(index), 0);                                                   # The index that will be incremented
  my $start = Label;
  my $next  = Label;
  my $end   = Label;
  SetLabel $start;                                                              # Start of loop

  If $index >= $limit, sub {Jge $end};                                          # Condition

  &$block($index, $start, $next, $end);                                         # Execute block

  SetLabel $next;                                                               # Next iteration
  $index++;                                                                     # Increment
  Jmp $start;
  SetLabel $end;
 }

#D1 Operating system                                                            # Interacting with the operating system.

#D2 Processes                                                                   # Create and manage processes

sub Fork()                                                                      # Fork: create and execute a copy of the current process.
 {@_ == 0 or confess;
  Comment "Fork";
  Mov rax, 57;
  Syscall
 }

sub GetPid()                                                                    # Get process identifier.
 {@_ == 0 or confess;
  Comment "Get Pid";

  Mov rax, 39;
  Syscall
 }

sub GetPidInHex()                                                               # Get process identifier in hex as 8 zero terminated bytes in rax.
 {@_ == 0 or confess;
  Comment "Get Pid";
  my $hexTranslateTable = hexTranslateTable;

  my $s = Subroutine
   {SaveFirstFour;
    Mov rax, 39;                                                                # Get pid
    Syscall;
    Mov rdx, rax;                                                               # Content to be printed

    ClearRegisters rax;                                                         # Save a trailing 00 on the stack
    Push ax;
    for my $i(reverse 5..7)
     {my $s = 8*$i;
      Mov rdi,rdx;
      Shl rdi,$s;                                                               # Push selected byte high
      Shr rdi,56;                                                               # Push select byte low
      Shl rdi,1;                                                                # Multiply by two because each entry in the translation table is two bytes long
      Mov ax, "[$hexTranslateTable+rdi]";
      Push ax;
     }
    Pop rax;                                                                    # Get result from stack
    RestoreFirstFourExceptRax;
   } name => "GetPidInHex";

  $s->call;
 }

sub GetPPid()                                                                   # Get parent process identifier.
 {@_ == 0 or confess;
  Comment "Get Parent Pid";

  Mov rax, 110;
  Syscall
 }

sub GetUid()                                                                    # Get userid of current process.
 {@_ == 0 or confess;
  Comment "Get User id";

  Mov rax, 102;
  Syscall
 }

sub WaitPid()                                                                   # Wait for the pid in rax to complete.
 {@_ == 0 or confess;
  Comment "WaitPid - wait for the pid in rax";

    my $s = Subroutine
   {SaveFirstSeven;
    Mov rdi,rax;
    Mov rax, 61;
    Mov rsi, 0;
    Mov rdx, 0;
    Mov r10, 0;
    Syscall;
    RestoreFirstSevenExceptRax;
   } name => "WaitPid";

  $s->call;
 }

sub ReadTimeStampCounter()                                                      # Read the time stamp counter and return the time in nanoseconds in rax.
 {@_ == 0 or confess;

  my $s = Subroutine
   {Comment "Read Time-Stamp Counter";
    PushR rdx;
    ClearRegisters rax;
    Cpuid;
    Rdtsc;
    Shl rdx,32;
    Or rax,rdx;
    PopR;
   } name => "ReadTimeStampCounter";

  $s->call;
 }

#D2 Memory                                                                      # Allocate and print memory

sub PrintMemoryInHex($)                                                         # Dump memory from the address in rax for the length in rdi on the specified channel. As this method prints in blocks of 8 up to 7 bytes will be missing from the end unless the length is a multiple of 8 .
 {my ($channel) = @_;                                                           # Channel
  @_ == 1 or confess "One parameter";
  Comment "Print out memory in hex on channel: $channel";

  my $s = Subroutine
   {my $size = RegisterSize rax;
    SaveFirstFour;

    Test rdi, 0x7;                                                              # Round the number of bytes to be printed
    IfNz
    Then                                                                        # Round up
     {Add rdi, 8;
     };
    And rdi, 0x3f8;                                                             # Limit the number of bytes to be printed to 1024

    Mov rsi, rax;                                                               # Position in memory
    Lea rdi,"[rax+rdi-$size+1]";                                                # Upper limit of printing with an 8 byte register
    For                                                                         # Print string in blocks
     {Mov rax, "[rsi]";
      Bswap rax;
      PrintRaxInHex($channel);
      Mov rdx, rsi;
      Add rdx, $size;
      Cmp rdx, rdi;
      IfLt
      Then
       {PrintString($channel, "  ");
       }
     } rsi, rdi, $size;
    RestoreFirstFour;
   } name=> "PrintOutMemoryInHexOnChannel$channel";

  $s->call;
 }

sub PrintErrMemoryInHex                                                         # Dump memory from the address in rax for the length in rdi on stderr.
 {@_ == 0 or confess;
  PrintMemoryInHex($stderr);
 }

sub PrintOutMemoryInHex                                                         # Dump memory from the address in rax for the length in rdi on stdout.
 {@_ == 0 or confess;
  PrintMemoryInHex($stdout);
 }

sub PrintErrMemoryInHexNL                                                       # Dump memory from the address in rax for the length in rdi and then print a new line.
 {@_ == 0 or confess;
  PrintMemoryInHex($stderr);
  PrintNL($stderr);
 }

sub PrintOutMemoryInHexNL                                                       # Dump memory from the address in rax for the length in rdi and then print a new line.
 {@_ == 0 or confess;
  PrintMemoryInHex($stdout);
  PrintNL($stdout);
 }

sub PrintMemory_InHex($)                                                        # Dump memory from the address in rax for the length in rdi on the specified channel. As this method prints in blocks of 8 up to 7 bytes will be missing from the end unless the length is a multiple of 8 .
 {my ($channel) = @_;                                                           # Channel
  @_ == 1 or confess "One parameter";
  Comment "Print out memory in hex on channel: $channel";

  my $s = Subroutine
   {my $size = RegisterSize rax;
    SaveFirstFour;

    Test rdi, 0x7;                                                              # Round the number of bytes to be printed
    IfNz
    Then                                                                        # Round up
     {Add rdi, 8;
     };
    And rdi, 0x3f8;                                                             # Limit the number of bytes to be printed to 1024

    Mov rsi, rax;                                                               # Position in memory
    Lea rdi,"[rax+rdi-$size+1]";                                                # Upper limit of printing with an 8 byte register
    For                                                                         # Print string in blocks
     {Mov rax, "[rsi]";
      Bswap rax;
      PrintRax_InHex($channel);
      Mov rdx, rsi;
      Add rdx, $size;
      Cmp rdx, rdi;
      IfLt
      Then
       {PrintString($channel, "  ");
       }
     } rsi, rdi, $size;
    RestoreFirstFour;
   } name=> "PrintOutMemory_InHexOnChannel$channel";

  $s->call;
 }

sub PrintErrMemory_InHex                                                        # Dump memory from the address in rax for the length in rdi on stderr.
 {@_ == 0 or confess;
  PrintMemory_InHex($stderr);
 }

sub PrintOutMemory_InHex                                                        # Dump memory from the address in rax for the length in rdi on stdout.
 {@_ == 0 or confess;
  PrintMemory_InHex($stdout);
 }

sub PrintErrMemory_InHexNL                                                      # Dump memory from the address in rax for the length in rdi and then print a new line.
 {@_ == 0 or confess;
  PrintMemory_InHex($stderr);
  PrintNL($stderr);
 }

sub PrintOutMemory_InHexNL                                                      # Dump memory from the address in rax for the length in rdi and then print a new line.
 {@_ == 0 or confess;
  PrintMemory_InHex($stdout);
  PrintNL($stdout);
 }

sub PrintMemory($)                                                              # Print the memory addressed by rax for a length of rdi on the specified channel.
 {my ($channel) = @_;                                                           # Channel
  @_ == 1 or confess "One parameter";

  my $s = Subroutine
   {Comment "Print memory on channel: $channel";
    SaveFirstFour rax, rdi;
    Mov rsi, rax;
    Mov rdx, rdi;
    Mov rax, 1;
    Mov rdi, $channel;
    Syscall;
    RestoreFirstFour();
   } name => "PrintOutMemoryOnChannel$channel";

  $s->call;
 }

sub PrintMemoryNL                                                               # Print the memory addressed by rax for a length of rdi on the specified channel followed by a new line.
 {my ($channel) = @_;                                                           # Channel
  @_ == 1 or confess "One parameter";
  PrintMemory($channel);
  PrintNL($channel);
 }

sub PrintErrMemory                                                              # Print the memory addressed by rax for a length of rdi on stderr.
 {@_ == 0 or confess;
  PrintMemory($stdout);
 }

sub PrintOutMemory                                                              # Print the memory addressed by rax for a length of rdi on stdout.
 {@_ == 0 or confess;
  PrintMemory($stdout);
 }

sub PrintErrMemoryNL                                                            # Print the memory addressed by rax for a length of rdi followed by a new line on stderr.
 {@_ == 0 or confess;
  PrintErrMemory;
  PrintErrNL;
 }

sub PrintOutMemoryNL                                                            # Print the memory addressed by rax for a length of rdi followed by a new line on stdout.
 {@_ == 0 or confess;
  PrintOutMemory;
  PrintOutNL;
 }

sub AllocateMemory($)                                                           # Allocate the variable specified amount of memory via mmap and return its address as a variable.
 {my ($size) = @_;                                                              # Size as a variable
  @_ == 1 or confess "Size required";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    Comment "Allocate memory";
    SaveFirstSeven;

    my %d = getSystemConstantsFromIncludeFile "linux/mman.h",                   # Memory map constants
      qw(MAP_PRIVATE MAP_ANONYMOUS PROT_WRITE PROT_READ);

    my $pa = $d{MAP_PRIVATE} | $d{MAP_ANONYMOUS};
    my $wr = $d{PROT_WRITE}  | $d{PROT_READ};

    Mov rax, 9;                                                                 # Memory map
    $$p{size}->setReg(rsi);                                                     # Amount of memory
    Xor rdi, rdi;                                                               # Anywhere
    Mov rdx, $wr;                                                               # Read write protections
    Mov r10, $pa;                                                               # Private and anonymous map
    Mov r8,  -1;                                                                # File descriptor for file backing memory if any
    Mov r9,  0;                                                                 # Offset into file
    Syscall;
    Cmp rax, -1;                                                                # Check return code
    IfEq
    Then
     {PrintErrTraceBack "Cannot allocate memory, return code -1";
     };
    Cmp eax, 0xffffffea;                                                        # Check return code
    IfEq
    Then
     {PrintErrTraceBack "Cannot allocate memory, return code 0xffffffea";
     };
    Cmp rax, -12;                                                               # Check return code
    IfEq
    Then
     {PrintErrTraceBack "Cannot allocate memory, return code -12";
     };
     $$p{address}->getReg(rax);                                                 # Amount of memory

    RestoreFirstSeven;
   } parameters=>[qw(address size)], name => 'AllocateMemory';

  $s->call(parameters=>{size=>$size, address => my $address = V address => 0});

  $address;
 }

sub FreeMemory($$)                                                              # Free memory specified by variables.
 {my ($address, $size) = @_;                                                    # Variable address of memory, variable size of memory
  @_ == 2 or confess "Address, size to free";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    SaveFirstFour;
    Mov rax, 11;                                                                # Munmap
    $$p{address}->setReg(rdi);                                                  # Address
    $$p{size}   ->setReg(rsi);                                                  # Length
    Syscall;
    RestoreFirstFour;
   } parameters=>[qw(size address)], name=> 'FreeMemory';

  $s->call(parameters => {address=>$address, size=>$size});
 }

sub ClearMemory($$)                                                             # Clear memory wit a variable address and variable length
 {my ($address, $size) = @_;                                                    # Address of memory as a variable, size of memory as a variable
  @_ == 2 or confess "address, size required";
  Comment "Clear memory";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    PushR (zmm0, rax, rdi, rsi, rdx);
    $$p{address}->setReg(rax);
    $$p{size}   ->setReg(rdi);
    Lea rdx, "[rax+rdi]";                                                       # Address of upper limit of buffer

    ClearRegisters zmm0;                                                        # Clear the register that will be written into memory

    Mov rsi, rdi;                                                               # Modulus the size of zmm
    And rsi, 0x3f;                                                              # Remainder modulo 64
    Cmp rsi, 0;                                                                 # Test remainder
    IfNz sub                                                                    # Need to align so that the rest of the clear can be done in full zmm blocks
     {PushR k7;
      V(align => rsi)->setMaskFirst(k7);                                        # Set mask bits
      Vmovdqu8 "[rax]{k7}", zmm0;                                               # Masked move to memory
      PopR;
      Add rax, rsi;                                                             # Update point to clear from
      Sub rdi, rsi;                                                             # Reduce clear length
     };

    For                                                                         # Clear remaining memory in full zmm blocks
     {Vmovdqu64 "[rax]", zmm0;
     } rax, rdx, RegisterSize zmm0;

    PopR;
   } parameters=>[qw(size address)], name => 'ClearMemory';

  $s->call(parameters => {address => $address, size => $size});
 }

sub CopyMemory($$$)                                                             # Copy memory.
 {my ($source, $target, $size) = @_;                                            # Source address variable, target address variable, length variable
  @_ == 3 or confess "Source, target, size required";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    SaveFirstSeven;
    $$p{source}->setReg(rsi);
    $$p{target}->setReg(rax);
    $$p{size}  ->setReg(rdi);
    ClearRegisters rdx;
    For                                                                         # Clear memory
     {Mov "r8b", "[rsi+rdx]";
      Mov "[rax+rdx]", "r8b";
     } rdx, rdi, 1;
    RestoreFirstSeven;
   } parameters=>[qw(source target size)], name => 'CopyMemory';

  $s->call(parameters=>{source => $source, target=>$target, size=>$size});
 }

#D2 Files                                                                       # Interact with the operating system via files.

sub OpenRead()                                                                  # Open a file, whose name is addressed by rax, for read and return the file descriptor in rax.
 {@_ == 0 or confess "Zero parameters";

  my $s = Subroutine
   {my %s = getSystemConstantsFromIncludeFile  "fcntl.h", qw(O_RDONLY);         # Constants for reading a file

    SaveFirstFour;
    Mov rdi,rax;
    Mov rax,2;
    Mov rsi, $s{O_RDONLY};
    Xor rdx,rdx;
    Syscall;
    RestoreFirstFourExceptRax;
   } name=> "OpenRead";

  $s->call;
 }

sub OpenWrite()                                                                 # Create the file named by the terminated string addressed by rax for write.
 {@_ == 0 or confess "Zero parameters";

  my $s = Subroutine
   {my %s = getSystemConstantsFromIncludeFile                                   # Constants for creating a file
      "fcntl.h", qw(O_CREAT O_WRONLY);
    my $write = $s{O_WRONLY} | $s{O_CREAT};

    SaveFirstFour;
    Mov rdi, rax;
    Mov rax, 2;
    Mov rsi, $write;
    Mov rdx, 0x1c0;                                                             # Permissions: u=rwx  1o=x 4o=r 8g=x 10g=w 20g=r 40u=x 80u=r 100u=r 200=T 400g=S 800u=S #0,2,1000, nothing
    Syscall;

    RestoreFirstFourExceptRax;
   } name=> "OpenWrite";

  $s->call;
 }

sub CloseFile()                                                                 # Close the file whose descriptor is in rax.
 {@_ == 0 or confess "Zero parameters";

  my $s = Subroutine
   {Comment "Close a file";
    SaveFirstFour;
    Mov rdi, rax;
    Mov rax, 3;
    Syscall;
    RestoreFirstFourExceptRax;
   } name=> "CloseFile";

  $s->call;
 }

sub StatSize()                                                                  # Stat a file whose name is addressed by rax to get its size in rax.
 {@_ == 0 or confess "Zero parameters";

  my ($F, $S) = (q(sys/stat.h), q(struct stat));                                # Get location of struct stat.st_size field
  my $Size = getStructureSizeFromIncludeFile $F, $S;
  my $off  = getFieldOffsetInStructureFromIncludeFile $F, $S, q(st_size);

  my $s = Subroutine
   {Comment "Stat a file for size";
    SaveFirstFour rax;
    Mov rdi, rax;                                                               # File name
    Mov rax,4;
    Lea rsi, "[rsp-$Size]";
    Syscall;
    Mov rax, "[$off+rsp-$Size]";                                                # Place size in rax
    RestoreFirstFourExceptRax;
   } name=> "StatSize";

  $s->call;
 }

sub ReadChar()                                                                  # Read a character from stdin and return it in rax else return -1 in rax if no character was read.
 {@_ == 0 or confess "Zero parameters";
  my $s = Subroutine
   {my ($p) = @_;
    SaveFirstFour;                                                              # Generated code

    Mov rax, 0;                                                                 # Read
    Mov rdi, 0;                                                                 # Stdin
    Lea rsi, "[rsp-8]";                                                         # Make space on stack
    Mov rdx, 1;                                                                 # One character
    Syscall;

    Cmp rax, 1;
    IfEq
    Then
     {Mov al, "[rsp-8]";
     },
    Else
     {Mov rax, -1;
     };

    RestoreFirstFourExceptRax;
   } name => 'ReadChar';

  $s->call
 }

sub ReadLine()                                                                  # Reads up to 8 characters followed by a terminating return and place them into rax.
 {@_ == 0 or confess "Zero parameters";
  my $s = Subroutine
   {my ($p) = @_;
    PushR rcx, r14, r15;
    ClearRegisters rax, rcx, r14, r15;

    (V max => RegisterSize(rax))->for(sub                                       # Read each character
     {my ($index, $start, $next, $end) = @_;

      ReadChar;
      Cmp rax, 0xf0;                                                            # Too high
      IfGe Then {Jmp $end};
      Cmp rax, 0xa;                                                             # Too low
      IfLe Then {Jmp $end};
      $index->setReg(rcx);
      Shl rcx, 3;
      Shl rax, cl;                                                              # Move into position
      Or r15, rax;
      Add rcx, $bitsInByte;
     });

    Mov rax, r15;                                                               # Return result in rax
    PopR;
   } name => 'ReadLine';

  $s->call
 }

sub ReadInteger()                                                               # Reads an integer in decimal and returns it in rax.
 {@_ == 0 or confess "Zero parameters";
  my $s = Subroutine
   {my ($p) = @_;
    PushR 15;
    ClearRegisters rax, r15;

    (V max => RegisterSize(rax))->for(sub                                       # Read each character
     {my ($index, $start, $next, $end) = @_;

      ReadChar;
      Cmp rax, 0x3A;                                                            # Too high
      IfGe Then {Jmp $end};
      Cmp rax, 0x29;                                                            # Too low
      IfLe Then {Jmp $end};
      Imul r15, 10;                                                             # Move into position
      Sub rax, 0x30;
      Add r15, rax;
     });

    Mov rax, r15;                                                               # Return result in rax
    PopR;
   } name => 'ReadInteger';

  $s->call
 }

sub ReadFile(@)                                                                 # Read a file into memory.
 {my ($File) = @_;                                                              # Variable addressing a zero terminated string naming the file
  @_ == 1 or confess "One parameter required";

  my $s = Subroutine
   {my ($p) = @_;
    Comment "Read a file into memory";
    SaveFirstSeven;                                                             # Generated code
    my $size = V(size => undef);
    my $fdes = V(fdes => undef);

    $$p{file}->setReg(rax);                                                     # File name

    StatSize;                                                                   # File size
    $size->getReg(rax);                                                         # Save file size

    $$p{file}->setReg(rax);                                                     # File name
    OpenRead;                                                                   # Open file for read
    $fdes->getReg(rax);                                                         # Save file descriptor

    my %d  = getSystemConstantsFromIncludeFile                                  # Memory map constants
     "linux/mman.h", qw(MAP_PRIVATE PROT_READ);
    my $pa = $d{MAP_PRIVATE};
    my $ro = $d{PROT_READ};

    Mov rax, 9;                                                                 # Memory map
    $size->setReg(rsi);                                                         # Amount of memory
    Xor rdi, rdi;                                                               # Anywhere
    Mov rdx, $ro;                                                               # Read write protections
    Mov r10, $pa;                                                               # Private and anonymous map
    $fdes->setReg(r8);                                                          # File descriptor for file backing memory
    Mov r9,  0;                                                                 # Offset into file
    Syscall;
    $size       ->setReg(rdi);
    $$p{address}->getReg(rax);
    $$p{size}   ->getReg(rdi);
    RestoreFirstSeven;
   } parameters=>[qw(file address size)], name => 'ReadFile';

  my $file    = ref($File) ? $File : V file => Rs $File;
  my $size    = V(size    => undef);
  my $address = V(address => undef);
  $s->call(parameters=>{file => $file, size=>$size, address=>$address});

  ($address, $size)                                                             # Return address and size of mapped file
 }

sub executeFileViaBash($)                                                       # Execute the file named in a variable
 {my ($file) = @_;                                                              # File variable
  @_ == 1 or confess "File required";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    SaveFirstFour;
    Fork;                                                                       # Fork

    Test rax, rax;

    IfNz                                                                        # Parent
    Then
     {WaitPid;
     },
    Else                                                                        # Child
     {$$p{file}->setReg(rdi);
      Mov rsi, 0;
      Mov rdx, 0;
      Mov rax, 59;
      Syscall;
     };
    RestoreFirstFour;
   } parameters=>[qw(file)], name => 'executeFileViaBash';

  $s->call(parameters=>{file => $file});
 }

sub unlinkFile(@)                                                               # Unlink the named file.
 {my ($file) = @_;                                                              # File variable
  @_ == 1 or confess "File required";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    SaveFirstFour;
    $$p{file}->setReg(rdi);
    Mov rax, 87;
    Syscall;
    RestoreFirstFour;
   } parameters=>[qw(file)], name => 'unlinkFile';

  $s->call(parameters=>{file => $file});
 }

#D1 Hash functions                                                              # Hash functions

sub Hash()                                                                      # Hash a string addressed by rax with length held in rdi and return the hash code in r15.
 {@_ == 0 or confess;

  my $s = Subroutine                                                            # Read file
   {Comment "Hash";

    PushR rax, rdi, k1, zmm0, zmm1;                                             # Save registers
    PushR 15;
    Vpbroadcastq zmm0, rdi;                                                     # Broadcast length through ymm0
    Vcvtuqq2pd   zmm0, zmm0;                                                    # Convert to lengths to float
    Vgetmantps   zmm0, zmm0, 4;                                                 # Normalize to 1 to 2, see: https://hjlebbink.github.io/x86doc/html/VGETMANTPD.html

    Add rdi, rax;                                                               # Upper limit of string

    ForIn                                                                       # Hash in ymm0 sized blocks
     {Vmovdqu ymm1, "[rax]";                                                    # Load data to hash
      Vcvtudq2pd zmm1, ymm1;                                                    # Convert to float
      Vgetmantps zmm0, zmm0, 4;                                                 # Normalize to 1 to 2, see: https://hjlebbink.github.io/x86doc/html/VGETMANTPD.html

      Vmulpd zmm0, zmm1, zmm0;                                                  # Multiply current hash by data
     }
    sub                                                                         # Remainder in partial block
     {Mov r15, -1;
      Bzhi r15, r15, rdi;                                                       # Clear bits that we do not wish to load
      Kmovq k1, r15;                                                            # Take up mask
      Vmovdqu8 "ymm1{k1}", "[rax]";                                             # Load data to hash

      Vcvtudq2pd zmm1, ymm1;                                                    # Convert to float
      Vgetmantps   zmm0, zmm0, 4;                                               # Normalize to 1 to 2, see: https://hjlebbink.github.io/x86doc/html/VGETMANTPD.html

      Vmulpd zmm0, zmm1, zmm0;                                                  # Multiply current hash by data
     }, rax, rdi, RegisterSize ymm0;

    Vgetmantps   zmm0, zmm0, 4;                                                 # Normalize to 1 to 2, see: https://hjlebbink.github.io/x86doc/html/VGETMANTPD.html

    Mov r15, 0b11110000;                                                        # Top 4 to bottom 4
    Kmovq k1, r15;
    Vpcompressq  "zmm1{k1}", zmm0;
    Vaddpd       ymm0, ymm0, ymm1;                                              # Top 4 plus bottom 4

    Mov r15, 0b1100;                                                            # Top 2 to bottom 2
    Kmovq k1, r15;
    Vpcompressq  "ymm1{k1}", ymm0;
    Vaddpd       xmm0, xmm0, xmm1;                                              # Top 2 plus bottom 2

    Pslldq       xmm0, 2;                                                       # Move centers into double words
    Psrldq       xmm0, 4;
    Mov r15, 0b0101;                                                            # Centers to lower quad
    Kmovq k1, r15;
    Vpcompressd  "xmm0{k1}", xmm0;                                              # Compress to lower quad
    PopR r15;

    Vmovq r15, xmm0;                                                            # Result in r15

    PopR;
   } name=> "Hash";

  $s->call;
 }

#D1 Unicode                                                                     # Convert between utf8 and utf32

sub convert_rax_from_utf32_to_utf8                                              # Convert a utf32 character held in rax to a utf8 character held in rax
 {@_ and confess "Zero parameters";

  my $s = Subroutine
   {PushR 14, 15;
    my $success = Label;                                                        # As shown at: https://en.wikipedia.org/wiki/UTF-8
    Cmp rax, 0x7f;                                                              # Ascii
    IfLe Then {Jmp $success};

    Cmp rax, 0x7ff;                                                             # Char size is: 2 bytes
    IfLe
    Then
     {Mov r15, rax;

      Shr r15, 6;                                                               # High byte
      And r15, 0x1f;
      Or  r15, 0xc0;

      Mov r14, rax;                                                             # Low byte
      And r14, 0x3f;
      Or  r14, 0x80;
      Shl r14, 8;
      Or r15, r14;
      Mov rax, r15;
      Jmp $success;
     };

    Cmp rax, 0xffff;                                                            # Char size is: 3 bytes
    IfLe
    Then
     {Mov r15, rax;

      Shr r15, 12;                                                              # High byte
      And r15, 0x0f;
      Or  r15, 0xe0;

      Mov r14, rax;                                                             # Middle byte
      Shr r14, 6;
      And r14, 0x3f;
      Or  r14, 0x80;
      Shl r14, 8;
      Or r15, r14;

      Mov r14, rax;                                                             # Low byte
      And r14, 0x3f;
      Or  r14, 0x80;
      Shl r14, 16;
      Or r15, r14;

      Mov rax, r15;
      Jmp $success;
     };

    Cmp rax, 0x10ffff;                                                          # Char size is: 4 bytes
    IfLe
    Then
     {Mov r15, rax;

      Shr r15, 18;                                                              # High byte
      And r15, 0x03;
      Or  r15, 0xf0;

      Mov r14, rax;                                                             # Middle byte
      Shr r14, 12;
      And r14, 0x3f;
      Or  r14, 0x80;
      Shl r14, 8;
      Or r15, r14;

      Mov r14, rax;                                                             # Middle byte
      Shr r14, 6;
      And r14, 0x3f;
      Or  r14, 0x80;
      Shl r14, 16;
      Or r15, r14;

      Mov r14, rax;                                                             # Low byte
      And r14, 0x3f;
      Or  r14, 0x80;
      Shl r14, 24;
      Or r15, r14;
      Mov rax, r15;
      Jmp $success;
     };

    SetLabel $success;

    PopR;
   } name => 'convert_rax_from_utf32_to_utf8';

  $s->call;
 } # convert_rax_from_utf32_to_utf8

sub GetNextUtf8CharAsUtf32($$$$)                                                # Get the next UTF-8 encoded character from the addressed memory and return it as a UTF-32 char.
 {my ($in, $out, $size, $fail) = @_;                                            # Address of character variable, output character variable, output size of input, output error  if any
  @_ == 4 or confess "In, out, size, fail required";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters

    PushR 11, 12, 13, 14, 15;
    $$p{fail}->getConst(0);                                                     # Clear failure indicator
    $$p{in}->setReg(15);                                                        # Character to convert
    ClearRegisters 14;                                                          # Move to byte register below does not clear the entire register
    Mov r14b, "[r15]";
    my $success = Label;                                                        # As shown at: https://en.wikipedia.org/wiki/UTF-8

    Cmp r14, 0x7f;                                                              # Ascii
    IfLe
    Then
     {$$p{out}->getReg(r14);
      $$p{size}->copy(1);
      Jmp $success;
     };

    Cmp r14, 0xdf;                                                              # Char size is: 2 bytes
    IfLe
    Then
     {Mov r13b, "[r15+1]";
      And r13, 0x3f;
      And r14, 0x1f;
      Shl r14, 6;
      Or  r14,  r13;
      $$p{out}->getReg(r14);
      $$p{size}->copy(2);
      Jmp $success;
     };

    Cmp r14, 0xef;                                                              # Char size is: 3 bytes
    IfLe
    Then
     {Mov r12b, "[r15+2]";
      And r12, 0x3f;
      Mov r13b, "[r15+1]";
      And r13, 0x3f;
      And r14, 0x0f;
      Shl r13,  6;
      Shl r14, 12;
      Or  r14,  r13;
      Or  r14,  r12;
      $$p{out}->getReg(r14);
      $$p{size}->copy(3);
      Jmp $success;
     };

    Cmp r14, 0xf7;                                                              # Char size is: 4 bytes
    IfLe
    Then
     {Mov r11b, "[r15+3]";
      And r11, 0x3f;
      Mov r12b, "[r15+2]";
      And r12, 0x3f;
      Mov r13b, "[r15+1]";
      And r13, 0x3f;
      And r14, 0x07;
      Shl r12,  6;
      Shl r13, 12;
      Shl r14, 18;
      Or  r14,  r13;
      Or  r14,  r12;
      Or  r14,  r11;
      $$p{out}->getReg(r14);
      $$p{size}->copy(4);
      Jmp $success;
     };

    $$p{fail}->getConst(1);                                                     # Conversion failed

    SetLabel $success;

    PopR;
   } parameters=>[qw(in out  size  fail)], name => 'GetNextUtf8CharAsUtf32';

  $s->call(parameters=>{in=>$in, out=>$out, size=>$size, fail=>$fail});
 } # GetNextUtf8CharAsUtf32

sub ConvertUtf8ToUtf32($$$$$)                                                   # Convert a string of utf8 to an allocated block of utf32 and return its address and length.
 {my ($u8, $size8, $u32, $size32, $count) = @_;                                 # utf8 string address variable, utf8 length variable, utf32 string address variable, utf32 length variable, number of utf8 characters converteed
  @_ == 5 or confess "Five parameters required";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    PushR 10, 11, 12, 13, 14, 15;

    my $size = $$p{size8} * 4;                                                  # Estimated length for utf32
    my $address = AllocateMemory $size;

     $$p{u8}            ->setReg(14);                                           # Current position in input string
    ($$p{u8}+$$p{size8})->setReg(15);                                           # Upper limit of input string
    $address->setReg(13);                                                       # Current position in output string
    ClearRegisters 12;                                                          # Number of characters in output string

    ForEver sub                                                                 # Loop through input string  converting each utf8 sequence to utf32
     {my ($start, $end) = @_;
      my ($out, $size, $fail) = (V(out => undef), V(size => undef), V(fail => undef));
      GetNextUtf8CharAsUtf32 V(in => r14), $out, $size, $fail;                  # Get next utf-8 character and convert it to utf32
      If $fail > 0,
      Then
       {PrintErrStringNL "Invalid utf8 character at index:";
        PrintErrRegisterInHex r12;
        Exit(1);
       };

      Inc r12;                                                                  # Count characters converted
      $out->setReg(r11);                                                        # Output character

      Mov  "[r13]",  r11d;
      Add    r13,    RegisterSize eax;                                          # Move up 32 bits output string
      $size->setReg(r10);                                                       # Decoded this many bytes
      Add   r14, r10;                                                           # Move up in input string
      Cmp   r14, r15;
      Jge $end;                                                                 # Exhausted input string
    };

    $$p{u32}   ->copy($address);                                                # Address of allocation
    $$p{size32}->copy($size);                                                   # Size of allocation
    $$p{count} ->getReg(r12);                                                   # Number of unicode points converted from utf8 to utf32
    PopR;
   } parameters=>[qw(u8 size8 u32 size32 count)], name => 'ConvertUtf8ToUtf32';

  $s->call(parameters=>
    {u8=>$u8, size8=>$size8, u32=>$u32, size32=>$size32, count=>$count});
 } # ConvertUtf8ToUtf32

#   4---+---3---+---2---+---1---+---0  Octal not decimal
# 0  CCCCCCCC                          ClassifyInRange                  C == classification
# 1  XXXXXXXX                          ClassifyWithInRange              X == offset in range
# 2  CCCCCCCC                XXXXXXXX  ClassifyWithInRangeAndSaveOffset C == classification, X == offset in range 0-2**10

sub ClassifyRange($$$)                                                          #P Implementation of ClassifyInRange and ClassifyWithinRange.
 {my ($recordOffsetInRange, $address, $size) = @_;                              # Record offset in classification in high byte if 1 else in classification if 2, variable address of utf32 string to classify, variable length of utf32 string to classify
  @_ == 3 or confess "Three parameters";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    my $finish = Label;

    PushR my @save =  (($recordOffsetInRange ? (r11, r12, r13) : ()),           # More registers required if we are recording position in range
                       r14, r15, k6, k7, zmm 29..31);

    Mov r15, 0x88888888;                                                        # Create a mask for the classification bytes
    Kmovq k7, r15;
    Kshiftlq k6, k7, 32;                                                        # Move mask into upper half of register
    Korq  k7, k6, k7;                                                           # Classification bytes masked by k7

    Knotq k7, k7;                                                               # Utf32 characters mask
    Vmovdqu8 "zmm31\{k7}{z}", zmm1;                                             # Utf32 characters at upper end of each range
    Vmovdqu8 "zmm30\{k7}{z}", zmm0;                                             # Utf32 characters at lower end of each range

    $$p{address}->setReg(15);                                                   # Address of first utf32 character
    $$p{size}->for(sub                                                          # Process each utf32 character in the block of memory
     {my ($index, $start, $next, $end) = @_;

      Mov r14d, "[r15]";                                                        # Load utf32 character
      Add r15, RegisterSize r14d;                                               # Move up to next utf32 character
      Vpbroadcastd       zmm29, r14d;                                           # Process 16 copies of the utf32 character
      Vpcmpud  k7,       zmm29, zmm30, 5;                                       # Look for start of range
      Vpcmpud "k6\{k7}", zmm29, zmm31, 2;                                       # Look for end of range
      Ktestw k6, k6;                                                            # Was there a match ?
      Jz $next;                                                                 # No character was matched
                                                                                # Process matched character
      if ($recordOffsetInRange == 1)                                            # Record offset in classification range in high byte as used for bracket matching
       {Vpcompressd "zmm29\{k6}", zmm0;                                         # Place classification byte at start of xmm29
        Vpextrd r13d, xmm29, 0;                                                 # Extract start of range
        Mov r12, r13;                                                           # Copy start of range
        Shr r12, 24;                                                            # Classification start
        And r13, 0x00ffffff;                                                    # Range start
        Sub r14, r13;                                                           # Offset in range
        Add r12, r14;                                                           # Offset in classification
        Mov "[r15-1]", r12b;                                                    # Save classification in high byte as in case 1 above.
       }
      elsif ($recordOffsetInRange == 2)                                         # Record classification in high byte and offset in classification range in low byte as used for alphabets
       {Vpcompressd "zmm29\{k6}", zmm0;                                         # Place classification byte and start of range at start of xmm29
        Vpextrd r13d, xmm29, 0;                                                 # Extract start of range specification
        Mov r12, r13;                                                           # Range classification code and start of range
        Shr r12, 24; Shl r12, 24;                                               # Clear low three bytes
        And r13, 0x00ffffff;                                                    # Utf Range start minus classification code

        Vpcompressd "zmm29\{k6}", zmm1;                                         # Place start of alphabet at start of xmm29
        Vpextrd r11d, xmm29, 0;                                                 # Extract offset of alphabet in range
        Shr r11, 24;                                                            # Alphabet offset
        Add r11, r14;                                                           # Range start plus utf32
        Sub r11, r13;                                                           # Offset of utf32 in alphabet range
        Or  r12, r11;                                                           # Case 2 above
        Mov "[r15-4]", r12d;                                                    # Save offset of utf32 in alphabet range in low bytes as in case 2 above.
       }
      else                                                                      # Record classification in high byte
       {Vpcompressd "zmm29\{k6}", zmm0;                                         # Place classification byte at start of xmm29
        Vpextrb "[r15-1]", xmm29, 3;                                            # Extract and save classification in high byte as in case 0 above.
       }
     });

    SetLabel $finish;
    PopR;
   } parameters=>[qw(address size)],
     name => "ClassifyRange_$recordOffsetInRange";

  $s->call(parameters=>{address=>$address, size=>$size});
 } # ClassifyRange

sub ClassifyInRange($$)                                                         # Character classification: classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1 formatted in double words with each double word in zmm0 having the classification in the highest 8 bits and with zmm0 and zmm1 having the utf32 character at the start (zmm0) and end (zmm1) of each range in the lowest 18 bits.  The classification bits from the first matching range are copied into the high (unused) byte of each utf32 character in the block of memory.  The effect is to replace the high order byte of each utf32 character with a classification code saying what type of character we are working.
 {my ($address, $size) = @_;                                                    # Variable address of utf32 string to classify, variable length of utf32 string to classify
  @_ == 2 or confess "Two parameters required";
  ClassifyRange(0, $address, $size);
 }

sub ClassifyWithInRange($$)                                                     # Bracket classification: Classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1 formatted in double words with the classification range in the high byte of each dword in zmm0 and the utf32 character at the start (zmm0) and end (zmm1) of each range in the lower 18 bits of each dword.  The classification bits from the position within the first matching range are copied into the high (unused) byte of each utf32 character in the block of memory.  With bracket matching this gives us a normalized bracket number.
 {my ($address, $size) = @_;                                                    # Variable address of utf32 string to classify, variable length of utf32 string to classify
  @_ == 2 or confess "Two parameters required";
  ClassifyRange(1, $address, $size);
 }

sub ClassifyWithInRangeAndSaveOffset($$)                                        # Alphabetic classification: classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1 formatted in double words with the classification code in the highest byte of each double word in zmm0 and the offset of the first element in the range in the highest byte of each dword in zmm1.  The lowest 18 bits of each double word in zmm0 and zmm1  contain the utf32 characters marking the start and end of each range. The classification bits from zmm1 for the first matching range are copied into the high byte of each utf32 character in the block of memory.  The offset in the range is copied into the lowest byte of each utf32 character in the block of memory.  The middle two bytes are cleared.  The classification byte is placed in the lowest byte of the utf32 character.
 {my ($address, $size) = @_;                                                    # Variable address of utf32 string to classify, variable length of utf32 string to classify
  @_ == 2 or confess "Two parameters required";
  ClassifyRange(2, $address, $size);
 }

#   4---+---3---+---2---+---1---+---0  Octal not decimal
#    CCCCCCCC        XXXXXXXXXXXXXXXX  ClassifyWithInRangeAndSaveWordOffset C == classification, X == offset in range 0-2**16

sub ClassifyWithInRangeAndSaveWordOffset($$$)                                   # Alphabetic classification: classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1, zmm2 formatted in double words. Zmm0 contains the low end of the range, zmm1 the high end and zmm2 contains the range offset in the high word of each Dword and the lexical classification on the lowest byte of each dword. Each utf32 character recognized is replaced by a dword whose upper byte is the lexical classification and whose lowest word is the range offset.
 {my ($address, $size, $classification) = @_;                                   # Variable address of string of utf32 characters, variable size of string in utf32 characters, variable one byte classification code for this range
  @_ == 3 or confess "Three parameters required";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    my $finish = Label;

    PushR 12, 13, 14, 15, 6, 7, 29..31;

    $$p{address}->setReg(15);                                                   # Address of first utf32 character
    $$p{size}->for(sub                                                          # Process each utf32 character in the block of memory
     {my ($index, $start, $next, $end) = @_;

      Mov r14d, "[r15]";                                                        # Load utf32 character
      Add r15, RegisterSize r14d;                                               # Move up to next utf32 character
      Vpbroadcastd       zmm31, r14d;                                           # Process 16 copies of the utf32 character
      Vpcmpud  k7,       zmm31, zmm0, 5;                                        # Look for start of range
      Vpcmpud "k6\{k7}", zmm31, zmm1, 2;                                        # Look for end of range
      Ktestw k6, k6;                                                            # Was there a match ?
      Jz $next;                                                                 # No character was matched
                                                                                # Process matched character
      Vpcompressd "zmm31\{k6}", zmm2;                                           # Corresponding classification and offset
      Vpextrd r13d, xmm31, 0;                                                   # Extract start of range specification - we can subtract this from the character to get its offset in this range
      Mov r12, r14;                                                             # Range classification code and start of range
      Sub r12, r13;                                                             # We now have the offset in the range

      $$p{classification}->setReg(13);                                          # Classification code
      Shl r13, 24;                                                              # Shift classification code into position
      Or  r12, r13;                                                             # Position classification code
      Mov "[r15-4]", r12d;                                                      # Classification in highest byte of dword, offset in range in lowest word
     });
    PopR;
   } parameters => [qw(address size classification)],
     name       => "ClassifyWithInRangeAndSaveWordOffset";

  $s->call(parameters=>{address=>$address, size=>$size,
           classification=>$classification});
 } # ClassifyWithInRangeAndSaveWordOffset

#D1 C Strings                                                                   # C strings are a series of bytes terminated by a zero byte.

sub Cstrlen()                                                                   #P Length of the C style string addressed by rax returning the length in r15.
 {@_ == 0 or confess "Deprecated in favor of StringLength";

  my $s = Subroutine                                                            # Create area
   {PushR my @regs = (rax, rdi, rcx);
    Mov rdi, rax;
    Mov rcx, -1;
    ClearRegisters rax;
    push @text, <<END;
    repne scasb
END
    Mov r15, rcx;
    Not r15;
    Dec r15;
    PopR @regs;
   } name => "Cstrlen";

  $s->call;
 }

sub StringLength($)                                                             # Length of a zero terminated string.
 {my ($string) = @_;                                                            # String
  @_ == 1 or confess "One parameter: zero terminated string";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    PushR rax, rdi, rcx;
    $$p{string}->setReg(rax);                                                   # Address string
    Mov rdi, rax;
    Mov rcx, -1;
    ClearRegisters rax;
    push @text, <<END;
    repne scasb
END
    Not rcx;
    Dec rcx;
    $$p{size}->getReg(rcx);                                                     # Save length
    PopR;
   } parameters => [qw(string size)], name => 'StringLength';

  $s->call(parameters=>{string=>$string, size => my $z = V size => 0});         # Variable that holds the length of the string

  $z
 }

#D1 Areas                                                                       # An area is single extensible block of memory which contains other data structures such as strings, arrays, trees within it.

our $AreaFreeChain = 0;                                                         # The key of the Yggdrasil tree entry in the area recording the start of the free chain

sub DescribeArea(%)                                                             # Describe a relocatable area.
 {my (%options) = @_;                                                           # Optional variable addressing the start of the area
  my $N = 4096;                                                                 # Initial size of area
  my $w = RegisterSize 31;

  my $quad = RegisterSize rax;                                                  # Field offsets
  my $size = 0;
  my $used = $size + $quad;                                                     # Amount of memory in the area that has been used - includes the free chain.
  my $free = $used + $quad;                                                     # Free chain blocks = freed zmm blocks
  my $tree = $free + $quad;                                                     # Start of Yggdrasil,
  my $data = $w;                                                                # Data starts in the next zmm block

  genHash(__PACKAGE__."::Area",                                                 # Definition of area
    N          => $N,                                                           # Initial allocation
    sizeOffset => $size,                                                        # Size field offset
    usedOffset => $used,                                                        # Used field offset
    freeOffset => $tree,                                                        # Free chain offset
    treeOffset => $tree,                                                        # Yggdrasil - a tree of global variables in this area
    dataOffset => $data,                                                        # The start of the data
    address    => ($options{address} // V address => 0),                        # Variable that addresses the memory containing the area
    zmmBlock   => $w,                                                           # Size of a zmm block - 64 bytes
    nextOffset => $w - RegisterSize(eax),                                       # Position of next offset on free chain
   );
 }

sub CreateArea(%)                                                               # Create an relocatable area and returns its address in rax. We add a chain header so that 64 byte blocks of memory can be freed and reused within the area.
 {my (%options) = @_;                                                           # Free=>1 adds a free chain.
  my $area = DescribeArea;                                                      # Describe an area
  my $N     = $area->N;
  my $used  = $area->usedOffset;
  my $data  = $area->dataOffset;
  my $size  = $area->sizeOffset;

  my $s = Subroutine                                                            # Allocate area
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    my $area = AllocateMemory K size=> $N;                                      # Allocate memory and save its location in a variable

    PushR rax;
    $$s{area}->address->copy($area);                                            # Save address of area
    $area->setReg(rax);
    Mov "dword[rax+$used]", $data;                                              # Initially used space
    Mov "dword[rax+$size]", $N;                                                 # Size
    PopR;
   } structures=>{area=>$area}, name => 'CreateArea';

  $s->call(structures=>{area=>$area});                                          # Variable that holds the reference to the area which is updated when the area is reallocated

  $area
 }

sub Nasm::X86::Area::free($)                                                    # Free an area
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";
  FreeMemory($area->address, $area->size)
 }

sub Nasm::X86::Area::used($)                                                    # Return the currently used size of an area as a variable.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";

  SaveFirstFour;
  $area->address->setReg(rax);                                                  # Address area
  Mov rdx, "[rax+$$area{usedOffset}]";                                          # Used
  Sub rdx, $area->dataOffset;                                                   # Subtract size of header so we get the actual amount in use
  my $size = V 'area used up' => rdx;                                           # Save length in a variable
  RestoreFirstFour;
  $size                                                                         # Return variable length
 }

sub Nasm::X86::Area::size($)                                                    # Get the size of an area as a variab;e.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";

  PushR rax;
  $area->address->setReg(rax);                                                  # Address area
  Mov rax, "[rax+$$area{sizeOffset}]";                                          # Get size
  my $size = V 'size of area' => rax;                                           # Save size in a variable
  PopR;
  $size                                                                         # Return size
 }

sub Nasm::X86::Area::updateSpace($$)                                            #P Make sure that the variable addressed area has enough space to accommodate content of the variable size.
 {my ($area, $size) = @_;                                                       # Area descriptor, variable size needed
  @_ == 2 or confess "Two parameters";

  my $s = Subroutine
   {my ($p, $s) = @_;                                                           # Parameters, structures
    PushR (rax, r10, r12, r13, r14, r15);
    my $base     = rax;                                                         # Base of area
    my $size     = r15;                                                         # Current size
    my $used     = r14;                                                         # Currently used space
    my $request  = r13;                                                         # Requested space
    my $newSize  = r12;                                                         # New size needed
    my $proposed = r10;                                                         # Proposed size

    my $area = $$s{area};                                                       # Address area
    $area->address->setReg($base);                                              # Address area
    $$p{size}->setReg($request);                                                # Requested space

    Mov $size, "[$base+$$area{sizeOffset}]";
    Mov $used, "[$base+$$area{usedOffset}]";
    Mov $newSize, $used;
    Add $newSize, $request;

    Cmp $newSize,$size;                                                         # New size needed
    IfGt                                                                        # New size is bigger than current size
    Then                                                                        # More space needed
     {Mov $proposed, 4096 * 1;                                                  # Minimum proposed area size
      K(loop=>36)->for(sub                                                      # Maximum number of shifts
       {my ($index, $start, $next, $end) = @_;
        Shl $proposed, 1;                                                       # New proposed size
        Cmp $proposed, $newSize;                                                # Big enough?
        Jge $end;                                                               # Big enough!
       });

      my $address = AllocateMemory V size => $proposed;                         # Create new area
      CopyMemory($area->address, $address, $area->size);                        # Copy old area into new area
      FreeMemory $area->address, $area->size;                                   # Free previous memory previously occupied area
      $area->address->copy($address);                                           # Save new area address
      $address->setReg($base);                                                  # Address area
      Mov "[$base+$$area{sizeOffset}]", $proposed;                              # Save the new size in the area
     };

    PopR;
   } parameters => [qw(size)],
     structures => {area => $area},
     name       => 'Nasm::X86::Area::updateSpace';

  $s->call(parameters=>{size => $size}, structures=>{area => $area});
 } # updateSpace

sub Nasm::X86::Area::makeReadOnly($)                                            # Make an area read only.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    Comment "Make an area readable";
    SaveFirstFour;
    $$p{address}->setReg(rax);
    Mov rdi, rax;                                                               # Address of area
    Mov rsi, "[rax+$$area{sizeOffset}]";                                        # Size of area

    Mov rdx, 1;                                                                 # Read only access
    Mov rax, 10;
    Syscall;
    RestoreFirstFour;                                                           # Return the possibly expanded area
   } parameters=>[qw(address)], name => 'Nasm::X86::Area::makeReadOnly';

  $s->call(parameters=>{address => $area->address});
 }

sub Nasm::X86::Area::makeWriteable($)                                           # Make an area writable.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    Comment "Make an area writable";
    SaveFirstFour;
    $$p{address}->setReg(rax);
    Mov rdi, rax;                                                               # Address of area
    Mov rsi, "[rax+$$area{sizeOffset}]";                                        # Size of area
    Mov rdx, 3;                                                                 # Read only access
    Mov rax, 10;
    Syscall;
    RestoreFirstFour;                                                           # Return the possibly expanded area
   } parameters=>[qw(address)], name => 'Nasm::X86::Area::makeWriteable';

  $s->call(parameters=>{address => $area->address});
 }

#D2 Alloc/Free                                                                  # Allocate and free memory in an area, either once only but in variable size blocks or reusably in zmm sized blocks via the free block chain.

sub Nasm::X86::Area::allocate($$)                                               # Allocate the variable amount of space in the variable addressed area and return the offset of the allocation in the area as a variable.
 {my ($area, $size) = @_;                                                       # Area descriptor, variable amount of allocation
  @_ == 2 or confess "Two parameters";

  SaveFirstFour;
  $area->updateSpace($size);                                                    # Update space if needed
  $area->address->setReg(rax);
  Mov rsi, "[rax+$$area{usedOffset}]";                                          # Currently used
  my $offset = V(offset => rsi);                                                # Variable to hold offset of allocation
  $size  ->setReg(rdi);
  Add rsi, rdi;
  Mov "[rax+$$area{usedOffset}]", rsi;                                          # Update currently used
  RestoreFirstFour;
  $offset
 }

sub Nasm::X86::Area::allocZmmBlock($)                                           # Allocate a block to hold a zmm register in the specified area and return the offset of the block as a variable.
 {my ($area) = @_;                                                              # Area
  @_ == 1 or confess "One parameter";
  my $offset = V(offset => 0);                                                  # Variable to hold offset of allocation

  PushR rax, my $first = r14, my $second = r15, 31;
  my $firstD = $first.'d'; my $secondD = $second.'d';

  $area->address->setReg(rax);                                                  # Address of area
  Mov $firstD, "[rax+$$area{freeOffset}]";                                      # Offset of first block in free chain if such a block exists
  Cmp $first, 0;
  IfGt
  Then                                                                          # Free block available
   {$area->getZmmBlock(V (offset => $first), 31);                               # Load the first block on the free chain
    dFromZ(31, 0)->setReg($second);                                             # The location of the second block if any
    Mov "[rax+$$area{freeOffset}]", $secondD;                                   # Offset of first block in free chain if such a block exists
    ClearRegisters 31;                                                          # Clear the zmm block - possibly this only needs to be done if we are reusing a block
    $offset->getReg($first);                                                    # First block is the allocated block
    $area->putZmmBlock($offset, 31);
   },
  Else                                                                          # Cannot reuse a free block so allocate
   {$offset->copy($area->allocate(K size => $area->zmmBlock));                  # Copy offset of allocation
   };
  PopR;


  $offset                                                                       # Return offset of allocated block
 }

sub Nasm::X86::Area::freeZmmBlock($$)                                           #P Free a block in an area by placing it on the free chain.
 {my ($area, $offset) = @_;                                                     # Area descriptor, offset of zmm block to be freed
  @_ == 2 or confess "Two parameters";

  PushR rax, my $first = r14, my $second = r15, zmm7;
  my $firstD = $first.'d'; my $secondD = $second.'d';
  $area->address->setReg(rax);                                                  # Address of area
  Mov $secondD, "[rax+$$area{freeOffset}]";                                     # Offset of first block in free chain if such a block exists
  ClearRegisters zmm7;
  Movd xmm7, $secondD;
  $area->putZmmBlock($offset, 7);
  $offset->setReg($first);                                                      # Offset if what will soon be the first block on the free chain
  Mov "[rax+$$area{freeOffset}]", $firstD;                                      # Offset of first block in free chain if such a block exists
  PopR;
 }

sub Nasm::X86::Area::freeChainSpace($)                                          # Count the number of blocks available on the free chain
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameters";
  my $count = V('free chain blocks' => 0);

  PushR rax, my $first = r15, 31;
  my $firstD = $first.'d';

  $area->address->setReg(rax);                                                  # Address of area
  Mov $firstD, "[rax+$$area{freeOffset}]";                                      # Offset of first block in free chain if such a block exists
  V( loop => 99)->for(sub                                                       # Loop through free block chain
   {my ($index, $start, $next, $end) = @_;
    Cmp $first, 0;
    IfEq Then{Jmp $end};                                                        # No more free blocks
    $area->getZmmBlock(V(offset => $first), 31);                                # Load the first block on the free chain
    dFromZ(31, 0)->setReg($first);                                              # The location of the second block if any
    $count->copy($count + 1);                                                   # Increment count of number of  blocks on the free chain
   });
  PopR;
  $count * RegisterSize 31;
 }

sub Nasm::X86::Area::getZmmBlock($$$)                                           #P Get the block with the specified offset in the specified string and return it in the numbered zmm.
 {my ($area, $block, $zmm) = @_;                                                # Area descriptor, offset of the block as a variable, number of zmm register to contain block
  @_ == 3 or confess "Three parameters";

  my $a = rdi;                                                                  # Work registers
  my $o = rsi;

  $area->address->setReg($a);                                                   # Area address
  $block->setReg($o);                                                           # Offset of block in area

  Cmp $o, $area->dataOffset;
  IfLt                                                                          # We could have done this using variable arithmetic, but such arithmetic is expensive and so it is better to use register arithmetic if we can.
  Then
   {PrintErrTraceBack "Attempt to get block before start of area";
   };

  Vmovdqu64 "zmm$zmm", "[$a+$o]";                                               # Read from memory
 }

sub Nasm::X86::Area::putZmmBlock($$$)                                           #P Write the numbered zmm to the block at the specified offset in the specified area.
 {my ($area, $block, $zmm) = @_;                                                # Area descriptor, offset of the block as a variable, number of zmm register to contain block
  @_ == 3 or confess "Three parameters";

  my $a = rdi;                                                                  # Work registers
  my $o = rsi;

  $area->address->setReg($a);                                                   # Area address
  $block->setReg($o);                                                           # Offset of block in area

  Cmp $o, $area->dataOffset;
  IfLt                                                                          # We could have done this using variable arithmetic, but such arithmetic is expensive and so it is better to use register arithmetic if we can.
  Then
   {PrintErrTraceBack "Attempt to put block before start of area";
   };

  Vmovdqu64 "[$a+$o]", "zmm$zmm";                                               # Read from memory
 }

sub Nasm::X86::Area::clearZmmBlock($$)                                          #P Clear the zmm block at the specified offset in the area
 {my ($area, $offset) = @_;                                                     # Area descriptor, offset of the block as a variable
  @_ == 2 or confess "Two parameters";

  PushR 31;                                                                     # Clear a zmm block
  ClearRegisters 31;
  $area->putZmmBlock($offset, 31);
  PopR;
 }

#D2 Yggdrasil                                                                   # The world tree from which we can address so many other things

sub Nasm::X86::Area::checkYggdrasilCreated($)                                   #P Return a tree descriptor to the Yggdrasil world tree for an area.  If Yggdrasil has not been created the B<found> variable will be zero else one.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";

  my $t = $area->DescribeTree;                                                  # Tree descriptor for Yggdrasil
  PushR rax;
  $area->address->setReg(rax);                                                  #P Address underlying area
  Mov rax, "[rax+$$area{treeOffset}]";                                          # Address Yggdrasil
  my $v = V('Yggdrasil', rax);                                                  # Offset to Yggdrasil if it exists else zero
  Cmp rax, 0;                                                                   # Does Yggdrasil even exist?
  IfNe
  Then                                                                          # Yggdrasil has been created so we can address it
   {$t->first->copy(rax);
    $t->found->copy(1);
   },
  Else                                                                          # Yggdrasil has not been created
   {$t->found->copy(0);
   };
  Cmp rax, 0;                                                                   # Restate whether Yggdrasil exists so that we can test its status quickly in the following code.
  PopR rax;
  $t
 }

sub Nasm::X86::Area::establishYggdrasil($)                                      #P Return a tree descriptor to the Yggdrasil world tree for an area creating the world tree Yggdrasil if it has not already been created.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";

  my $t = $area->DescribeTree;                                                  # Tree descriptor for Yggdrasil
  PushR rax, rdi;
  $area->address->setReg(rax);                                                  #P Address underlying area
  Mov rdi, "[rax+$$area{treeOffset}]";                                          # Address Yggdrasil
  Cmp rdi, 0;                                                                   # Does Yggdrasil even exist?
  IfNe
  Then                                                                          # Yggdrasil has already been created so we can address it
   {$t->first->copy(rdi);
   },
  Else                                                                          # Yggdrasil has not been created
   {my $T = $area->CreateTree();
    $T->first->setReg(rdi);
    $t->first->copy(rdi);
    Mov "[rax+$$area{treeOffset}]", rdi;                                        # Save offset of Yggdrasil
   };
  PopR;
  $t
 }

#D2 Areas as Strings                                                            # Use the memory supplied by the area as a string - however, in general, this is too slow unless coupled with another slow operation such as executing a command, mapping a file or writing to a file.

sub Nasm::X86::Area::m($$$)                                                     # Append the variable addressed content of variable size to the specified area.
 {my ($area, $address, $size) = @_;                                             # Area descriptor, variable address of content, variable length of content
  @_ == 3 or confess "Three parameters";

  my $used = "[rax+$$area{usedOffset}]";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    SaveFirstFour;
    my $area = $$s{area};
    $area->address->setReg(rax);
    my $oldUsed = V("used", $used);
    $area->updateSpace($$p{size});                                              # Update space if needed

    my $target  = $oldUsed + $area->address;
    CopyMemory($$p{address}, $target, $$p{size});                               # Copy data into the area

    my $newUsed = $oldUsed + $$p{size};

    $area->address->setReg(rax);                                                # Update used field
    $newUsed->setReg(rdi);
    Mov $used, rdi;

    RestoreFirstFour;
   } structures => {area => $area},
     parameters => [qw(address size)],
     name       => 'Nasm::X86::Area::m';

  $s->call(structures => {area => $area},
           parameters => {address => $address, size => $size});
 }

sub Nasm::X86::Area::q($$)                                                      # Append a constant string to the area.
 {my ($area, $string) = @_;                                                     # Area descriptor, string
  @_ == 2 or confess "Two parameters";

  my $s = Rs($string);
  $area->m(V('address', $s), V('size', length($string)));
 }

sub Nasm::X86::Area::ql($$)                                                     # Append a quoted string containing new line characters to the specified area.
 {my ($area, $const) = @_;                                                      # Area, constant
  @_ == 2 or confess "Two parameters";
  for my $l(split /\s*\n/, $const)
   {$area->q($l);
    $area->nl;
   }
 }

sub Nasm::X86::Area::char($$)                                                   # Append a character expressed as a decimal number to the specified area.
 {my ($area, $char) = @_;                                                       # Area descriptor, number of character to be appended
  @_ == 2 or confess "Two parameters";
  my $s = Rb(ord($char));
  $area->m(V(address => $s), K size => 1);                                      # Move data
 }

sub Nasm::X86::Area::nl($)                                                      # Append a new line to the area addressed by rax.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";
  $area->char("\n");
 }

sub Nasm::X86::Area::z($)                                                       # Append a trailing zero to the area addressed by rax.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";
  $area->char("\0");
 }

sub Nasm::X86::Area::append($@)                                                 # Append one area to another.
 {my ($target, $source) = @_;                                                   # Target area descriptor, source area descriptor
  @_ == 2 or confess "Two parameters";

  SaveFirstFour;
  $source->address->setReg(rax);
  Mov rdi, "[rax+$$source{usedOffset}]";
  Sub rdi, $source->dataOffset;
  Lea rsi, "[rax+$$source{dataOffset}]";
  $target->m(V(address => rsi), V size => rdi);
  RestoreFirstFour;
 }

sub Nasm::X86::Area::clear($)                                                   # Clear an area
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    PushR rax, rdi;
    $$p{address}->setReg(rax);
    Mov rdi, $area->dataOffset;
    Mov "[rax+$$area{usedOffset}]", rdi;
    ClearRegisters rdi;
    Mov "[rax+$$area{freeOffset}]", rdi;
    Mov "[rax+$$area{treeOffset}]", rdi;
    PopR;
   } parameters=>[qw(address)], name => 'Nasm::X86::Area::clear';

  $s->call(parameters=>{address => $area->address});
 }

sub Nasm::X86::Area::write($$)                                                  # Write the content of the specified area to a file specified by a zero terminated string.
 {my ($area, $file) = @_;                                                       # Area descriptor, variable addressing file name
  @_ == 2 or confess "Two parameters";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    SaveFirstFour;

    $$p{file}->setReg(rax);
    OpenWrite;                                                                  # Open file
    my $file = V(fd => rax);                                                    # File descriptor

    $$p{address}->setReg(rax);                                                  # Write file
    Lea rsi, "[rax+$$area{dataOffset}]";
    Mov rdx, "[rax+$$area{usedOffset}]";
    Sub rdx, $area->dataOffset;

    Mov rax, 1;                                                                 # Write content to file
    $file->setReg(rdi);
    Syscall;

    $file->setReg(rax);
    CloseFile;
    RestoreFirstFour;
   } parameters=>[qw(file address)], name => 'Nasm::X86::Area::write';

  $s->call(parameters=>{address => $area->address, file => $file});
 }

sub Nasm::X86::Area::read($@)                                                   # Read a file specified by a variable addressed zero terminated string and place the contents of the file into the named area.
 {my ($area, $file) = @_;                                                       # Area descriptor, variable addressing file name
  @_ == 2 or confess "Two parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    Comment "Read an area";
    my ($address, $size) = ReadFile $$p{file};
    my $area = $$s{area};
    $area->m($address, $size);                                                  # Move data into area
    FreeMemory($size, $address);                                                # Free memory allocated by read
   } structures => {area=>$area},
     parameters => [qw(file)],
     name       => 'Nasm::X86::Area::read';

  $s->call(structures => {area => $area}, parameters => {file => $file});
 }

sub Nasm::X86::Area::out($)                                                     # Print the specified area on sysout.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";

  my $s = Subroutine
   {my ($p) = @_;                                                               # Parameters
    SaveFirstFour;
    $$p{address}->setReg(rax);

    Mov rdi, "[rax+$$area{usedOffset}]";                                        # Length to print
    Sub rdi, $area->dataOffset;                                                 # Length to print
    Lea rax, "[rax+$$area{dataOffset}]";                                        # Address of data field
    PrintOutMemory;
    RestoreFirstFour;
   } parameters=>[qw(address)], name => 'Nasm::X86::Area::out';

  $s->call(parameters=>{address => $area->address});
 }

sub Nasm::X86::Area::outNL($)                                                   # Print the specified area on sysout followed by a new line.
 {my ($area) = @_;                                                              # Area descriptor
  @_ == 1 or confess "One parameter";

  $area->out;
  PrintOutNL;
 }

sub Nasm::X86::Area::dump($$;$)                                                 # Dump details of an area.
 {my ($area, $title, $depth) = @_;                                              # Area descriptor, title string, optional variable number of 64 byte blocks to dump
  @_ == 2 or @_ == 3 or confess "Two or three parameters";
  my $blockSize = 64;                                                           # Print in blocks of this size

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    PushR rax, rdi;
    my $area = $$s{area};
    $area->address->setReg(rax);                                                # Get address of area
    PrintOutString("Area   ");

    PushR rax;                                                                  # Print size
    Mov rax, "[rax+$$area{sizeOffset}]";
    PrintOutString "  Size: ";
    PrintOutRaxRightInDec K width => 8;
    PrintOutString "  ";
    PopR rax;

    PushR rax;                                                                  # Print size
    Mov rax, "[rax+$$area{usedOffset}]";
    PrintOutString("  Used: ");
    PrintOutRaxRightInDec  K width => 8;
    PrintOutNL;
    PopR rax;

    $$p{depth}->for(sub                                                         # Print the requested number of blocks
     {my ($index, $start, $next, $end) = @_;
      Mov rdi, $blockSize;                                                      # Length of each print
      ($index*RegisterSize(zmm31))->out('', ' | ');
      my $address = $area->address + $index * $blockSize;                       # Address of block to print
      $address->setReg(rax);
      PrintOutMemory_InHexNL;
     });

    PopR;
   } structures=>{area=>$area},
     parameters=>[qw(depth)],
     name => "Nasm::X86::Area::dump";

  PrintOutStringNL $title;
  $s->call(structures=>{area=>$area}, parameters=>{depth => ($depth // V('depth', 4))});
 }

#D1 Tree                                                                        # Tree constructed as sets of blocks in an area.

sub DescribeTree(%)                                                             #P Return a descriptor for a tree with the specified options.
 {my (%options) = @_;                                                           # Tree description options

  confess "Maximum keys must be less than or equal to 14"
    unless ($options{length}//0) <= 14;                                         # Maximum number of keys is 14

  my $b = RegisterSize 31;                                                      # Size of a block == size of a zmm register
  my $o = RegisterSize eax;                                                     # Size of a double word

  my $keyAreaWidth = $b - $o * 2 ;                                              # Key / data area width  in bytes
  my $length = $options{length} // $keyAreaWidth / $o;                          # Length of block to split

  my $l2 = int($length/2);                                                      # Minimum length of length after splitting

  genHash(__PACKAGE__."::Tree",                                                 # Tree
    area        => ($options{area} // DescribeArea),                            # Area definition.
    length       => $length,                                                    # Number of keys in a maximal block
    lengthLeft   => $l2,                                                        # Left minimal number of keys
    lengthMiddle => $l2 + 1,                                                    # Number of splitting key counting from 1
    lengthMin    => $length - 1 - $l2,                                          # The smallest number of keys we are allowed in any node other than a root node.
    lengthOffset => $keyAreaWidth,                                              # Offset of length in keys block.  The length field is a word - see: "MultiWayTree.svg"
    lengthRight  => $length - 1 - $l2,                                          # Right minimal number of keys
    loop         => $b - $o,                                                    # Offset of keys, data, node loop.
    maxKeys      => $length,                                                    # Maximum number of keys allowed in this tree which might well ne less than the maximum we can store in a zmm.
    offset       => V(offset  => 0),                                            # Offset of last node found
    splittingKey => ($l2 + 1) * $o,                                             # Offset at which to split a full block
    treeBits     => $keyAreaWidth + 2,                                          # Offset of tree bits in keys block.  The tree bits field is a word, each bit of which tells us whether the corresponding data element is the offset (or not) to a sub tree of this tree .
    treeBitsMask => 0x3fff,                                                     # Total of 14 tree bits
    keyDataMask  => 0x3fff,                                                     # Key data mask
    nodeMask     => 0x7fff,                                                     # Node mask
    up           => $keyAreaWidth,                                              # Offset of up in data block.
    width        => $o,                                                         # Width of a key or data slot.
    zWidth       => $b,                                                         # Width of a zmm register
    zWidthD      => $b / $o,                                                    # Width of a zmm in double words being the element size
    maxKeysZ     => $b / $o - 2,                                                # The maximum possible number of keys in a zmm register
    maxNodesZ    => $b / $o - 1,                                                # The maximum possible number of nodes in a zmm register

    rootOffset   => $o * 0,                                                     # Offset of the root field in the first block - the root field contains the offset of the block containing the keys of the root of the tree
    upOffset     => $o * 1,                                                     # Offset of the up field which points to any containing tree
    sizeOffset   => $o * 2,                                                     # Offset of the size field which tells us the number of  keys in the tree
    middleOffset => $o * ($l2 + 0),                                             # Offset of the middle slot in bytes
    rightOffset  => $o * ($l2 + 1),                                             # Offset of the first right slot in bytes

    compare      => V(compare => 0),                                            # Last comparison result -1, 0, +1
    data         => V(data    => 0),                                            # Variable containing the current data
    debug        => V(debug   => 0),                                            # Write debug trace if true
    first        => V(first   => 0),                                            # Variable addressing offset to first block of the tree which is the header block
    found        => V(found   => 0),                                            # Variable indicating whether the last find was successful or not
    index        => V(index   => 0),                                            # Index of key in last node found
    key          => V(key     => 0),                                            # Variable containing the current key
    offset       => V(key     => 0),                                            # Variable containing the offset of the block containing the current key
    subTree      => V(subTree => 0),                                            # Variable indicating whether the last find found a sub tree
   );
 }

sub Nasm::X86::Area::DescribeTree($%)                                           #P Return a descriptor for a tree in the specified area with the specified options.
 {my ($area, %options) = @_;                                                    # Area descriptor, options for tree
  @_ >= 1 or confess;

  DescribeTree(area=>$area, %options)
 }

sub Nasm::X86::Area::CreateTree($%)                                             # Create a tree in an area.
 {my ($area, %options) = @_;                                                    # Area description, tree options
  @_ % 2 == 1 or confess "Odd number of parameters required";

  my $tree = $area->DescribeTree(%options);                                     # Return a descriptor for a tree in the specified area

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    my $tree  = $$s{tree};                                                      # Tree
    $tree->first->copy($tree->area->allocZmmBlock);                             # Allocate header

   } structures=>{area => $area, tree => $tree},
     name => 'Nasm::X86::Area::CreateTree';

  $s->call(structures=>{area => $area, tree => $tree});

  $tree                                                                         # Description of array
 }

sub Nasm::X86::Tree::describeTree($%)                                           #P Create a a description of a tree
 {my ($tree, %options) = @_;                                                    # Tree descriptor, {first=>first node of tree if not the existing first node; area=>area used by tree if not the existing area}
  @_ >= 1 or confess "At least one parameter";

  $tree->area->DescribeTree(%options);                                          # Return a descriptor for a tree
 }

sub Nasm::X86::Tree::position($$)                                               #P Make a copy of a tree descriptor
 {my ($tree, $first) = @_;                                                      # Tree descriptor, offset of tree
  my $t = $tree->describeTree;

  $t->first->copy($first);                                                      # Variable addressing offset to first block of keys.
  $t                                                                            # Return new descriptor
 }

sub Nasm::X86::Tree::copyDescription($)                                         #P Make a copy of a tree descriptor
 {my ($tree) = @_;                                                              # Tree descriptor
  my $t = $tree->describeTree;

  $t->data   ->copy($tree->data );                                              # Variable containing the last data found
  $t->debug  ->copy($tree->debug);                                              # Write debug trace if true
  $t->first  ->copy($tree->first);                                              # Variable addressing offset to first block of keys.
  $t->found  ->copy($tree->found);                                              # Variable indicating whether the last find was successful or not
  $t->index  ->copy($tree->index);                                              # Index of key in last node found
  $t->subTree->copy($tree->subTree);                                            # Variable indicating whether the last find found a sub tree
  $t                                                                            # Return new descriptor
 }

sub Nasm::X86::Tree::firstFromMemory($$)                                        #P Load the first block for a tree into the numbered zmm.
 {my ($tree, $zmm) = @_;                                                        # Tree descriptor, number of zmm to contain first block
  @_ == 2 or confess "Two parameters";
  my $base = rdi; my $offset = rsi;
  $tree->area->address->setReg($base);
  $tree->first->setReg($offset);
  Vmovdqu64 zmm($zmm), "[$base+$offset]";
 }

sub Nasm::X86::Tree::firstIntoMemory($$)                                        #P Save the first block of a tree in the numbered zmm back into memory.
 {my ($tree, $zmm) = @_;                                                        # Tree descriptor, number of zmm containing first block
  @_ == 2 or confess "Two parameters";
  my $base = rdi; my $offset = rsi;
  $tree->area->address->setReg($base);
  $tree->first->setReg($offset);
  Vmovdqu64  "[$base+$offset]", zmm($zmm);
 }

sub Nasm::X86::Tree::rootIntoFirst($$$)                                         #P Put the contents of a variable into the root field of the first block of a tree when held in a zmm register.
 {my ($tree, $zmm, $value) = @_;                                                # Tree descriptor, number of zmm containing first block, variable containing value to put
  @_ == 3 or confess "Three parameters";
  $value->dIntoZ($zmm, $tree->rootOffset);
 }

sub Nasm::X86::Tree::rootFromFirst($$)                                          #P Return a variable containing the offset of the root block of a tree from the first block when held in a zmm register.
 {my ($tree, $zmm) = @_;                                                        # Tree descriptor, number of zmm containing first block
  @_ == 2 or confess "Two parameters";
  dFromZ $zmm, $tree->rootOffset;
 }

sub Nasm::X86::Tree::root($$$)                                                  #P Check whether the specified offset refers to the root of a tree when the first block is held in a zmm register. The result is returned by setting the zero flag to one if the offset is the root, else to zero.
 {my ($t, $F, $offset) = @_;                                                    # Tree descriptor, zmm register holding first block, offset of block as a variable
  @_ == 3 or confess "Three parameters";
  my $root = $t->rootFromFirst($F);                                             # Get the offset of the corresponding data block
  $root == $offset                                                              # Check whether the offset is in fact the root
 }

sub Nasm::X86::Tree::sizeFromFirst($$)                                          #P Return a variable containing the number of keys in the specified tree when the first block is held in a zmm register..
 {my ($tree, $zmm) = @_;                                                        # Tree descriptor, number of zmm containing first block
  @_ == 2 or confess "Two parameters";
  dFromZ $zmm, $tree->sizeOffset;
 }

sub Nasm::X86::Tree::sizeIntoFirst($$$)                                         #P Put the contents of a variable into the size field of the first block of a tree  when the first block is held in a zmm register.
 {my ($tree, $zmm, $value) = @_;                                                # Tree descriptor, number of zmm containing first block, variable containing value to put
  @_ == 3 or confess "Three parameters";
  $value->dIntoZ($zmm, $tree->sizeOffset);
 }

sub Nasm::X86::Tree::incSizeInFirst($$)                                         #P Increment the size field in the first block of a tree when the first block is held in a zmm register.
 {my ($tree, $zmm) = @_;                                                        # Tree descriptor, number of zmm containing first block
  @_ == 2 or confess "Two parameters";
  my $s = dFromZ $zmm, $tree->sizeOffset;
  $tree->sizeIntoFirst($zmm, $s+1);
 }

sub Nasm::X86::Tree::incSize($)                                                 #P Increment the size of a tree
 {my ($tree) = @_;                                                              # Tree descriptor
  @_ == 1 or confess "One parameter";
  PushR 31;
  $tree->firstFromMemory(31);
  $tree->incSizeInFirst (31);
  $tree->firstIntoMemory(31);
  PopR;
 }

sub Nasm::X86::Tree::decSizeInFirst($$)                                         #P Decrement the size field in the first block of a tree when the first block is held in a zmm register.
 {my ($tree, $zmm) = @_;                                                        # Tree descriptor, number of zmm containing first block
  @_ == 2 or confess "Two parameters";
  my $s = dFromZ $zmm, $tree->sizeOffset;
  If $s == 0,
  Then
   {PrintErrTraceBack "Cannot decrement zero length tree";
   };
  $tree->sizeIntoFirst($zmm, $s-1);
 }

sub Nasm::X86::Tree::decSize($)                                                 #P Decrement the size of a tree
 {my ($tree) = @_;                                                              # Tree descriptor
  @_ == 1 or confess "One parameter";
  PushR 31;
  $tree->firstFromMemory(31);
  $tree->decSizeInFirst (31);
  $tree->firstIntoMemory(31);
  PopR;
 }

sub Nasm::X86::Tree::size($)                                                    # Return in a variable the number of elements currently in the tree.
 {my ($tree) = @_;                                                              # Tree descriptor
  @_ == 1 or confess "One parameter";
  my $F = 31;
  PushR $F;
  $tree->firstFromMemory($F);
  my $s = $tree->sizeFromFirst($F);
  $s->name = q(size of tree);
  PopR;
  $s
 }

sub Nasm::X86::Tree::allocBlock($$$$)                                           #P Allocate a keys/data/node block and place it in the numbered zmm registers.
 {my ($tree, $K, $D, $N) = @_;                                                  # Tree descriptor, numbered zmm for keys, numbered zmm for data, numbered zmm for children
  @_ == 4 or confess "4 parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    my $t = $$s{tree};                                                          # Tree
    my $area = $t->area;                                                        # Area
    my $k = $area->allocZmmBlock;                                               # Keys
    my $d = $area->allocZmmBlock;                                               # Data
    my $n = $area->allocZmmBlock;                                               # Children

    PushR 8;
    $t->putLoop($d, $K);                                                        # Set the link from key to data
    $t->putLoop($n, $D);                                                        # Set the link from data to node
    $t->putLoop($t->first, $N);                                                 # Set the link from node to tree first block

    $$p{address}->copy($k);                                                     # Address of block
    PopR;
   } structures => {tree => $tree},
     parameters => [qw(address)],
     name       => qq(Nasm::X86::Tree::allocBlock::${K}::${D}::${N});           # Create a subroutine for each combination of registers encountered

  $s->call(structures => {tree => $tree},
           parameters => {address =>  my $a = V address => 0});

  $a
 } # allocBlock

sub Nasm::X86::Tree::freeBlock($$$$$)                                           #P Free a keys/data/node block whise keys  block entry is located at the specified offset.
 {my ($tree, $k, $K, $D, $N) = @_;                                              # Tree descriptor, offset of keys block, numbered zmm for keys, numbered zmm for data, numbered zmm for children
  @_ == 5 or confess "Five parameters";
  my $d = $tree->getLoop($K);
  my $n = $tree->getLoop($D);
  $tree->area->freeZmmBlock($_) for $k, $d, $n;                                 # Free the component zmm blocks
 } # freeBlock

sub Nasm::X86::Tree::upFromData($$)                                             #P Up from the data zmm in a block in a tree
 {my ($tree, $zmm) = @_;                                                        # Tree descriptor, number of zmm containing data block
  @_ == 2 or confess "Two parameters";
  dFromZ $zmm, $tree->up;
 }

sub Nasm::X86::Tree::upIntoData($$$)                                            #P Up into the data zmm in a block in a tree
 {my ($tree, $value, $zmm) = @_;                                                # Tree descriptor, variable containing value to put, number of zmm containing first block
  @_ == 3 or confess "Three parameters";
  $value->dIntoZ($zmm, $tree->up);
 }

sub Nasm::X86::Tree::lengthFromKeys($$)                                         #P Get the length of the keys block in the numbered zmm and return it as a variable.
 {my ($t, $zmm) = @_;                                                           # Tree descriptor, zmm number
  @_ == 2 or confess "Two parameters";

  bFromZ($zmm, $t->lengthOffset);                                               # The length field as a variable
 }

sub Nasm::X86::Tree::lengthIntoKeys($$$)                                        #P Get the length of the block in the numbered zmm from the specified variable.
 {my ($t, $zmm, $length) = @_;                                                  # Tree, zmm number, length variable
  @_ == 3 or confess "Three parameters";
  ref($length) or confess dump($length);
  $length->bIntoZ($zmm, $t->lengthOffset)                                       # Set the length field
 }

sub Nasm::X86::Tree::incLengthInKeys($$)                                        #P Increment the number of keys in a keys block or complain if such is not possible
 {my ($t, $K) = @_;                                                             # Tree, zmm number
  @_ == 2 or confess "Two parameters";
  my $l = $t->lengthOffset;                                                     # Offset of length bits
  PushR 15;
  ClearRegisters r15;
  bRegFromZmm r15, $K, $l;                                                      # Length
  Cmp r15, $t->length;
  IfLt
  Then
   {Inc r15;
    bRegIntoZmm r15, $K, $l;
   },
  Else
   {PrintErrTraceBack "Cannot increment length of block beyond ".$t->length;
   };
  PopR;
 }

sub Nasm::X86::Tree::decLengthInKeys($$)                                        #P Decrement the number of keys in a keys block or complain if such is not possible
 {my ($t, $K) = @_;                                                             # Tree, zmm number
  @_ == 2 or confess "Two parameters";
  my $l = $t->lengthOffset;                                                     # Offset of length bits
  PushR 15;
  ClearRegisters r15;
  bRegFromZmm r15, $K, $l;                                                      # Length
  Cmp r15, 0;
  IfGt
  Then
   {Dec r15;
    bRegIntoZmm r15, $K, $l;
   },
  Else
   {PrintErrTraceBack "Cannot decrement length of block below 0";
   };

  PopR;
 }

sub Nasm::X86::Tree::leafFromNodes($$)                                          #P Return a variable containing true if we are on a leaf.  We determine whether we are on a leaf by checking the offset of the first sub node.  If it is zero we are on a leaf otherwise not.
 {my ($tree, $zmm) = @_;                                                        # Tree descriptor, number of zmm containing node block
  @_ == 2 or confess "Two parameters";
  my $n = dFromZ $zmm, 0;                                                       # Get first node
  my $l = V leaf => 0;                                                          # Return a variable which is non zero if  this is a leaf
  If $n == 0, Then {$l->copy(1)};                                               # Leaf if the node is zero
  $l
 }

sub Nasm::X86::Tree::getLoop($$)                                                #P Return the value of the loop field as a variable.
 {my ($t, $zmm) = @_;                                                           # Tree descriptor, numbered zmm
  @_ == 2 or confess "Two parameters";
  dFromZ $zmm, $t->loop;                                                        # Get loop field as a variable
 }

sub Nasm::X86::Tree::putLoop($$$)                                               #P Set the value of the loop field from a variable.
 {my ($t, $value, $zmm) = @_;                                                   # Tree descriptor, variable containing offset of next loop entry, numbered zmm
  @_ == 3 or confess "Three parameters";
  $value->dIntoZ($zmm, $t->loop);                                               # Put loop field as a variable
 }

sub Nasm::X86::Tree::maskForFullKeyArea                                         #P Place a mask for the full key area in the numbered mask register
 {my ($tree, $maskRegister) = @_;                                               # Tree description, mask register
  my $m = registerNameFromNumber $maskRegister;
  ClearRegisters $m;                                                            # Zero register
  Knotq $m, $m;                                                                 # Invert to fill with ones
  Kshiftrw $m, $m, 2;                                                           # Mask with ones in the full key area
 }

sub Nasm::X86::Tree::maskForFullNodesArea                                       #P Place a mask for the full nodes area in the numbered mask register
 {my ($tree, $maskRegister) = @_;                                               # Tree description, mask register
  my $m = registerNameFromNumber $maskRegister;
  ClearRegisters $m;                                                            # Zero register
  Knotq $m, $m;                                                                 # Invert to fill with ones
  Kshiftrw $m, $m, 1;                                                           # Mask with ones in the full key area
 }

sub Nasm::X86::Tree::getBlock($$$$$)                                            #P Get the keys, data and child nodes for a tree node from the specified offset in the area for the tree.
 {my ($t, $offset, $K, $D, $N) = @_;                                            # Tree descriptor, offset of block as a variable, numbered zmm for keys, numbered data for keys, numbered zmm for nodes
  @_ == 5 or confess "Five parameters";
  my $a = $t->area;                                                             # Underlying area
  $a->getZmmBlock($offset, $K);                                                 # Get the keys block
  my $data = $t->getLoop(  $K);                                                 # Get the offset of the corresponding data block
  $a->getZmmBlock($data,   $D);                                                 # Get the data block
  my $node = $t->getLoop  ($D);                                                 # Get the offset of the corresponding node block
  $a->getZmmBlock($node,   $N);                                                 # Get the node block
 }

sub Nasm::X86::Tree::putBlock($$$$$)                                            #P Put a tree block held in three zmm registers back into the area holding the tree at the specified offset.
 {my ($t, $offset, $K, $D, $N) = @_;                                            # Tree descriptor, offset of block as a variable, numbered zmm for keys, numbered data for keys, numbered zmm for nodes
  @_ == 5 or confess "Five parameters";
  my $a    = $t->area;                                                          # Area for tree
  my $data = $t->getLoop(  $K);                                                 # Get the offset of the corresponding data block
  my $node = $t->getLoop(  $D);                                                 # Get the offset of the corresponding node block
  $a->putZmmBlock($offset, $K);                                                 # Put the keys block
  $a->putZmmBlock($data,   $D);                                                 # Put the data block
  $a->putZmmBlock($node,   $N);                                                 # Put the node block
 }

sub Nasm::X86::Tree::firstNode($$$$)                                            #P Return as a variable the last node block in the specified tree node held in a zmm
 {my ($tree, $K, $D, $N) = @_;                                                  # Tree definition, key zmm, data zmm, node zmm for a node block
  @_ == 4 or confess "Four parameters";

  dFromZ($N, 0)
 }

sub Nasm::X86::Tree::lastNode($$$$)                                             #P Return as a variable the last node block in the specified tree node held in a zmm
 {my ($tree, $K, $D, $N) = @_;                                                  # Tree definition, key zmm, data zmm, node zmm for a node block
  @_ == 4 or confess "Four parameters";

  dFromZ($N, $tree->lengthFromKeys($K) * $tree->width)
 }

sub Nasm::X86::Tree::relativeNode($$$$$)                                        #P Return as a variable a node offset relative (specified as ac constant) to another offset in the same node in the specified zmm
 {my ($tree, $offset, $relative, $K, $N) = @_;                                  # Tree definition, offset, relative location, key zmm, node zmm
  @_ == 5 or confess "Five parameters";

  abs($relative) == 1 or confess "Relative must be +1 or -1";

  my $l = $tree->lengthFromKeys($K);                                            # Length of block
  PushR $K, 7, 15;                                                              # Reuse keys for comparison value
  $offset->setReg(15);
  Vpbroadcastd zmm($K), r15d;                                                   # Load offset to test
  Vpcmpud k7, zmm($N, $K), $Vpcmp->eq;                                          # Check for nodes equal to offset
  Kmovq r15, k7;
  Tzcnt r15, r15;                                                               # Index of offset
  if ($relative < 0)
   {Cmp r15, 0;
    IfEq Then{PrintErrTraceBack "Cannot get offset before first offset"};
    Sub r15, 1;
   }
  if ($relative > 0)
   {Cmp r15, $tree->length;
    IfGt Then{PrintErrTraceBack "Cannot get offset beyond last offset"};
    Add r15, 1;
   }
  my $r = dFromZ $N, V(offset => r15) * $tree->width;                           # Select offset
  PopR;

  $r
 }

sub Nasm::X86::Tree::nextNode($$$$)                                             #P Return as a variable the next node block offset after the specified one in the specified zmm
 {my ($tree, $offset, $K, $N) = @_;                                             # Tree definition, offset, key zmm, node zmm
  @_ == 4 or confess "Four parameters";
  $tree->relativeNode($offset, +1, $K, $N);
 }

sub Nasm::X86::Tree::prevNode($$$$)                                             #P Return as a variable the previous node block offset after the specified one in the specified zmm
 {my ($tree, $offset, $K, $N) = @_;                                             # Tree definition, offset, key zmm, node zmm
  @_ == 4 or confess "Four parameters";
  $tree->relativeNode($offset, -1, $K, $N);
 }

sub Nasm::X86::Tree::indexNode($$$$)                                            #P Return, as a variable, the point mask obtained by testing the nodes in a block for specified offset. We have to supply the keys as well so that we can find the number of nodes. We need the number of nodes so that we only search the valid area not all possible node positions in the zmm.
 {my ($tree, $offset, $K, $N) = @_;                                             # Tree definition, key as a variable, zmm containing keys, comparison from B<Vpcmp>
  @_ == 4 or confess "Four parameters";

  my $A = $K == 17 ? 18 : 17;                                                   # The broadcast facility 1 to 16 does not seem to work reliably so we load an alternate zmm
  PushR rcx, 14, 15, 7, $A;                                                     # Registers

  $offset->setReg(14);                                                          # The offset we are looking for
  Vpbroadcastd zmm($A), r14d;                                                   # Load offset to test
  Vpcmpud k7, zmm($N, $A), $Vpcmp->eq;                                          # Check for nodes equal to offset
  my $l = $tree->lengthFromKeys($K);                                            # Current length of the keys block
  $l->setReg(rcx);                                                              # Create a mask of ones that matches the width of a key node in the current tree.
  Mov   r15, 2;                                                                 # A one in position two because the number of nodes is always one more than the number of keys
  Shl   r15, cl;                                                                # Position the one at end of nodes block
  Dec   r15;                                                                    # Reduce to fill block with ones
  Kmovq r14, k7;                                                                # Matching nodes
  And   r15, r14;                                                               # Matching nodes in mask area
  my $r = V index => r15;                                                       # Save result as a variable
  PopR;

  $r                                                                            # Point of key if non zero, else no match
 }

sub Nasm::X86::Tree::expand($$)                                                 #P Expand the node at the specified offset in the specified tree if it needs to be expanded and is not the root node (which cannot be expanded because it has no siblings to take substance from whereas as all other nodes do).  Set tree.found to the offset of the left sibling if the node at the specified offset was merged into it and freed else set tree.found to zero.
 {my ($tree, $offset) = @_;                                                     # Tree descriptor, offset of node block to expand
  @_ == 2 or confess "Two parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    PushR 8..15, 22..31;

    my $t = $$s{tree};                                                          # Tree to search
    my $L = $$p{offset};                                                        # Offset of node to expand is currently regarded as left
    my $F = 31;
    my $PK = 30; my $PD = 29; my $PN = 28;
    my $LK = 27; my $LD = 26; my $LN = 25;
    my $RK = 24; my $RD = 23; my $RN = 22;

    $t->found->copy(0);                                                         # Assume the left node will not be freed by the expansion
    $t->firstFromMemory($F);                                                    # Load first block
    my $root = $t->rootFromFirst($F);                                           # Root node block offset
    If $root == 0 || $root == $L, Then {Jmp $success};                          # Empty tree or on root so nothing to do

    Block                                                                       # If not on the root and node has the minimum number of keys then either steal left or steal right or merge left or merge right
     {my ($end, $start) = @_;                                                   # Code with labels supplied
      $t->getBlock($L, $LK, $LD, $LN);                                          # Load node from memory
      my $ll = $t->lengthFromKeys($LK);                                         # Length of node
      If $ll > $t->lengthMin, Then {Jmp $end};                                  # Has more than the bare minimum so does not need to be expanded

      my $P = $t->upFromData($LD);                                              # Parent offset
      $t->getBlock($P, $PK, $PD, $PN);                                          # Get the parent keys/data/nodes
      my $fn = $t->firstNode($PK, $PD, $PN);                                    # Parent first node
      my $ln = $t-> lastNode($PK, $PD, $PN);                                    # Parent last node

      my $R = V right => 0;                                                     # The node on the right
      my $plp = $t->indexNode($L, $PK, $PN);                                    # Position of the left node in the parent

      If $plp == 0,                                                             # Zero implies that the left child is not registered in its parent
      Then
       {PrintErrTraceBack "Cannot find left node in parent";
       };

      If $L == $ln,                                                             # If necessary step one to the let and record the fact that we did is that we can restart the search at the top
      Then                                                                      # Last child and needs merging
       {Vmovdqu64 zmm $RK, $LK;                                                 # Copy the current left node into the right node
        Vmovdqu64 zmm $RD, $LD;
        Vmovdqu64 zmm $RN, $LN;
        $R->copy($L);                                                           # Left becomes right node because it is last
        my $l = $plp >> K(one => 1);                                            # The position of the previous node known to exist because we are currently on the last node
        $L->copy($l->dFromPointInZ($PN));                                       # Load previous sibling as new left keeping old left in right so that left and right now form a pair of siblings
        $t->getBlock($L, $LK, $LD, $LN);                                        # Load the new left
        $t->found->copy($L);                                                    # Show that we created a new left
       },
      Else
       {my $r = $plp << K(one => 1);                                            # The position of the node to tthe right known to exist because we are not currently on the last node
        $R->copy($r->dFromPointInZ($PN));                                       # Load next sibling as right
        $t->getBlock($R, $RK, $RD, $RN);                                        # Load the right sibling
       };

      my $lr = $t->lengthFromKeys($RK);                                         # Length of right
      If $lr == $t->lengthMin,
      Then                                                                      # Merge left and right into left as they are both at minimum size
       {$t->merge($PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN);                 # Tree definition, parent keys zmm, data zmm, nodes zmm, left keys zmm, data zmm, nodes zmm.
        # $t->freeBlock($R, $RK, $RD, $RN);                                     # The right is no longer required because it has been merged away

        my $lp = $t->lengthFromKeys($PK);                                       # New length of parent
        If $lp == 0,
        Then                                                                    # Root now empty
         {$t->rootIntoFirst($F, $L);                                            # Parent is now empty so the left block must be the new root
          $t->firstIntoMemory($F);                                              # Save first block with updated root
          #$t->freeBlock($P, $PK, $PD, $PN);                                    # The parent is no longer required because the left ir the new root
         },
        Else                                                                    # Root not empty
         {$t->putBlock($P, $PK, $PD, $PN);                                      # Write parent back into memory
         };
       },
      Else                                                                      # Steal from right as it is too big to merge and so must have some excess that we can steal
       {$t->stealFromRight($PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN);        # Steal
        $t->putBlock($P, $PK, $PD, $PN);                                        # Save modified parent
        $t->putBlock($R, $RK, $RD, $RN);                                        # Save modified right
       };
      $t->putBlock($L, $LK, $LD, $LN);                                          # Save non minimum left

      my $l = $t->leafFromNodes($LN);                                           # Whether the left block is a leaf
      If $l > 0,                                                                # If the zero Flag is zero then this is not a leaf
      Then
       {PushR $RK, $RD, $RN;                                                    # Save these zmm even though we are not going to need them any more
        ($t->lengthFromKeys($LK) + 1)->for(sub                                  # Reparent the children of the left hand side.  This is not efficient as we load all the children (if there are any) but it is effective.
         {my ($index, $start, $next, $end) = @_;
          my $R = dFromZ $LN, $index * $t->width;                               # Offset of node
          $t->getBlock  ($R, $RK, $RD, $RN);                                    # Get child of right node reusing the left hand set of registers as we no longer need them having written them to memory
          $t->upIntoData($L,      $RD);                                         # Parent for child of right hand side
          $t->putBlock  ($R, $RK, $RD, $RN);                                    # Save block into memory now that its parent pointer has been updated
         });
         PopR;
       };
     };  # Block

    SetLabel $success;                                                          # Find completed successfully
    PopR;
   } parameters=>[qw(offset)],
     structures=>{tree=>$tree},
     name => 'Nasm::X86::Tree::expand';

  $s->call(structures=>{tree => $tree}, parameters=>{offset => $offset});
 } # expand

sub Nasm::X86::Tree::replace($$$$)                                              #P Replace the key/data/subTree at the specified point in the specified zmm with the values found in the tree key/data/sub tree fields.
 {my ($tree, $point, $K, $D) = @_;                                              # Tree descriptor, point at which to extract, keys zmm, data zmm
  @_ == 4 or confess "Four parameters";

  $point->dIntoPointInZ($K, $tree->key);                                        # Key
  $point->dIntoPointInZ($D, $tree->data);                                       # Data at point

  $tree->setOrClearTreeBitToMatchContent($K, $point, $tree->subTree);           # Replace tree bit
 } # replace

sub Nasm::X86::Tree::overWriteKeyDataTreeInLeaf($$$$$$$)                        #P Over write an existing key/data/sub tree triple in a set of zmm registers and set the tree bit as indicated.
 {my ($tree, $point, $K, $D, $IK, $ID, $subTree) = @_;                          # Tree descriptor, point at which to overwrite formatted as a one in a sea of zeros, key, data, insert key, insert data, sub tree if tree.

  @_ == 7 or confess "Seven parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    my $success = Label;                                                        # End label

    PushR 1..7, rdi;

    $$p{point}->setReg(rdi);                                                    # Load mask register showing point of insertion.
    Kmovq k7, rdi;                                                              # A sea of zeros with a one at the point of insertion

    $$p{key}  ->setReg(rdi); Vpbroadcastd zmmM($K, 7), edi;                     # Insert value at expansion point
    $$p{data} ->setReg(rdi); Vpbroadcastd zmmM($D, 7), edi;

    If $$p{subTree} > 0,                                                        # Set the inserted tree bit
    Then
     {Kmovq rdi, k7;
      $tree->setTreeBit ($K, rdi);
     },
    Else
     {Kmovq rdi, k7;
      $tree->clearTreeBit($K, rdi);
     };

    PopR;
   } name => "Nasm::X86::Tree::overWriteKeyDataTreeInLeaf($K, $D)",             # Different variants for different blocks of registers.
     structures => {tree=>$tree},
     parameters => [qw(point key data subTree)];

  $s->call(structures => {tree  => $tree},
           parameters => {key   => $IK, data => $ID,
                          point => $point, subTree => $subTree});
 }

#D2 Insert                                                                      # Insert a key into the tree.

sub Nasm::X86::Tree::indexXX($$$$)                                              #P Return, as a variable, the mask obtained by performing a specified comparison on the key area of a node against a specified key.
 {my ($tree, $key, $K, $cmp) = @_;                                              # Tree definition, key as a variable, zmm containing keys, comparison from B<Vpcmp>
  @_ == 4 or confess "Four parameters";

  my $A = $K == 17 ? 18 : 17;                                                   # The broadcast facility 1 to 16 does not seem to work reliably so we load an alternate zmm
  PushR rcx, r14, r15, k7, $A;                                                  # Registers

  $key->setReg(14);
  Vpbroadcastd zmm($A), r14d;                                                   # Load key to test
  Vpcmpud k7, zmm($K, $A), $cmp;                                                # Check keys from memory broadcast
  my $l = $tree->lengthFromKeys($K);                                            # Current length of the keys block
  $l->setReg(rcx);                                                              # Create a mask of ones that matches the width of a key node in the current tree.
  Mov   r15, 1;                                                                 # The one
  Shl   r15, cl;                                                                # Position the one at end of keys block
  Dec   r15;                                                                    # Reduce to fill block with ones
  Kmovq r14, k7;                                                                # Matching keys
  And   r15, r14;                                                               # Matching keys in mask area
  my $r = V index => r15;                                                       # Save result as a variable
  PopR;

  $r                                                                            # Point of key if non zero, else no match
 }

sub Nasm::X86::Tree::indexEq($$$)                                               #P Return the  position of a key in a zmm equal to the specified key as a point in a variable.
 {my ($tree, $key, $K) = @_;                                                    # Tree definition, key as a variable, zmm containing keys
  @_ == 3 or confess "Three parameters";

  $tree->indexXX($key, $K, $Vpcmp->eq);                                         # Check for equal keys from the broadcasted memory
 }

sub Nasm::X86::Tree::insertionPoint($$$)                                        #P Return the position at which a key should be inserted into a zmm as a point in a variable.
 {my ($tree, $key, $K) = @_;                                                    # Tree definition, key as a variable, zmm containing keys
  @_ == 3 or confess "Three parameters";

  $tree->indexXX($key, $K, $Vpcmp->le) + 1;                                     # Check for less than or equal keys
 }

sub Nasm::X86::Tree::insertKeyDataTreeIntoLeaf($$$$$$$$)                        #P Insert a new key/data/sub tree triple into a set of zmm registers if there is room, increment the length of the node and set the tree bit as indicated and increment the number of elements in the tree.
 {my ($tree, $point, $F, $K, $D, $IK, $ID, $subTree) = @_;                      # Tree descriptor, point at which to insert formatted as a one in a sea of zeros, first, key, data, insert key, insert data, sub tree if tree.

  @_ == 8 or confess "Eight parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    my $success = Label;                                                        # End label
    my $t = $$s{tree};                                                          # Address tree

    PushR 4..8;

    my $point = $$p{point};                                                     # Point at which to insert
    $$p{point}->setReg(8);                                                      # Load mask register showing point of insertion.

    Kmovq k7, r8;                                                               # A sea of zeros with a one at the point of insertion

    $t->maskForFullKeyArea(6);                                                  # Mask for key area

    Kandnq  k4, k7, k6;                                                         # Mask for key area with a hole at the insertion point

    Vpexpandd zmmM($K, 4), zmm($K);                                             # Expand to make room for the value to be inserted
    Vpexpandd zmmM($D, 4), zmm($D);

    $$p{key}  ->setReg(8); Vpbroadcastd zmmM($K, 7), r8d;                       # Insert value at expansion point
    $$p{data} ->setReg(8); Vpbroadcastd zmmM($D, 7), r8d;

    $t->incLengthInKeys($K);                                                    # Increment the length of this node to include the inserted value

    $t->insertIntoTreeBits($K, 7, $$p{subTree});                                # Set the matching tree bit depending on whether we were supplied with a tree or a variable

    $t->incSizeInFirst($F);                                                     # Update number of elements in entire tree.

    PopR;
   } name => "Nasm::X86::Tree::insertKeyDataTreeIntoLeaf($F, $K, $D)",          # Different variants for different blocks of registers.
     structures => {tree=>$tree},
     parameters => [qw(point key data subTree)];

  $s->call(structures => {tree  => $tree},
           parameters => {key   => $IK, data => $ID,
                          point => $point, subTree => $subTree});
 }

sub Nasm::X86::Tree::splitNode($$)                                              #P Split a node if it it is full returning a variable that indicates whether a split occurred or not.
 {my ($tree, $offset) = @_;                                                     # Tree descriptor,  offset of block in area of tree as a variable
  @_ == 2 or confess 'Two parameters';

  my $PK = 31; my $PD = 30; my $PN = 29;                                        # Key, data, node blocks
  my $LK = 28; my $LD = 27; my $LN = 26;
  my $RK = 25; my $RD = 24; my $RN = 23;
  my $F  = 22;
                                                                                # First block of this tree
  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    my $t     = $$s{tree};                                                      # Tree
    my $area = $t->area;                                                        # Area

    PushR 22...31;
    ClearRegisters 22..31;                                                      # Otherwise we get left over junk

    my $offset = $$p{offset};                                                   # Offset of block in area
    my $split  = $$p{split};                                                    # Indicate whether we split or not
    $t->getBlock($offset, $LK, $LD, $LN);                                       # Load node as left

    my $length = $t->lengthFromKeys($LK);
    If $t->lengthFromKeys($LK) < $t->maxKeys,
    Then                                                                        # Only split full blocks
     {$split->copy(K split => 0);                                               # Split not required
      Jmp $success;
     };

    my $parent = $t->upFromData($LD);                                           # Parent of this block

    my $r = $t->allocBlock    ($RK, $RD, $RN);                                  # Create a new right block
    If $parent > 0,
    Then                                                                        # Not the root node because it has a parent
     {$t->upIntoData      ($parent, $RD);                                       # Address existing parent from new right
      $t->getBlock        ($parent, $PK, $PD, $PN);                             # Load extant parent
      $t->splitNotRoot
                          ($r,      $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN);
      $t->putBlock        ($parent, $PK, $PD, $PN);
      $t->putBlock        ($offset, $LK, $LD, $LN);
     },
    Else                                                                        # Split the root node
     {my $p = $t->allocBlock       ($PK, $PD, $PN);                             # Create a new parent block
      $t->splitRoot   ($offset, $r, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN);
      $t->upIntoData      ($p,      $LD);                                       # Left  points up to new parent
      $t->upIntoData      ($p,      $RD);                                       # Right points up to new parent
      $t->putBlock        ($p,      $PK, $PD, $PN);
      $t->putBlock        ($offset, $LK, $LD, $LN);
      $t->putBlock        ($r,      $RK, $RD, $RN);

      $t->firstFromMemory ($F);                                                 # Update new root of tree
      $t->rootIntoFirst   ($F, $p);
      $t->firstIntoMemory ($F);
     };

    $t->leafFromNodes($RN);                                                     # Whether the right block is a leaf
    IfNe                                                                        # If the zero Flag is zero then this is not a leaf
    Then
     {(K(nodes => $t->lengthRight) + 1)->for(sub                                # Reparent the children of the right hand side now known not to be a leaf
       {my ($index, $start, $next, $end) = @_;
        my $n = dFromZ $RN, $index * $t->width;                                 # Offset of node
        $t->getBlock  ($n, $LK, $LD, $LN);                                      # Get child of right node reusing the left hand set of registers as we no longer need them having written them to memory
        $t->upIntoData($r,      $LD);                                           # Parent for child of right hand side
        $t->putBlock  ($n, $LK, $LD, $LN);                                      # Save block into memory now that its parent pointer has been updated
       });
     };

    $t->putBlock        ($r,      $RK, $RD, $RN);                               # Save right block

    SetLabel $success;                                                          # Insert completed successfully
    PopR;
   }  structures => {tree => $tree},
      parameters => [qw(offset split)],
      name       => 'Nasm::X86::Tree::splitNode';

  $s->call(structures => {tree   => $tree},
           parameters => {offset => $offset, split => my $p = V split => 1});

  $p                                                                            # Return a variable containing one if the node was split else zero.
 } # splitNode

sub Nasm::X86::Tree::splitNotRoot($$$$$$$$$$$)                                  #P Split a non root left node pushing its excess right and up.
 {my ($tree, $newRight, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN) = @_;      # Tree definition, variable offset in area of right node block, parent keys zmm, data zmm, nodes zmm, left keys zmm, data zmm, nodes zmm, right keys, data, node zmm
  @_ == 11 or confess "Eleven parameters required";

  my $w         = $tree->width;                                                 # Size of keys, data, nodes
  my $zw        = $tree->zWidthD;                                               # Number of dwords in a zmm
  my $zwn       = $tree->maxNodesZ;                                             # Maximum number of dwords that could be used for nodes in a zmm register.
  my $zwk       = $tree->maxKeysZ;                                              # Maxiumum number of dwords used for keys/data in a zmm
  my $lw        = $tree->maxKeys;                                               # Maximum number of keys in a node
  my $ll        = $tree->lengthLeft;                                            # Minimum node width on left
  my $lm        = $tree->lengthMiddle;                                          # Position of splitting key
  my $lr        = $tree->lengthRight;                                           # Minimum node on right
  my $lb        = $tree->lengthOffset;                                          # Position of length byte
  my $tb        = $tree->treeBits;                                              # Position of tree bits
  my $up        = $tree->up;                                                    # Position of up word in data
  my $transfer  = r8;                                                           # Transfer register
  my $transferD = r8d;                                                          # Transfer register as a dword
  my $transferW = r8w;                                                          # Transfer register as a  word
  my $work      = r9;                                                           # Work register as a dword

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Variable parameters, structure variables, structure copies, subroutine description
    PushR $transfer, $work, 1..7;

    my $SK = dFromZ $LK, $ll * $w;                                              # Splitting key
    my $SD = dFromZ $LD, $ll * $w;                                              # Data corresponding to splitting key

    my $mask = sub                                                              # Set k7 to a specified bit mask
     {my ($prefix, @onesAndZeroes) = @_;                                        # Prefix bits, alternating zeroes and ones
      LoadBitsIntoMaskRegister(7, $prefix, @onesAndZeroes);                     # Load k7 with mask
     };

    &$mask("00", $zwk);                                                         # Area to clear in keys and data preserving last qword
    Vmovdqu32    zmmM($RK, 7),  zmm($LK);
    Vmovdqu32    zmmM($RD, 7),  zmm($LD);

    &$mask("0",  $zwn);                                                         # Area to clear in nodes preserving last dword
    Vmovdqu32    zmmM($RN, 7),  zmm($LN);

    &$mask("00", $lw-$zwk,  $lr, -$ll-1);                                       # Compress right data/keys
    Vpcompressd  zmmM($RK, 7),  zmm($RK);
    Vpcompressd  zmmM($RD, 7),  zmm($RD);

    &$mask("0",  $lw-$zwk, $lr+1, -$lr-1);                                      # Compress right nodes
    Vpcompressd  zmmM($RN, 7),  zmm($RN);

    &$mask("11", $ll-$zwk, $ll);                                                # Clear left keys and data
    Vmovdqu32    zmmMZ($LK, 7), zmm($LK);
    Vmovdqu32    zmmMZ($LD, 7), zmm($LD);

    &$mask("1",  $ll-$zwk, $ll+1);                                              # Clear left nodes
    Vmovdqu32    zmmMZ($LN, 7), zmm($LN);

    &$mask("11", 2+$lr-$zw,  $lr);                                              # Clear right keys and data
    Vmovdqu32    zmmMZ($RK, 7), zmm($RK);
    Vmovdqu32    zmmMZ($RD, 7), zmm($RD);

    &$mask("1",  $lr-$zwk, $lr+1);                                              # Clear right nodes
    Vmovdqu32    zmmMZ($RN, 7), zmm($RN);

    my $t = $$s{tree};                                                          # Address tree

    &$mask("00", $zwk);                                                         # Area to clear in keys and data preserving last qword
    my $in = $t->insertionPoint($SK, $PK);                                      # The position at which the key would be inserted if this were a leaf
    $in->setReg($transfer);
    Kmovq k6, $transfer;                                                        # Mask shows insertion point
    Kandnq k5, k6, k7;                                                          # Mask shows expansion needed to make the insertion possible

    Vpexpandd zmmM($PK, 5), zmm($PK);                                           # Make room in parent keys and place the splitting key
    Vpexpandd zmmM($PD, 5), zmm($PD);                                           # Make room in parent data and place the data associated with the splitting key

    $SK->setReg($transfer);                                                     # Key to be inserted
    Vpbroadcastd zmmM($PK, 6), $transferD;                                      # Insert key

    $SD->setReg($transfer);                                                     # Data to be inserted
    Vpbroadcastd zmmM($PD, 6), $transferD;                                      # Insert data


    $in->setReg($transfer);                                                     # Next node up as we always expand to the right
    Shl $transfer, 1;
    Kmovq k4, $transfer;                                                        # Mask shows insertion point
    &$mask("0", $zwn);                                                          # Area to clear in keys and data preserving last qword
    Kandnq k3, k4, k7;                                                          # Mask shows expansion needed to make the insertion possible
    Vpexpandd zmmM($PN, 3), zmm($PN);                                           # Expand nodes

    $$p{newRight}->setReg($transfer);                                           # New right node to be inserted
    Vpbroadcastd zmmM($PN, 4), $transferD;                                      # Insert node

                                                                                # Lengths
    wRegFromZmm $work, $PK, $lb;                                                # Increment length of parent field
    Inc $work;
    wRegIntoZmm $work, $PK, $lb;

    Mov $work, $ll;                                                             # Lengths
    wRegIntoZmm $work, $LK, $lb;                                                # Left after split
    Mov $work, $lr;                                                             # Lengths
    wRegIntoZmm $work, $RK, $lb;                                                # Right after split

    &$mask("01", -$zwk);                                                        # Copy parent offset from left to right so that the new right node  still has the same parent
    Vmovdqu32 zmmM($RD, 7), zmm($LD);

    wRegFromZmm $transfer, $LK, $tb;                                            # Tree bits
    Mov $work, $transfer;
    And $work, (1 << $ll) - 1;
    wRegIntoZmm $work, $LK, $tb;                                                # Left after split

    Mov $work, $transfer;
    Shr $work, $lm;
    And $work, (1 << $lr) - 1;
    wRegIntoZmm $work, $RK, $tb;                                                # Right after split

    Mov $work, $transfer;                                                       # Insert splitting key tree bit into parent at the location indicated by k5
    Shr $work, $ll;
    And  $work, 1;                                                              # Tree bit to be inserted parent at the position indicated by a single 1 in k5 in parent
    wRegFromZmm $transfer, $PK, $tb;                                            # Tree bits from parent

    Cmp  $work, 0;                                                              # Are we inserting a zero into the tree bits?
    IfEq
    Then                                                                        # Inserting zero
     {InsertZeroIntoRegisterAtPoint k6, $transfer;                              # Insert a zero into transfer at the point indicated by k5
     },
    Else                                                                        # Inserting one
     {InsertOneIntoRegisterAtPoint k6, $transfer;                               # Insert a zero into transfer at the point indicated by k5
     };
    wRegIntoZmm $transfer, $PK, $tb;                                            # Save parent tree bits after split

    PopR;
   }
  structures => {tree => $tree},
  parameters => [qw(newRight)],
  name       => "Nasm::X86::Tree::splitNotRoot".
          "($lw, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)";

  $s->call(
    structures => {tree => $tree},
    parameters => {newRight => $newRight});
 }
sub Nasm::X86::Tree::splitRoot($$$$$$$$$$$$)                                    #P Split a non root node into left and right nodes with the left half left in the left node and splitting key/data pushed into the parent node with the remainder pushed into the new right node
 {my ($tree, $nLeft, $nRight, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN) = @_;# Tree definition, variable offset in area of new left node block, variable offset in area of new right node block, parent keys zmm, data zmm, nodes zmm, left keys zmm, data zmm, nodes zmm, right keys, data , nodes zmm
  @_ == 12 or confess "Twelve parameters required";

  my $w         = $tree->width;                                                 # Size of keys, data, nodes
  my $zw        = $tree->zWidthD;                                               # Number of dwords in a zmm
  my $zwn       = $tree->maxNodesZ;                                             # Maximum number of dwords that could be used for nodes in a zmm register.
  my $zwk       = $tree->maxKeysZ;                                              # Maxiumum number of dwords used for keys/data in a zmm
  my $lw        = $tree->maxKeys;                                               # Maximum number of keys in a node
  my $ll        = $tree->lengthLeft;                                            # Minimum node width on left
  my $lm        = $tree->lengthMiddle;                                          # Position of splitting key
  my $lr        = $tree->lengthRight;                                           # Minimum node on right
  my $lb        = $tree->lengthOffset;                                          # Position of length byte
  my $tb        = $tree->treeBits;                                              # Position of tree bits
  my $transfer  = r8;                                                           # Transfer register
  my $transferD = r8d;                                                          # Transfer register as a dword
  my $transferW = r8w;                                                          # Transfer register as a  word

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Variable parameters, structure variables, structure copies, subroutine description

    my $mask = sub                                                              # Set k7 to a specified bit mask
     {my ($prefix, @onesAndZeroes) = @_;                                        # Prefix bits, alternating zeroes and ones
      LoadBitsIntoMaskRegister(7, $prefix, @onesAndZeroes);                     # Load k7 with mask
     };

    my $t = $$s{tree};                                                          # Address tree

    PushR $transfer, 6, 7;

    $t->maskForFullKeyArea(7);                                                  # Mask for keys area
    $t->maskForFullNodesArea(6);                                                # Mask for nodes area

    Mov $transfer, -1;
    Vpbroadcastd zmmM($PK, 7), $transferD;                                      # Force keys to be high so that insertion occurs before all of them

    Mov $transfer, 0;
    Vpbroadcastd zmmM($PD, 7), $transferD;                                      # Zero other keys and data
    Vpbroadcastd zmmM($RK, 7), $transferD;
    Vpbroadcastd zmmM($RD, 7), $transferD;

    Mov $transfer, 0;
    Vpbroadcastd zmmM($PN, 6), $transferD;
    Vpbroadcastd zmmM($RN, 6), $transferD;

    my $newRight = $$p{newRight};
    $t->splitNotRoot($newRight, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN);   # Split the root node as if it were a non root node

    $$p{newLeft} ->dIntoZ($PN, 0);                                              # Place first - left sub node into new root
    $$p{newRight}->dIntoZ($PN, 4);                                              # Place second - right sub node into new root

    Kshiftrw k7, k7, 1;                                                         # Reset parent keys/data outside of single key/data
    Kshiftlw k7, k7, 1;
    Mov $transfer, 0;
    Vpbroadcastd zmmM($PK, 7), $transferD;

    Mov $transfer, 1;                                                           # Lengths
    wRegIntoZmm $transfer, $PK, $lb;                                            # Left after split

    wRegFromZmm $transfer, $PK, $tb;                                            # Parent tree bits
    And $transfer, 1;
    wRegIntoZmm $transfer, $PK, $tb;

    PopR;
   }
  structures => {tree => $tree},
  parameters => [qw(newLeft newRight)],
  name       => "Nasm::X86::Tree::splitRoot".
          "($lw, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)";

  $s->call
   (structures => {tree => $tree},
    parameters => {newLeft => $nLeft, newRight => $nRight});
 }

sub Nasm::X86::Tree::put($$$)                                                   # Put a variable key and data into a tree. The data could be a tree descriptor to place a sub tree into a tree at the indicated key.
 {my ($tree, $key, $data) = @_;                                                 # Tree definition, key as a variable, data as a variable or a tree descriptor
  @_ == 3 or confess "Three parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    my $success = Label;                                                        # End label

    PushR my ($F, $K, $D, $N) = reverse 28..31;

    my $t = $$s{tree};
    my $k = $$p{key};
    my $d = $$p{data};
    my $S = $$p{subTree};
    my $a = $t->area;

    my $start = SetLabel;                                                       # Start the descent through the tree

    $t->firstFromMemory($F);
    my $Q = $t->rootFromFirst($F);                                              # Start the descent at the root node

    If $Q == 0,                                                                 # First entry as there is no root node.
    Then
     {my $block = $t->allocBlock($K, $D, $N);
      $k->dIntoZ                ($K, 0);
      $d->dIntoZ                ($D, 0);
      $t->incLengthInKeys       ($K);
      $t->setOrClearTreeBitToMatchContent($K, K(key => 1), $S);
      $t->putBlock($block,       $K, $D, $N);
      $t->rootIntoFirst         ($F, $block);
      $t->incSizeInFirst        ($F);
      $t->firstIntoMemory       ($F);                                           # First back into memory
      Jmp $success;
     };

    my $descend = SetLabel;                                                     # Descend to the next level

    $t->getBlock($Q, $K, $D, $N);                                               # Get the current block from memory

    my $eq = $t->indexEq($k, $K);                                               # Check for an equal key
    If $eq > 0,                                                                 # Equal key found
    Then                                                                        # Overwrite the existing key/data
     {$t->overWriteKeyDataTreeInLeaf($eq, $K, $D, $k, $d, $S);
      $t->putBlock                  ($Q,  $K, $D, $N);
      Jmp $success;
     };

    my $split = $t->splitNode($Q);                                              # Split blocks that are full
    If $split > 0,
    Then
     {Jmp $start;                                                               # Restart the descent now that this block has been split
     };

    my $leaf = $t->leafFromNodes($N);                                           # Are we on a leaf node ?
    If $leaf > 0,
    Then
     {my $i = $t->insertionPoint($k, $K);                                       # Find insertion point
      $t->insertKeyDataTreeIntoLeaf($i, $F, $K, $D, $k, $d, $S);
      $t->putBlock                 ($Q, $K, $D, $N);
      $t->firstIntoMemory          ($F);                                        # First back into memory
      Jmp $success;
     };

    my $in = $t->insertionPoint($k, $K);                                        # The position at which the key would be inserted if this were a leaf
    my $next = $in->dFromPointInZ($N);                                          # The node to the left of the insertion point - this works because the insertion point can be upto one more than the maximum number of keys

    $Q->copy($next);                                                            # Get the offset of the next node - we are not on a leaf so there must be one
    Jmp $descend;                                                               # Descend to the next level

    SetLabel $success;
    PopR;
   } name => "Nasm::X86::Tree::put",
     structures => {tree=>$tree},
     parameters => [qw(key data subTree)];

  if (ref($data) !~ m(Tree))                                                    # Whether we are a putting a sub tree
   {$s->call(structures => {tree    => $tree},
             parameters => {key     => $key,
                            data    => $data,
                            subTree => K(zero => 0)});
   }
  else
   {$s->call(structures => {tree    => $tree},
             parameters => {key     => $key,
                            data    => $data->first,
                            subTree => K(key => 1)});
   }
 }

#D2 Find                                                                        # Find a key in the tree. Trees have dword integer keys and so can act as arrays as well.

sub Nasm::X86::Tree::zero($)                                                    #P Zero the return fields of a tree descriptor
 {my ($tree) = @_;                                                              # Tree descriptor, key field to search for
  @_ == 1 or confess "One parameter";
  $tree->found  ->copy(0);                                                      # Key not found
  $tree->key    ->copy(0);                                                      # Copy in key so we know what was searched for
  $tree->data   ->copy(0);                                                      # Data not yet found
  $tree->subTree->copy(0);                                                      # Not yet a sub tree
  $tree->offset ->copy(0);                                                      # Offset not known
 }

sub Nasm::X86::Tree::find($$)                                                   # Find a key in a tree and tests whether the found data is a sub tree.  The results are held in the variables "found", "data", "subTree" addressed by the tree descriptor. The key just searched for is held in the key field of the tree descriptor. The point at which it was found is held in B<found> which will be zero if the key was not found.
 {my ($tree, $key) = @_;                                                        # Tree descriptor, key field to search for
  @_ == 2 or confess "Two parameters";
  ref($key) =~ m(Variable) or confess "Variable required";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    PushR my $F = 31, my $K = 30, my $D = 29, my $N = 28;;

    my $t = $$s{tree};                                                          # Tree to search
       $t->zero;                                                                # Clear all the return fields
    $t->key->copy(my $k = $$p{key});                                            # Copy in key so we know what was searched for

    $t->firstFromMemory      ($F);                                              # Load first block
    my $Q = $t->rootFromFirst($F);                                              # Start the search from the root
    If $Q == 0,
    Then                                                                        # Empty tree so we have not found the key
     {Jmp $success;                                                             # Return
     };

    K(loop=>99)->for(sub                                                        # Step down through tree
     {my ($index, $start, $next, $end) = @_;

      $t->getBlock($Q, $K, $D, $N);                                             # Get the keys/data/nodes

      my $eq = $t->indexEq($k, $K);                                             # The position of a key in a zmm equal to the specified key as a point in a variable.
      If $eq  > 0,                                                              # Result mask is non zero so we must have found the key
      Then
       {my $d = $eq->dFromPointInZ($D);                                         # Get the corresponding data
        $t->found ->copy($eq);                                                  # Key found at this point
        $t->data  ->copy($d);                                                   # Data associated with the key
        $t->offset->copy($Q);                                                   # Offset of the containing block
        $t->subTree->copy($t->getTreeBit($K, $eq));                             # Get corresponding tree bit
        Jmp $success;                                                           # Return
       };

      my $leaf = $t->leafFromNodes($N);                                         # Are we on a leaf
      If $leaf > 0,
      Then                                                                      # Zero implies that this is a leaf node so we cannot search any further and will have to go with what you have
       {Jmp $success;                                                           # Return
       };

      my $i = $t->insertionPoint($k, $K);                                       # The insertion point if we were inserting
      my $n = $i->dFromPointInZ($N);                                            # Get the corresponding data
      $Q->copy($n);                                                             # Corresponding node
     });
    PrintErrTraceBack "Stuck in find";                                          # We seem to be looping endlessly

    SetLabel $success;                                                          # Find completed successfully
    PopR;
   } parameters=>[qw(key)],
     structures=>{tree=>$tree},
     name => 'Nasm::X86::Tree::find';

  $s->call(structures=>{tree => $tree}, parameters=>{key => $key});
 } # find

sub Nasm::X86::Tree::findFirst($)                                               # Find the first element in a tree and set B<found>|B<key>|B<data>|B<subTree> to show the result
 {my ($tree) = @_;                                                              # Tree descriptor
  @_ == 1 or confess "One parameter";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Successfully completed

    my $t = $$s{tree};                                                          # Tree to search

    $t->found  ->copy(0);                                                       # Key not found
    $t->data   ->copy(0);                                                       # Data not yet found
    $t->subTree->copy(0);                                                       # Not yet a sub tree
    $t->offset ->copy(0);                                                       # Offset not known

    PushR 28..31;

    my $F = 31; my $K = 30; my $D = 29; my $N = 28;

    $t->firstFromMemory($F);                                                    # Update the size of the tree
    my $size = $t->sizeFromFirst($F);                                           # Size of tree

    If $size == 0,                                                              # Empty tree
    Then
     {Jmp $success
     };

    my $root = $t->rootFromFirst($F);                                           # Root of tree
    $t->getBlock($root, $K, $D, $N);                                            # Load root

    K(loop => 99)->for(sub                                                      # Step down through the tree a reasonable number of times
     {my ($i, $start, $next, $end) = @_;
      my $k = dFromZ($K, 0);
      my $d = dFromZ($D, 0);
      my $n = dFromZ($N, 0);
      my $b = $t->getTreeBit($K, K key => 1);

      If $t->leafFromNodes($N),                                                 # Leaf node means we have arrived
      Then
       {$t->found  ->copy(1);
        $t->key    ->copy($k);
        $t->data   ->copy($d);
        $t->subTree->copy($b);
        Jmp $success
       };

      $t->getBlock($n, $K, $D, $N);
     });
    PrintErrTraceBack "Stuck looking for first";

    SetLabel $success;                                                          # Find completed successfully
    PopR;
   } structures=>{tree=>$tree},
     name => "Nasm::X86::Tree::findFirst($$tree{length})";

  $s->call(structures=>{tree => $tree});
 } # findFirst

sub Nasm::X86::Tree::findLast($)                                                # Find the last key in a tree
 {my ($tree) = @_;                                                              # Tree descriptor
  @_ == 1 or confess "One parameter";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Successfully completed

    my $t = $$s{tree};                                                          # Tree to search

    $t->found  ->copy(0);                                                       # Key not found
    $t->data   ->copy(0);                                                       # Data not yet found
    $t->subTree->copy(0);                                                       # Not yet a sub tree
    $t->offset ->copy(0);                                                       # Offset not known

    PushR 28..31;

    my $F = 31; my $K = 30; my $D = 29; my $N = 28;

    $t->firstFromMemory($F);                                                    # Update the size of the tree
    my $size = $t->sizeFromFirst($F);                                           # Size of tree

    If $size == 0,                                                              # Empty tree
    Then
     {Jmp $success
     };

    my $root = $t->rootFromFirst($F);                                           # Root of tree
    $t->getBlock($root, $K, $D, $N);                                            # Load root

    K(loop => 99)->for(sub                                                      # Step down through the tree a reasonable number of times
     {my ($i, $start, $next, $end) = @_;
      my $l = $t->lengthFromKeys($K);
      my $o  = ($l - 1) * $t->width;
      my $O  = ($l + 0) * $t->width;
      my $k = dFromZ($K, $o);
      my $d = dFromZ($D, $o);
      my $n = dFromZ($N, $O);
      my $b = $t->getTreeBit($K, $l);

      If $t->leafFromNodes($N),                                                 # Leaf node means we have arrived
      Then
       {$t->found   ->copy(1);
        $t->key    ->copy($k);
        $t->data   ->copy($d);
        $t->subTree->copy($b);
        Jmp $success
       };

      $t->getBlock($n, $K, $D, $N);
     });
    PrintErrTraceBack "Stuck looking for last";

    SetLabel $success;                                                          # Find completed successfully
    PopR;
   } structures=>{tree=>$tree},
     name => "Nasm::X86::Tree::findLast($$tree{length})";

  $s->call(structures=>{tree => $tree});
 } # findLast

sub Nasm::X86::Tree::findNext($$)                                               # Find the next key greater than the one specified.
 {my ($tree, $key) = @_;                                                        # Tree descriptor, key
  @_ == 2 or confess "Two parameters";
  ref($key) =~ m(Variable) or confess "Variable required";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    PushR 28..31;
    my $t = $$s{tree};                                                          # Tree to search
    my $k = $$p{key};                                                           # Key to find
    $t->key->copy($k);                                                          # Copy in key so we know what was searched for

    my $F = 31; my $K = 30; my $D = 29; my $N = 28;
    my $lengthMask = k6; my $testMask = k7;

    $t->found  ->copy(0);                                                       # Key not found
    $t->data   ->copy(0);                                                       # Data not yet found
    $t->subTree->copy(0);                                                       # Not yet a sub tree
    $t->offset ->copy(0);                                                       # Offset not known

    $t->firstFromMemory      ($F);                                              # Load first block
    my $Q = $t->rootFromFirst($F);                                              # Start the search from the root
    If $Q == 0,
    Then                                                                        # Empty tree so we have successfully not found the key
     {Jmp $success;                                                             # Return
     };

    my $li = V(key => 0);                                                       # Offset of last not right tells us where to continue the search -
    my $lQ = V(key => 0);                                                       # Insertion point of last non right

    K(loop=>99)->for(sub                                                        # Step down through tree
     {my ($index, $start, $next, $end) = @_;

      $t->getBlock($Q, $K, $D, $N);                                             # Get the keys/data/nodes
      my $lp   = K(key => 1) << $t->lengthFromKeys($K);                         # Point to last node in nodes area
      my $i = $t->insertionPoint($k, $K);                                       # The insertion point
      If $t->leafFromNodes($N) > 0,
      Then                                                                      # On a leaf
       {If $i == $lp,
        Then                                                                    # Last in leaf so reposition on last not right
         {If $li == 0, Then {Jmp $success};                                     # Greater than all keys
          $t->getBlock($li, $K, $D, $N);
          $i->copy($lQ);
         };
        $t->found  ->copy($i);                                                  # Key found at this point
        $t->key    ->copy($i->dFromPointInZ($K));                               # Save key
        $t->data   ->copy($i->dFromPointInZ($D));                               # Save data
        $t->subTree->copy($t->getTreeBit   ($K, $i));                           # Save sub tree
        $t->offset ->copy($Q);                                                  # Save offset
        Jmp $success;                                                           # Return
       };

      my $n = $i->dFromPointInZ($N);                                            # Get the corresponding data
      If $i != $lp,
      Then                                                                      # Not descending through the last right
       {$li->copy($Q);
        $lQ->copy($i);
       };
      $Q->copy($n);                                                             # Corresponding node
     });
    PrintErrTraceBack "Stuck in find next";                                     # We seem to be looping endlessly

    SetLabel $success;                                                          # Find completed successfully
    PopR;
   } parameters=>[qw(key)],
     structures=>{tree=>$tree},
     name => 'Nasm::X86::Tree::findNext';

  $s->call(structures=>{tree => $tree}, parameters=>{key => $key});
 } # findNext

sub Nasm::X86::Tree::findPrev($$)                                               # Find the previous key less than the one specified.
 {my ($tree, $key) = @_;                                                        # Tree descriptor, key
  @_ == 2 or confess "Two parameters";
  ref($key) =~ m(Variable) or confess "Variable required";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    PushR 28..31;
    my $t = $$s{tree};                                                          # Tree to search
    my $k = $$p{key};                                                           # Key to find
    $t->key->copy($k);                                                          # Copy in key so we know what was searched for

    my $F = 31; my $K = 30; my $D = 29; my $N = 28;
    my $lengthMask = k6; my $testMask = k7;

    $t->found  ->copy(0);                                                       # Key not found
    $t->data   ->copy(0);                                                       # Data not yet found
    $t->subTree->copy(0);                                                       # Not yet a sub tree
    $t->offset ->copy(0);                                                       # Offset not known

    $t->firstFromMemory      ($F);                                              # Load first block
    my $Q = $t->rootFromFirst($F);                                              # Start the search from the root
    If $Q == 0, Then {Jmp $success};                                            # Empty tree so we have successfully not found the key

    my $li = V key => 0;                                                        # Offset of last not right tells us where to continue the search -
    my $lQ = V key => 0;                                                        # Insertion point of last non right

    K(loop => 99)->for(sub                                                      # Step down through tree
     {my ($index, $start, $next, $end) = @_;
      $t->getBlock($Q, $K, $D, $N);                                             # Get the keys/data/nodes
      my $i = $t->insertionPoint($k, $K);                                       # The insertion point
      If $i > 1,
      Then
       {my $j = $i >> K key => 1;
        If $j->dFromPointInZ($K) == $k,
        Then
         {$i->copy($j);
         };
       };

      If $t->leafFromNodes($N) > 0,
      Then                                                                      # On a leaf
       {If $i == 1,
        Then                                                                    # First in leaf so reposition on last not left
         {If $li == 0, Then {Jmp $success};                                     # Greater than all keys
          $t->getBlock($li, $K, $D, $N);
          $i->copy($lQ);
         };
        $i->copy($i >> K(one => 1));
        $t->found  ->copy($i);                                                  # Key found at this point
        $t->key    ->copy($i->dFromPointInZ($K));                               # Save key
        $t->data   ->copy($i->dFromPointInZ($D));                               # Save data
        $t->subTree->copy($t->getTreeBit   ($K, $i));                           # Save sub tree
        $t->offset ->copy($Q);                                                  # Save offset
        Jmp $success;                                                           # Return
       };

      my $n = $i->dFromPointInZ($N);                                            # Get the corresponding data
      If $i != 1,
      Then                                                                      # Not descending through the first left
       {$li->copy($Q);
        $lQ->copy($i);
       };
      $Q->copy($n);                                                             # Corresponding node
     });
    PrintErrTraceBack "Stuck in find prev";                                     # We seem to be looping endlessly

    SetLabel $success;                                                          # Find completed successfully
    PopR;
   } parameters=>[qw(key)],
     structures=>{tree=>$tree},
     name => 'Nasm::X86::Tree::findPrev';

  $s->call(structures=>{tree => $tree}, parameters=>{key => $key});
 } # findPrev

sub Nasm::X86::Tree::findAndReload($$)                                          #P Find a key in the specified tree and clone it is it is a sub tree.
 {my ($t, $key) = @_;                                                           # Tree descriptor, key as a dword
  @_ == 2 or confess "Two parameters";

  $t->find($key);                                                               # Find the key
  If $t->found > 0,                                                             # Make the found data the new  tree
  Then
   {$t->first->copy($t->data);                                                  # Copy the data variable to the first variable without checking whether it is valid
   };
 }

sub Nasm::X86::Tree::leftOrRightMost($$$$)                                      #P Return the offset of the left most or right most node.
 {my ($tree, $dir, $node, $offset) = @_;                                        # Tree descriptor, direction: left = 0 or right = 1, start node,  offset of located node
  @_ == 4 or confess "Four parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    my $t        = $$s{tree};                                                   # Tree
       $t->first->copy(my $F = $$p{node});                                      # First block
    my $area = $t->area;                                                        # Area
    PushR rax, 8, 9, 29..31;

    K(loopLimit=>9)->for(sub                                                    # Loop a reasonable number of times
     {my ($index, $start, $next, $end) = @_;
      $t->getBlock($F, 31, 30, 29);                                             # Get the first keys block
      my $n = dFromZ 29, 0;                                                     # Get the node block offset from the data block loop
      If $n == 0,
      Then                                                                      # Reached the end so return the containing block
       {$$p{offset}->copy($F);
        Jmp $success;
       };
      if ($dir == 0)                                                            # Left most
       {my $l = dFromZ 29, 0;                                                   # Get the left most node
        $F->copy($l);                                                           # Continue with the next level
       }
      else                                                                      # Right most
       {my $l = $t->lengthFromKeys(31);                                         # Length of the node
        my $r = dFromZ 31, $l;                                                  # Get the right most child
        $F->copy($r);                                                           # Continue with the next level
       }
     });
    PrintErrStringNL "Stuck in LeftOrRightMost";
    Exit(1);

    SetLabel $success;                                                          # Insert completed successfully
    PopR;
   } structures => {tree => $tree},
     parameters => [qw(node offset)],
     name       => $dir==0 ? "Nasm::X86::Tree::leftMost" :
                             "Nasm::X86::Tree::rightMost";

  $s->call(structures => {tree=>$tree},
           parameters => {node => $node, offset=>$offset});
 }

sub Nasm::X86::Tree::leftMost($$$)                                              #P Return the offset of the left most node from the specified node.
 {my ($t, $node, $offset) = @_;                                                 # Tree descriptor, start node, returned offset
  @_ == 3 or confess "Three parameters";
  $t->leftOrRightMost(0, $node, $offset)                                        # Return the left most node
 }

sub Nasm::X86::Tree::rightMost($$$)                                             #P Return the offset of the left most node from the specified node.
 {my ($t, $node, $offset) = @_;                                                 # Tree descriptor, start node, returned offset
  @_ == 3 or confess "Three parameters";
  $t->leftOrRightMost(1, $node, $offset)                                        # Return the right most node
 }

sub Nasm::X86::Tree::depth($$)                                                  # Return the depth of a node within a tree.
 {my ($tree, $node) = @_;                                                       # Tree descriptor, node
  @_ == 2 or confess "Two parameters required";
  PrintErrTraceBack "Rewrite me";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    my $t = $$s{tree};                                                          # Tree
    my $area = $tree->area;                                                     # Area
    my $N = $$p{node};                                                          # Starting node

    PushR 8, 9, 14, 15, 30, 31;
    my $tree = $N->clone('tree');                                               # Start at the specified node

    K(loop => 9)->for(sub                                                       # Step up through tree
     {my ($index, $start, $next, $end) = @_;
      $t->getKeysData($tree, 31, 30, r8, r9);                                   # Get the first node of the tree
      my $P = $t->getUpFromData(30);                                            # Parent
      If $P == 0,
      Then                                                                      # Empty tree so we have not found the key
       {$$p{depth}->copy($index+1);                                             # Key not found
        Jmp $success;                                                           # Return
       };
      $tree->copy($P);                                                          # Up to next level
     });
    PrintErrStringNL "Stuck in depth";                                          # We seem to be looping endlessly
    Exit(1);

    SetLabel $success;                                                          # Insert completed successfully
    PopR;
   }  structures => {tree => $tree},
      parameters => [qw(node depth)],
      name       => 'Nasm::X86::Tree::depth';

  $s->call(structures => {tree => $tree->copyDescription},
           parameters => {node => $node, depth => my $d = V depth => 0});

  $d
 } # depth

#D2 Sub trees                                                                   # Construct trees of trees.

sub Nasm::X86::Tree::isTree($$$)                                                #P Set the Zero Flag to oppose the tree bit in the numbered zmm register holding the keys of a node to indicate whether the data element indicated by the specified register is an offset to a sub tree in the containing area or not.
{my ($t, $zmm, $point) = @_;                                                    # Tree descriptor, numbered zmm register holding the keys for a node in the tree, register showing point to test
 @_ == 3 or confess "Three parameters";

  my $z = registerNameFromNumber $zmm;                                          # Full name of zmm register
  my $o = $t->treeBits;                                                         # Bytes from tree bits to end of zmm
  my $w = $t->zWidth;                                                           # Size of zmm register
  Vmovdqu64    "[rsp-$w]", $z;                                                  # Write beyond stack
  Test $point, "[rsp-$w+$o]";                                                   # Test the tree bit under point
 } # isTree

sub Nasm::X86::Tree::getTreeBit($$$)                                            #P Get the tree bit from the numbered zmm at the specified point and return it in a variable as a one or a zero.
 {my ($t, $zmm, $point) = @_;                                                   # Tree descriptor, register showing point to test, numbered zmm register holding the keys for a node in the tree
  @_ == 3 or confess "Three parameters";

  $t->getTreeBits($zmm, rdi);                                                   # Tree bits
  $point->setReg(rsi);
  And rdi, rsi;                                                                 # Write beyond stack
  my $r = V treeBit => 0;
  Cmp di, 0;
  IfNe Then {$r->copy(1)};
  $r
 }

sub Nasm::X86::Tree::setOrClearTreeBit($$$$)                                    #P Set or clear the tree bit selected by the specified point in the numbered zmm register holding the keys of a node to indicate that the data element indicated by the specified register is an offset to a sub tree in the containing area.
 {my ($t, $set, $point, $zmm) = @_;                                             # Tree descriptor, set if true else clear, register holding point to set, numbered zmm register holding the keys for a node in the tree
  @_ == 4 or confess "Four parameters";
  #CheckGeneralPurposeRegister($point);
  my $z = registerNameFromNumber $zmm;                                          # Full name of zmm register
  my $o = $t->treeBits;                                                         # Tree bits to end of zmm
  my $r = registerNameFromNumber $point;
  PushR $z;                                                                     # Push onto stack so we can modify it
  if ($set)                                                                     # Set the indexed bit
   {And $point, $t->treeBitsMask;                                               # Mask tree bits to prevent operations outside the permitted area
    Or "[rsp+$o]", $point;                                                      # Set tree bit in zmm
   }
  else                                                                          # Clear the indexed bit
   {And $point, $t->treeBitsMask;                                               # Mask tree bits to prevent operations outside the permitted area
    Not $point;
    And "[rsp+$o]", $point;
   }
  PopR;                                                                         # Retrieve zmm
 } # setOrClearTree

sub Nasm::X86::Tree::setTreeBit($$$)                                            #P Set the tree bit in the numbered zmm register holding the keys of a node to indicate that the data element indexed by the specified register is an offset to a sub tree in the containing area.
 {my ($t, $zmm, $point) = @_;                                                   # Tree descriptor, numbered zmm register holding the keys for a node in the tree, register holding the point to clear
  @_ == 3 or confess "Three parameters";
  $t->setOrClearTreeBit(1, $point, $zmm);
 } # setTree

sub Nasm::X86::Tree::clearTreeBit($$$)                                          #P Clear the tree bit in the numbered zmm register holding the keys of a node to indicate that the data element indexed by the specified register is an offset to a sub tree in the containing area.
{my ($t, $zmm, $point) = @_;                                                    # Tree descriptor, numbered zmm register holding the keys for a node in the tree, register holding register holding the point to set
  @_ == 3 or confess "Three parameters";
  $t->setOrClearTreeBit(0, $point, $zmm);
 } # clearTree


sub Nasm::X86::Tree::setOrClearTreeBitToMatchContent($$$$)                      #P Set or clear the tree bit pointed to by the specified register depending on the content of the specified variable.
 {my ($t, $zmm, $point, $content) = @_;                                         # Tree descriptor, numbered keys zmm, register indicating point, content indicating zero or one
  @_ == 4 or confess "Four parameters";

  if (ref($point))                                                              # Point is a variable so we must put it in a register
   {PushR 15;
    $point->setReg(15);
    If $content > 0,                                                            # Content represents a tree
    Then
     {$t->setTreeBit($zmm, r15);
     },
    Else                                                                        # Content represents a variable
     {$t->clearTreeBit($zmm, r15);
     };
    PopR;
   }
  Else
   {If $content > 0,                                                            # Content represents a tree
    Then
     {$t->setTreeBit($zmm, $point);
     },
    Else                                                                        # Content represents a variable
     {$t->clearTreeBit($zmm, $point);
     };
   }
 }

sub Nasm::X86::Tree::getTreeBits($$$)                                           #P Load the tree bits from the numbered zmm into the specified register.
 {my ($t, $zmm, $register) = @_;                                                # Tree descriptor, numbered zmm, target register
  @_ == 3 or confess "Three parameters";
  wRegFromZmm $register, $zmm, $t->treeBits;
  And $register, $t->treeBitsMask;
 }

sub Nasm::X86::Tree::setTreeBits($$$)                                           #P Put the tree bits in the specified register into the numbered zmm.
 {my ($t, $zmm, $register) = @_;                                                # Tree descriptor, numbered zmm, target register
  @_ == 3 or confess "Three parameters";
  And $register, $t->treeBitsMask;
  wRegIntoZmm $register, $zmm, $t->treeBits;
 }

sub Nasm::X86::Tree::insertTreeBit($$$$)                                        #P Insert a zero or one into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.
 {my ($t, $onz, $zmm, $point) = @_;                                             # Tree descriptor, 0 - zero or 1 - one, numbered zmm, register indicating point
  @_ == 4 or confess "Four parameters";
  my $z = registerNameFromNumber $zmm;
  my $p = registerNameFromNumber $point;
  PushR my @save = my ($bits) = ChooseRegisters(1, $point);                     # Tree bits register
  $t->getTreeBits($zmm, $bits);                                                 # Get tree bits
  if ($onz)
   {InsertOneIntoRegisterAtPoint ($p, $bits);                                   # Insert a one into the tree bits at the indicated location
   }
  else
   {InsertZeroIntoRegisterAtPoint($p, $bits);                                   # Insert a zero into the tree bits at the indicated location
   }
  $t->setTreeBits($zmm, $bits);                                                 # Put tree bits
  PopR;
 }

sub Nasm::X86::Tree::insertZeroIntoTreeBits($$$)                                #P Insert a zero into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.
 {my ($t, $zmm, $point) = @_;                                                   # Tree descriptor, numbered zmm, register indicating point
  @_ == 3 or confess "3 parameters";
  $t->insertTreeBit(0, $zmm, $point);                                           # Insert a zero into the tree bits field in the numbered zmm at the specified point
 }

sub Nasm::X86::Tree::insertOneIntoTreeBits($$$)                                 #P Insert a one into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.
 {my ($t, $zmm, $point) = @_;                                                   # Tree descriptor, numbered zmm, register indicating point
  @_ == 3 or confess "Three parameters";
  $t->insertTreeBit(1, $zmm, $point);                                           # Insert a one into the tree bits field in the numbered zmm at the specified point
 }

sub Nasm::X86::Tree::insertIntoTreeBits($$$$)                                   #P Insert a one into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.
 {my ($t, $zmm, $point, $content) = @_;                                         # Tree descriptor, numbered zmm, register indicating point, bit to insert
  @_ == 4 or confess "Four parameters";

  if (ref($point))                                                              # Point is a variable so we must put into a register
   {PushR 15;
    $point->setReg(15);
    If $content > 0,                                                            # Content represents a one
    Then
     {$t->insertOneIntoTreeBits ($zmm, r15);
     },
    Else                                                                        # Content represents a zero
     {$t->insertZeroIntoTreeBits($zmm, r15);
     };
    PopR;
   }
  else
   {If $content > 0,                                                            # Content represents a one
    Then
     {$t->insertOneIntoTreeBits ($zmm, $point);
     },
    Else                                                                        # Content represents a zero
     {$t->insertZeroIntoTreeBits($zmm, $point);
     };
   }
 }

#D2 Delete                                                                      # Delete a key from the tree

sub Nasm::X86::Tree::extract($$$$$)                                             #P Extract the key/data/node and tree bit at the specified point from the block held in the specified zmm registers.
 {my ($tree, $point, $K, $D, $N) = @_;                                          # Tree descriptor, point at which to extract, keys zmm, data zmm, node zmm
  @_ == 5 or confess "Five parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    my $t = $$s{tree};                                                          # Tree to search
    my $l = $t->leafFromNodes($N);                                              # Check for a leaf
    If $l == 0,                                                                 # If the zero Flag is zero then this is not a leaf
    Then                                                                        # We can only perform this operation on a leaf
     {PrintErrTraceBack "Cannot extract from a non leaf node";
     };

#    my $l = $t->lengthFromKeys($K);                                            # Check for a minimal block
#    If $l <= $t->lengthMin,
#    Then                                                                       # Minimal block - extraction not possible
#     {PrintErrTraceBack "Cannot extract from a minimum block";
#     };
#
    PushR 7, 15;

    my $q = $$p{point};                                                         # Point at which to extract
    $t->data->copy($q->dFromPointInZ($D));                                      # Data at point
    $t->subTree->copy($t->getTreeBit($K, $q));                                  # Sub tree or not a sub tree

    $q->setReg(15);                                                             # Create a compression mask to squeeze out the key/data
    Not r15;                                                                    # Invert point
    Mov rsi, r15;                                                               # Inverted point
    And rsi, $t->keyDataMask;                                                   # Mask for keys area
    Kmovq k7, rsi;
    Vpcompressd zmmM($K, 7), zmm($K);                                           # Compress out the key
    Vpcompressd zmmM($D, 7), zmm($D);                                           # Compress out the data

    PushR 6, 31;
    $t->getTreeBits($K, rsi);                                                   # Tree bits
    Kmovq k6, rsi;
    Vpmovm2d zmm(31), k6;                                                       # Broadcast the tree bits into a zmm
    Vpcompressd zmmM(31, 7), zmm(31);                                           # Compress out the tree bit in question
    Vpmovd2m k6, zmm(31);                                                       # Reform the tree bits minus the squeezed out bit
    Kmovq rsi, k6;                                                              # New tree bits
    $t->setTreeBits($K, rsi);                                                   # Reload tree bits
    PopR;

    Mov rsi, r15;                                                               # Inverted point
    And rsi, $t->nodeMask;                                                      # Mask for node area
    Kmovq k7, rsi;
    Vpcompressd zmmM($N, 7), zmm($N);                                           # Compress out the node

    $t->decLengthInKeys($K);                                                    # Reduce length by  one

    SetLabel $success;                                                          # Find completed successfully
    PopR;
   } parameters=>[qw(point)],
     structures=>{tree=>$tree},
     name => "Nasm::X86::Tree::extract($K, $D, $N, $$tree{length})";

  $s->call(structures=>{tree => $tree}, parameters=>{point => $point});
 } # extract

sub Nasm::X86::Tree::extractFirst($$$$)                                         #P Extract the first key/data and tree bit at the specified point from the block held in the specified zmm registers and place the extracted data/bit in tree data/subTree.
 {my ($tree, $K, $D, $N) = @_;                                                  # Tree descriptor, keys zmm, data zmm, node zmm
  @_ == 4 or confess "Four parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    my $t = $$s{tree};                                                          # Tree to search
    $t->leafFromNodes($N);                                                      # Check for a leaf
    IfNe                                                                        # If the zero Flag is zero then this is not a leaf
    Then                                                                        # We can only perform this operation on a leaf
     {PrintErrTraceBack "Cannot extract first from a non leaf node";
     };

    $t->key ->copy(dFromZ($K, 0));                                              # Save corresponding key  into tree data field
    $t->data->copy(dFromZ($D, 0));                                              # Save corresponding data into tree data field

    PushR 7;
    Mov rsi, $t->keyDataMask;                                                   # Mask for keys area
    Sub rsi, 1;                                                                 # Mask for keys area with a zero in the first position
    Kmovq k7, rsi;
    Vpcompressd zmmM($K, 7), zmm($K);                                           # Compress out the key
    Vpcompressd zmmM($D, 7), zmm($D);                                           # Compress out the data

    $t->getTreeBits($K, rdi);                                                   # Tree bits
    Mov rsi, rdi;
    And rsi, 1;                                                                 # First tree bit
    $t->subTree->getReg(rsi);                                                   # Save tree bit
    Shr rdi, 1;                                                                 # Remove first tree bit
    $t->setTreeBits($K, rdi);                                                   # Reload tree bits

    $t->decLengthInKeys($K);                                                    # Reduce length by  one

    SetLabel $success;                                                          # Find completed successfully

    PopR;
   } parameters=>[qw(point)],
     structures=>{tree=>$tree},
     name => "Nasm::X86::Tree::extractFirst($K, $D, $N, $$tree{length})";

  $s->call(structures=>{tree => $tree});
 } # extractFirst

sub Nasm::X86::Tree::mergeOrSteal($$)                                           #P Merge the block at the specified offset with its right sibling or steal from it. If there is no  right sibling then do the same thing but with the left sibling.  The supplied block must not be the root. The key we ae looking for must be in the tree key field.
 {my ($tree, $offset) = @_;                                                     # Tree descriptor, offset of non root block that might need to merge or steal
  @_ == 2 or confess "Two parameters";

  my $s = Subroutine
   {my ($parameters, $structures, $sub) = @_;                                   # Parameters, structures, subroutine definition

    my $t  = $$structures{tree};                                                # Tree to search
    my $F  = 31;
    my $PK = 30; my $PD = 29; my $PN = 28;
    my $LK = 27; my $LD = 26; my $LN = 25;
    my $RK = 24; my $RD = 23; my $RN = 22;

    PushR 22..31;

    my $l = $$parameters{offset}->clone("left");                                # Offset of left node that might need merging
    If $l == 0,
    Then
     {PrintErrTraceBack "Zero offset in mergeOrSteal";
     };
    $t->getBlock($l, $LK, $LD, $LN);                                            # Get the keys/data/nodes
    my $p = $t->upFromData($LD);                                                # Parent offset
    If $p == 0,
    Then
     {PrintErrTraceBack "Cannot mergeOrSteal the root";
     };

    my $ll = $t->lengthFromKeys($LK);                                           # Length of left
    If $ll == $t->lengthMin,                                                    # Need to merge or steal
    Then
     {$t->getBlock($p, $PK, $PD, $PN);                                          # Get the parent
      If $l != $t->lastNode($PK, $PD, $PN),
      Then                                                                      # Not the last node so we ca either steal or merge right
       {my $ll = $t->lengthFromKeys($LK);                                       # Length of left
        my $r = $t->nextNode($l, $PK, $PN);                                     # Right hand will be next sibling
        $t->getBlock($r, $RK, $RD, $RN);                                        # Get next sibling

        my $rl = $t->lengthFromKeys($RK);
        If $rl == $t->lengthMin,
        Then                                                                    # Merge left and right siblings because we now know they are both minimal
         {$t->merge($PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN);               # Tree definition, parent keys zmm, data zmm, nodes zmm, left keys zmm, data zmm, nodes zmm.
          If $t->lengthFromKeys($PK) == 0,
          Then                                                                  # We just merged in the root so make the left sibling the root
           {$t->firstFromMemory($F);
            $t->rootIntoFirst($F, $l);
            $t->firstIntoMemory($F);
            $t->upIntoData(K(zero => 0), $LD);                                  # Zero the up pointer for the root
            $t->freeBlock($p, $PK, $PD, $PN);                                   # Free parent as it is no longer needed
           },                                                                   # Else not required
          Else                                                                  # Steal from right sibling
           {$t->putBlock($p, $PK, $PD, $PN);                                    # Save modified parent
           };
          $t->freeBlock($r, $RK, $RD, $RN);                                     # Free right as it is no longer needed
         },
        Else                                                                    # Steal from right sibling
         {$t->stealFromRight($PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN);      # Steal
          $t->putBlock($p, $PK, $PD, $PN);                                      # Save modified parent
          $t->putBlock($r, $RK, $RD, $RN);                                      # Save modified right
         };
        $t->putBlock($l, $LK, $LD, $LN);                                        # Save non minimum left
        $$parameters{changed}->copy(1);                                         # Show that we changed the tree layout
       },

      Else                                                                      # Left sibling is last so we either merge the two nodes to eliminate the right node or steal from the left is that is not possible
       {my $r = $l;                                                             # The left sibling is last so we make it the right block
        $t->getBlock($r, $RK, $RD, $RN);                                        # Get the right keys/data/nodes
        my $l = $t->prevNode($r, $PK, $PN);                                     # Left block will be previous sibling
        $t->getBlock($l, $LK, $LD, $LN);                                        # Get the right keys/data/nodes
        my $ll = $t->lengthFromKeys($LK);                                       # Length of left
        If $ll == $t->lengthMin,                                                # Has the the bare minimum so must merge or steal
        Then
         {$t->merge($PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN);               # Tree definition, parent keys zmm, data zmm, nodes zmm, left keys zmm, data zmm, nodes zmm.
          If $t->lengthFromKeys($PK) == 0,
          Then                                                                  # We just merged in the root so make the left sibling the root
           {$t->firstFromMemory($F);
            $t->rootIntoFirst($F, $l);
            $t->firstIntoMemory($F);
            $t->upIntoData(K(zero => 0), $LD);                                  # Zero the up pointer for the root
            $t->freeBlock($p, $PK, $PD, $PN);                                   # Free parent as it is no longer needed
           },                                                                   # Else not required
          Else                                                                  # Steal from right sibling
           {$t->putBlock($p, $PK, $PD, $PN);                                    # Save modified parent
           };
           $t->freeBlock($r, $RK, $RD, $RN);                                    # Save modified right
         },
        Else                                                                    # Steal from right sibling
         {$t->stealFromLeft($PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN);       # Steal
          $t->putBlock($p, $PK, $PD, $PN);                                      # Save modified parent
          $t->putBlock($r, $RK, $RD, $RN);                                      # Save modified right
         };
        $t->putBlock($l, $LK, $LD, $LN);                                        # Save non minimum left
        $$parameters{changed}->copy(1);                                         # Show that we changed the tree layout
       };
     };
    PopR;
   } parameters=>[qw(offset changed)],
     structures=>{tree=>$tree},
     name => "Nasm::X86::Tree::mergeOrSteal($$tree{length})";

  $s->call(structures=>
   {tree       =>  $tree},
    parameters => {offset=> $offset, changed => my $changed = V changed => 0});

  $changed                                                                      # Whether we did a merge or steal
 } # mergeOrSteal

sub Nasm::X86::Tree::stealFromRight($$$$$$$$$$)                                 #P Steal one key from the node on the right where the current left node,parent node and right node are held in zmm registers and return one if the steal was performed, else zero.
 {my ($tree, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN) = @_;                 # Tree definition, parent keys zmm, data zmm, nodes zmm, left keys zmm, data zmm, nodes zmm, right keys, data, nodes zmm.
  @_ == 10 or confess "Ten parameters required";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Variable parameters, structure variables, structure copies, subroutine description
    my $t  = $$s{tree};
    my $ll = $t->lengthFromKeys($LK);
    my $lr = $t->lengthFromKeys($RK);

    PushR 7;

    $t->found->copy(0);                                                         # Assume we cannot steal

    Block                                                                       # Check that it is possible to steal key a from the node on the right
     {my ($end, $start) = @_;                                                   # Code with labels supplied
      If $ll != $t->lengthLeft,
      Then                                                                      # Left not minimal
       {PrintErrStringNL "Left not minimal";
        Jmp $end
       };
      If $lr == $t->lengthRight,                                                # Right minimal
      Then
       {PrintErrStringNL "Should merge not steal";
        Jmp $end
       };

      $t->found->copy(1);                                                       # Proceed with the steal

      my $pir = (K one => 1);                                                   # Point of right key to steal
      my $pil = $pir << ($ll - 1);                                              # Point of left key to receive key

      my $rk  = $pir->dFromPointInZ($RK);                                       # Right key to rotate left
      my $rd  = $pir->dFromPointInZ($RD);                                       # Right data to rotate left
      my $rn  = $pir->dFromPointInZ($RN);                                       # Right node to rotate left

      If $t->leafFromNodes($LN) == 0,
      Then                                                                      # Left is not a leaf so the right is not a leaf so we must upgrade first right child up pointer
       {PushR $LK, $LD, $LN, $RK, $RD, $RN;
        my $ln = dFromZ($LN, 0);                                                # First child of left
        $t->getBlock($ln, $LK, $LD, $LN);                                       # Left grand child
        $t->getBlock($rn, $RK, $RD, $RN);                                       # Right grand child
        my $lcu = $t->upFromData($LD);                                          # Offset of left block
        $t->upIntoData($lcu, $RD);                                              # Set up of right grand child to left block
        $t->putBlock($rn, $RK, $RD, $RN);
        PopR;
       };

      my $pip = $t->insertionPoint($rk, $PK);                                   # Point of parent key to insert
      my $pip1= $pip >> K(one=>1);                                              # Point of parent key to merge in
      my $pk  = $pip1->dFromPointInZ($PK);                                      # Parent key to rotate left
      my $pd  = $pip1->dFromPointInZ($PD);                                      # Parent data to rotate left

      my $pb  = $t->getTreeBit($PK, $pip);                                      # Parent tree bit
      my $rb  = $t->getTreeBit($RK, K one => 1);                                # First right tree bit
      $pip1->dIntoPointInZ($PK, $rk);                                           # Right key into parent
      $pip1->dIntoPointInZ($PD, $rd);                                           # Right data into parent
      $t->setOrClearTreeBitToMatchContent($PK, $pip, $rb);                      # Right tree bit into parent
      $pk->dIntoZ($LK, $t->middleOffset);                                       # Parent key into left
      $pd->dIntoZ($LD, $t->middleOffset);                                       # Parent data into left
      $rn->dIntoZ($LN, $t->rightOffset);                                        # Right node into left

      $t->insertIntoTreeBits($LK, K(position => 1 << $t->lengthLeft), $pb);     # Parent tree bit into left

      LoadConstantIntoMaskRegister                                              # Nodes area
       (7, createBitNumberFromAlternatingPattern '00', $t->maxKeysZ-1, -1);
      Vpcompressd zmmM($RK, 7), zmm($RK);                                       # Compress right keys one slot left
      Vpcompressd zmmM($RD, 7), zmm($RD);                                       # Compress right data one slot left

      LoadConstantIntoMaskRegister                                              # Nodes area
       (7, createBitNumberFromAlternatingPattern '0', $t->maxNodesZ-1, -1);
      Vpcompressd zmmM($RN, 7), zmm($RN);                                       # Compress right nodes one slot left

      $t->incLengthInKeys($LK);                                                 # Increment left hand length
      $t->decLengthInKeys($RK);                                                 # Decrement right hand
     };
    PopR;
   }
  name       =>
  "Nasm::X86::Tree::stealFromRight($$tree{length}, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)",
  structures => {tree => $tree},
  parameters => [qw(result)];

  $s->call(structures => {tree   => $tree});

  $tree                                                                         # Chain
 }

sub Nasm::X86::Tree::stealFromLeft($$$$$$$$$$)                                  #P Steal one key from the node on the left where the current left node,parent node and right node are held in zmm registers and return one if the steal was performed, else  zero.
 {my ($tree, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN) = @_;                 # Tree definition, parent keys zmm, data zmm, nodes zmm, left keys zmm, data zmm, nodes zmm, right keys, data, nodes zmm.
  @_ == 10 or confess "Ten parameters required";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Variable parameters, structure variables, structure copies, subroutine description
    my $t  = $$s{tree};
    my $ll = $t->lengthFromKeys($LK);
    my $lr = $t->lengthFromKeys($RK);

    PushR 7;

    $t->found->copy(0);                                                         # Assume we cannot steal

    Block                                                                       # Check that it is possible to steal a key from the node on the left
     {my ($end, $start) = @_;                                                   # Code with labels supplied
      If $lr != $t->lengthRight,  Then {Jmp $end};                              # Right not minimal
      If $ll == $t->lengthLeft,   Then {Jmp $end};                              # Left minimal

      $t->found->copy(1);                                                       # Proceed with the steal

      my $pir = K(one => 1);                                                    # Point of right key
      my $pil = $pir << ($ll - 1);                                              # Point of left key

      my $lk  = $pil->dFromPointInZ($LK);                                       # Left key to rotate right
      my $ld  = $pil->dFromPointInZ($LD);                                       # Left data to rotate right
      my $ln  = ($pil << K(key => 1))->dFromPointInZ($LN);                      # Left node to rotate right

      my $lb  = $t->getTreeBit($LK, $pil);                                      # Left tree bit to rotate right

      my $pip = $t->insertionPoint($lk, $PK);                                   # Point of parent key to merge in

      my $pk  = $pip->dFromPointInZ($PK);                                       # Parent key to rotate right
      my $pd  = $pip->dFromPointInZ($PD);                                       # Parent data to rotate right
      my $pb  = $t->getTreeBit($PK, $pip);                                      # Parent tree bit

      LoadConstantIntoMaskRegister                                              # Nodes area
       (7, createBitNumberFromAlternatingPattern '00', $t->maxKeysZ-1, -1);
      Vpexpandd zmmM($RK, 7), zmm($RK);                                         # Expand right keys one slot right
      Vpexpandd zmmM($RD, 7), zmm($RD);                                         # Expand right data one slot right

      LoadConstantIntoMaskRegister                                              # Nodes area
       (7, createBitNumberFromAlternatingPattern '0', $t->maxNodesZ-1, -1);
      Vpexpandd zmmM($RN, 7), zmm($RN);                                         # Expand right nodes one slot right

      $pip->dIntoPointInZ($PK, $lk);                                            # Left key into parent
      $pip->dIntoPointInZ($PD, $ld);                                            # Left data into parent
      $t->setOrClearTreeBitToMatchContent($PK, $pip, $lb);                      # Left tree bit into parent

      $pir->dIntoPointInZ($RK, $pk);                                            # Parent key into right
      $pir->dIntoPointInZ($RD, $pd);                                            # Parent data into right
      $pir->dIntoPointInZ($RN, $ln);                                            # Left node into right
      $t->insertIntoTreeBits($RK, $pir, $pb);                                   # Parent tree bit into right

      $t->decLengthInKeys($LK);                                                 # Decrement left hand
      $t->incLengthInKeys($RK);                                                 # Increment right hand

      If $t->leafFromNodes($RN) == 0,
      Then                                                                      # Right is not a leaf so we must upgrade the up pointer of the first child of right to match that of the second child of right
       {PushR $LK, $LD, $LN, $RK, $RD, $RN;
        my $r1 = dFromZ($RN, 0);                                                # First child of right
        my $r2 = dFromZ($RN, 0);                                                # Second child of right
        $t->getBlock($r1, $LK, $LD, $LN);                                       # Load first child of right
        $t->getBlock($r2, $RK, $RD, $RN);                                       # Load second child of right
        my $r2u = $t->upFromData($RD);                                          # Up from second child of right
        $t->upIntoData($r2u, $LD);                                              # Set first child up to second child up
        $t->putBlock($r1, $LK, $LD, $LN);
        PopR;
       };

     };
    PopR;
   }
  name       =>
  "Nasm::X86::Tree::stealFromLeft($$tree{length}, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)",
  structures => {tree => $tree};

  $s->call(structures => {tree   => $tree});

  $tree                                                                         # Chain
 } # stealFromLeft

sub Nasm::X86::Tree::merge($$$$$$$$$$)                                          #P Merge a left and right node if they are at minimum size.
 {my ($tree, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN) = @_;                 # Tree definition, parent keys zmm, data zmm, nodes zmm, left keys zmm, data zmm, nodes zmm, right keys, data, nodes zmm.
  @_ == 10 or confess "Ten parameters required";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Variable parameters, structure variables, structure copies, subroutine description
    my $t  = $$s{tree};
    my $ll = $t->lengthFromKeys($LK);
    my $lr = $t->lengthFromKeys($RK);

    PushR 7, 14, 15;

    Block                                                                       # Check that it is possible to steal a key from the node on the left
     {my ($end, $start) = @_;                                                   # Code with labels supplied
      If $ll != $t->lengthLeft,  Then {Jmp $end};                               # Left not minimal
      If $lr != $t->lengthRight, Then {Jmp $end};                               # Right not minimal

      my $pil = K(one => 1);                                                    # Point of first left key
      my $lk  = $pil->dFromPointInZ($LK);                                       # First left key
      my $pip = $t->insertionPoint($lk, $PK);                                   # Point of parent key to merge in
      my $pk  = $pip->dFromPointInZ($PK);                                       # Parent key to merge
      my $pd  = $pip->dFromPointInZ($PD);                                       # Parent data to merge
      my $pn  = $pip->dFromPointInZ($PN);                                       # Parent node to merge
      my $pb  = $t->getTreeBit($PK, $pip);                                      # Parent tree bit

      my $m = K(one => 1) << K( shift => $t->lengthLeft);                       # Position of parent key in left
      $m->dIntoPointInZ($LK, $pk);                                              # Position parent key in left
      $m->dIntoPointInZ($LD, $pd);                                              # Position parent data in left
     #$m->dIntoPointInZ($LN, $pn);                                              # Position parent node in left - not needed because the left and right around the aprent lkey are the left and right node offsets - we should use this fact to update the children of the right node so that their up pointers point to the left node
      $t->insertIntoTreeBits($LK, $m, $pb);                                     # Tree bit for parent data
      LoadConstantIntoMaskRegister                                              # Keys/Data area
       (7, createBitNumberFromAlternatingPattern '00', $t->lengthRight,   -$t->lengthMiddle);
      Vpexpandd zmmM($LK, 7), zmm($RK);                                         # Expand right keys into left
      Vpexpandd zmmM($LD, 7), zmm($RD);                                         # Expand right data into left
      LoadConstantIntoMaskRegister                                              # Nodes area
       (7, createBitNumberFromAlternatingPattern '0',  $t->lengthRight+1, -$t->lengthMiddle);
      Vpexpandd zmmM($LN, 7), zmm($RN);                                         # Expand right data into left

      $pip->setReg(15);                                                         # Collapse mask for keys/data in parent
      Not r15;
      And r15, $t->treeBitsMask;
      Kmovq k7, r15;
      Vpcompressd zmmM($PK, 7), zmm($PK);                                       # Collapse parent keys
      Vpcompressd zmmM($PD, 7), zmm($PD);                                       # Collapse data keys

      my $one = K(one => 1);                                                    # Collapse mask for keys/data in parent
#     my $np = (!$pip << $one) >> $one;
      my $np = !$pip << $one;                                                   # Move the compression point up one to remove the matching node
      $np->setReg(14);
      Add r14, 1;                                                               # Fill hole left at position 0
      Kmovq k7, r14;                                                            # Node squeeze mask
      Vpcompressd zmmM($PN, 7), zmm($PN);                                       # Collapse nodes

      my $z = $PK == 31 ? 30: 31;                                               # Collapse parent tree bits
      PushR zmm $z;                                                             # Collapse parent tree bits
      $t->getTreeBits($PK, r15);                                                # Get tree bits
      Kmovq k7, r15;                                                            # Tree bits
      Vpmovm2d zmm($z), k7;                                                     # Broadcast the bits into a zmm
      $pip->setReg(15);                                                         # Parent insertion point
      Kmovq k7, r15;
      Knotq k7, k7;                                                             # Invert parent insertion point
      Vpcompressd zmmM($z, 7), zmm($z);                                         # Compress
      Vpmovd2m k7, zmm $z;                                                      # Recover bits
      Kmovq r15, k7;
      And r15, $t->treeBitsMask;                                                # Clear trailing bits beyond valid tree bits
      $t->setTreeBits($PK, r15);
      PopR;

      $t->getTreeBits($LK, r15);                                                # Append right tree bits to the Left tree bits
      $t->getTreeBits($RK, r14);                                                # Right tree bits
      my $sl = RegisterSize(r15) * $bitsInByte / 4 - $tree->lengthMiddle;       # Clear bits right of the lower left bits
      Shl r15w, $sl;
      Shr r15w, $sl;

      Shl r14, $tree->lengthMiddle;                                             # Move right tree bits into position
      Or  r15, r14;                                                             # And in left tree bits
      And r15, $t->treeBitsMask;                                                # Clear trailing bits beyond valid tree bits
      $t->setTreeBits($LK, r15);                                                # Set tree bits

      If $t->leafFromNodes($RN) == 0,
      Then                                                                      # Right is not a leaf so we must upgrade the up offset of its children to the up pointer of the first left child
       {PushR $LK, $LD, $LN;
        my $l1 = dFromZ($LN, 0);                                                # First child of left
        $t->getBlock($l1, $LK, $LD, $LN);                                       # Load first child of left
        my $l2u = $t->upFromData($LD);                                          # Offset of left block
        my $lr = 1 + $t->lengthFromKeys($RK);                                   # Number of right children
        $lr->for(sub                                                            # Each child of right
         {my ($i) = @_;
          my $r = dFromZ($RN, $i * $tree->width);                               # Offset of child
          $t->getBlock($r, $LK, $LD, $LN);                                      # Load child of right
          $t->upIntoData ($l2u, $LD);                                           # Set parent
          $t->putBlock($r, $LK, $LD, $LN);                                      # Write back into memory
         });
        PopR;
       };

      $t->decLengthInKeys($PK);                                                 # Parent now has one less
      $t->lengthIntoKeys($LK, K length => $t->length);                          # Left is now full

     };
    PopR;
   }
  name       =>
  "Nasm::X86::Tree::merge($$tree{length}, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)",
  structures => {tree => $tree};

  $s->call(structures => {tree=> $tree});

  $tree                                                                         # Chain
 } # merge

sub Nasm::X86::Tree::deleteFirstKeyAndData($$$)                                 #P Delete the first element of a leaf mode returning its characteristics in the calling tree descriptor.
 {my ($tree, $K, $D) = @_;                                                      # Tree definition, keys zmm, data zmm
  @_ == 3 or confess "Three parameters";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Variable parameters, structure variables, structure copies, subroutine description
    my $t = $$s{tree};
    my $l = $t->lengthFromKeys($K);

    PushR 7, 14, 15;

    $t->found->copy(0);                                                         # Assume not found

    Block                                                                       # Check that it is possible to steal a key from the node on the left
     {my ($end, $start) = @_;                                                   # Code with labels supplied
      If $l == 0,  Then {Jmp $end};                                             # No elements left

      $t->found->copy(1);                                                       # Show first key and data have been found

      $t->key ->copy(dFromZ $K, 0);                                             # First key
      $t->data->copy(dFromZ $D, 0);                                             # First data
      $t->getTreeBits($K, r15);                                                 # First tree bit

      Mov r14, r15;
      Shr r14, 1;                                                               # Shift tree bits over by 1
      $t->setTreeBits($K, r14);                                                 # Save new tree bits
      And r15, 1;                                                               # Isolate first tree bit
      $t->subTree->copy(r15);                                                   # Save first tree bit

      my $m = (K(one => 1) << K(shift => $t->length)) - 2;                      # Compression mask to remove key/data
      $m->setReg(7);
      Vpcompressd zmmM($K, 7), zmm($K);                                         # Compress out first key
      Vpcompressd zmmM($D, 7), zmm($D);                                         # Compress out first data

      $t->decLengthInKeys($K);                                                  # Reduce length
     };
    PopR;
   }
  name       => "Nasm::X86::Tree::deleteFirstKeyAndData($K, $D)",
  structures => {tree => $tree};

  $s->call(structures => {tree => $tree});

  $tree                                                                         # Chain tree - actual data is in key, data,  subTree, found variables
 }

sub Nasm::X86::Tree::delete($$)                                                 # Find a key in a tree and delete it
 {my ($tree, $key) = @_;                                                        # Tree descriptor, key field to delete
  @_ == 2 or confess "Two parameters";
  ref($key) =~ m(Variable) or confess "Variable required";

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $success = Label;                                                        # Short circuit if ladders by jumping directly to the end after a successful push

    my $t = $$s{tree};                                                          # Tree to search
    my $k = $$p{key};                                                           # Key to find

    $t->found  ->copy(0);                                                       # Key not found
    $t->data   ->copy(0);                                                       # Data not yet found
    $t->subTree->copy(0);                                                       # Not yet a sub tree
    $t->offset ->copy(0);                                                       # Offset not known
    $t->key->copy($k);                                                          # Copy in key so we know what was searched for

    $t->find($k);                                                               # See if we can find the key
    If $t->found == 0, Then {Jmp $success};                                     # Key not present so we cannot delete

    PushR my $F = 31, my $K = 30, my $D = 29, my $N = 28;

    $t->firstFromMemory($F);                                                    # Update the size of the tree
    my $size = $t->sizeFromFirst($F);                                           # Size of tree
    $t->decSizeInFirst($F);
    $t->firstIntoMemory($F);

    K(loop => 99)->for(sub
     {my ($i, $startDescent, $next, $end) = @_;

      $t->firstFromMemory         ($F);                                         # Load first block
      my $root = $t->rootFromFirst($F);                                         # Start the search from the root to locate the  key to be deleted
      If $root == 0, Then{Jmp $success};                                        # Empty tree so we have not found the key and nothing needs to be done

      If $size == 1,                                                            # Delete the last element which must be the matching element
      Then
       {$t->rootIntoFirst($F, K z=>0);                                          # Empty the tree
        $t->firstIntoMemory($F);                                                # The position of the key in the root node
        Jmp $success
       };

      $t->getBlock($root, $K, $D, $N);                                          # Load root block
      If $t->leafFromNodes($N) > 0,                                             # Element must be in the root as the root is a leaf and we know the key can be found
      Then
       {my $eq = $t->indexEq($k, $K);                                           # Key must be in this leaf as we know it can be found and this is the last opportunity to find it
        $t->extract($eq, $K, $D, $N);                                           # Extract from root
        $t->putBlock($root, $K, $D, $N);
        Jmp $success
       };

      my $P = $root->clone('position');                                         # Position in tree
      K(loop => 99)->for(sub                                                    # Step down through tree looking for the key
       {my ($index, $start, $next, $end) = @_;
        my $eq = $t->indexEq($k, $K);                                           # The key might still be in the parent now known not be a leaf
        If $eq > 0,
        Then                                                                    # We have found the key so now we need to find the next leaf unless this node is in fact a leaf
         {my $pu = $t->upFromData($D);                                          # Parent offset
          If $pu > 0,
          Then                                                                  # Cannot merge or steal on root
           {If $t->mergeOrSteal($P) > 0,                                        # Merge or steal if necessary
            Then                                                                # Restart entire process because we might have changed the position of the key being deleted by merging in its vicinity
             {Jmp $startDescent;
             };
           };

          If $t->leafFromNodes($N) > 0,                                         # We found the item in a leaf so it can be deleted immediately if there is enough
          Then
           {my $eq = $t->indexEq($k, $K);                                       # Key must be in this leaf as we know it can be found and this is the last opportunity to find it
            $t->extract($eq, $K, $D, $N);                                       # Remove from block
            $t->putBlock($P, $K, $D, $N);                                       # Save block
            Jmp $success;                                                       # Leaf removed
           };

          my $eq = $t->indexEq($k, $K);                                         # Location of key
          my $Q = ($eq << K(one=>1))->dFromPointInZ($N);                        # Go right to the next level down

          K(loop => 99)->for(sub                                                # Find the left most leaf
           {my ($index, $start, $next, $end) = @_;

            If $t->mergeOrSteal($Q) > 0,                                        # Merge or steal if necessary
            Then                                                                # Restart entire process because we might have changed the position of the key being deleted by merging in its vicinity
             {Jmp $startDescent;
             };
            $t->getBlock($Q, $K, $D, $N);                                       # Next block down
            If $t->leafFromNodes($N) > 0,                                       # We must hit a leaf eventually
            Then
             {$t->extractFirst($K, $D, $N);                                     # Remove from block
              $t->putBlock($Q, $K, $D, $N);                                     # Save block

              my $key     = $t->key->clone("key");                              # Record details of leaf
              my $data    = $t->data->clone("data");                            #
              my $subTree = $t->subTree->clone("data");                         #
              $t->find($k);                                                     # Find key we actually want to delete

              $t->key    ->copy($key);                                          # Reload
              $t->data   ->copy($data);
              $t->subTree->copy($subTree);

              my $l = $t->offset;                                               # Offset of block containing key

              $t->getBlock($l, $K, $D, $N);                                     # Block containing key
              $t->replace ($t->found,  $K, $D);                                 # Replace key to delete with leaf
              $t->putBlock($l, $K, $D, $N);                                     # Save block
              Jmp $success;
             };

            my $i = $t->insertionPoint($k, $K);                                 # The insertion point if we were inserting is the next node to visit
            $Q->copy($i->dFromPointInZ($N));                                    # Get the corresponding offset of the the next block down
           });
           Jmp $success;
         };

        my $i = $t->insertionPoint($k, $K);                                     # The insertion point if we were inserting is the next node to visit
        $P->copy($i->dFromPointInZ($N));                                        # Get the corresponding node

        $t->getBlock($P, $K, $D, $N);                                           # Get the next block

        my $l = $t->lengthFromKeys($K);                                         # Length of block

        If $l == $t->lengthMin,                                                 # Has the the bare minimum so must be merged.
        Then
         {If $t->mergeOrSteal($P) > 0,                                          # Merge or steal if necessary
          Then                                                                  # Restart entire process because we might have changed the position of the key being deleted by merging in its vicinity
           {Jmp $startDescent;
           };
         };
       });
     });
    PrintErrTraceBack "Stuck looking for leaf";

    SetLabel $success;                                                          # Find completed successfully
    PopR;
   } parameters=>[qw(key)],
     structures=>{tree=>$tree},
     name => "Nasm::X86::Tree::delete($$tree{length})";

  $s->call(structures=>{tree => $tree}, parameters=>{key => $key});
 } # delete

#D2 Print                                                                       # Print a tree

sub Nasm::X86::Tree::dump($$)                                                   # Dump a tree and all its sub trees.
 {my ($tree, $title) = @_;                                                      # Tree, title
  @_ == 2 or confess "Two parameters";

  PushR my $F = 31;

  my $s = Subroutine                                                            # Print a tree
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition
    my $t = $$s{tree};                                                          # Tree
    my $I = $$p{indentation};                                                   # Indentation to apply to the start of each new line

    PushR my $transfer = r8, my $treeBitsR = r10, my $treeBitsIndexR = r11,
          my $K = 30, my $D = 29, my $N = 28;

    Block                                                                       # Print each node in the tree
     {my ($end, $start) = @_;                                                   # Labels
      my $offset = $$p{offset};                                                 # Offset of node to print
      $t->getBlock($offset, $K, $D, $N);                                        # Load node
      $t->getTreeBits($K, $treeBitsR);                                          # Tree bits for this node
      my $l = $t->lengthFromKeys($K);                                           # Number of nodes

      my $root = $t->rootFromFirst($F);                                         # Root or not

      $I->outSpaces;
      PrintOutString "At: ";                                                    # Print position and length
      $offset->outRightInHex(K width => 4);
      (K(col => 20) - $I)->outSpaces;
      PrintOutString "length: ";
      $l->outRightInDec(K width => 4);

      PrintOutString ",  data: ";                                               # Position of data block
      $t->getLoop($K)->outRightInHex(K width => 4);

      PrintOutString ",  nodes: ";                                              # Position of nodes block
      $t->getLoop($D)->outRightInHex(K width => 4);

      PrintOutString ",  first: ";                                              # First block of tree
      $t->getLoop($N)->outRightInHex(K width => 4);

      my $U = $t->upFromData($D);                                               # Up field determines root / parent / leaf

      If $root == $offset,
      Then
       {PrintOutString ", root";                                                # Root
       },
      Else
       {PrintOutString ",  up: ";                                               # Up
        $U->outRightInHex(K width => 4);
       };

      If dFromZ($N, 0) == 0,                                                    # Leaf or parent
      Then
       {PrintOutString ", leaf";
       },
      Else
       {PrintOutString ", parent";
       };

      $t->getTreeBits($K, $transfer);
      Cmp $transfer, 0;
      IfGt
      Then                                                                      # Identify the data elements which are sub trees
       {PrintOutString ",  trees: ";
        V(bits => $transfer)->outRightInBin(K width => $t->maxKeys);
       };
      PrintOutNL;

      $I->copy($I + 2);                                                         # Indent sub tree

      $I->outSpaces; PrintOutString "Index:";                                   # Indices
      $l->for(sub
       {my ($index, $start, $next, $end) = @_;
        PrintOutString ' ';
        $index->outRightInDec(K width => 4);
       });
      PrintOutNL;

      my $printKD = sub                                                         # Print keys or data or nodes
       {my ($name, $zmm, $nodes, $tb) = @_;                                     # Key or data or node, zmm containing key or data or node, hex if true else decimal, print tree bits if tree
        $I->outSpaces; PrintOutString $name;                                    # Keys
        Mov $treeBitsIndexR, 1 if $tb;                                          # Check each tree bit position

        ($nodes ? $l + 1 : $l)->for(sub                                         # There is one more node than keys or data
         {my ($index, $start, $next, $end) = @_;
          my $i = $index * $t->width;                                           # Key or Data offset
          my $k = dFromZ $zmm, $i;                                              # Key or Data

          if (!$tb)                                                             # No tree bits
           {PrintOutString ' ';
            $k->outRightInHex(K width => 4);
            #$k->outRightInHex(K width => 4) if  $nodes;
            #$k->outRightInDec(K width => 4) if !$nodes;
           }
          else
           {Test $treeBitsR, $treeBitsIndexR;                                   # Check for a tree bit
            IfNz
            Then                                                                # This key indexes a sub tree
             {PushR 31;
              $t->area->getZmmBlock($k, 31);
              my $r = $t->rootFromFirst($F) >> K(sixteen => 4);
              PopR;
              $r->outRightInHex(K width => 4);                                  # Or use $k if we want the first block
              PrintOutString '*';
             },
            Else
             {PrintOutString ' ';
              $k->outRightInDec(K width => 4);
             };
           }
          Shl $treeBitsIndexR, 1 if $tb;                                        # Next tree bit position
         });
        PrintOutNL;
       };

      $printKD->('Keys :', $K, 0, 0);                                           # Print keys
      $printKD->('Data :', $D, 0, 1);                                           # Print data either as _hex for a sub tree reference or in decimal for data
      If dFromZ($N, 0) > 0,                                                     # If the first node is not zero we are not on a leaf
      Then
       {$printKD->('Nodes:', $N, 1, 0);
       };

      Cmp $treeBitsR, 0;                                                        # Any tree bit sets?
      IfNe
      Then                                                                      # Tree bits present
       {Mov $treeBitsIndexR, 1;                                                 # Check each tree bit position
        PushR my $F = 31;                                                       # Load first block of sub tree
        K(loop => $t->maxKeys)->for(sub
         {my ($index, $start, $next, $end) = @_;
          Test $treeBitsR, $treeBitsIndexR;                                     # Check for a tree bit
          IfNz
          Then                                                                  # This key indexes a sub tree
           {my $i = $index * $t->width;                                         # Key/data offset
            my $d = dFromZ($D, $i);                                             # Data
            my $I = V(indentation => 0)->copy($I + 2 + 1);                      # Indent by one extra space to show separate sub tree rather than continuation of the existing tree and to make the at address line up with the address in data.

            my      $T = $t->position($d);
                    $T->firstFromMemory($F);                                    # First block for tree
            my $r = $T->rootFromFirst($F);
            If $r == 0,                                                         # Empty tree
            Then
             {PrintOutStringNL "- empty";
             },
            Else
             {$sub->call(parameters => {indentation => $I, offset => $r},
                         structures => {tree        => $T});                    # Print sub tree referenced by data field
             };
           };
          Shl $treeBitsIndexR, 1;                                               # Next tree bit position
         });
        PopR;
       };

      If $l > 0,
      Then                                                                      # If the block only has one node it must be a leaf
       {($l+1)->for(sub                                                         # Print sub nodes
         {my ($index, $start, $next, $end) = @_;
          my $i = $index * $t->width;                                           # Key/Data offset
          my $d = dFromZ($N, $i);                                               # Sub nodes
          If $d > 0,                                                            # Print any sub nodes
          Then
           {my $I = V(indentation => 0)->copy($I + 2);
            $sub->call(parameters => {indentation => $I, offset=>$d},
                       structures => {tree        => $t});                      # Print sub tree referenced by data field
           };
         });
       };

      ($I - 2)->outSpaces; PrintOutStringNL "end";                              # Separate sub tree dumps

     };

    PopR;
   } parameters => [qw(indentation offset)],
     structures => {tree => $tree},
     name       => "Nasm::X86::Tree::dump";

  PrintOutStringNL $title;                                                      # Title of the piece so we do not lose it

  $tree->firstFromMemory($F);                                                   # First block for tree
  my $Q = $tree->rootFromFirst($F);

  If $Q == 0,                                                                   # Empty tree
  Then
   {PrintOutStringNL "- empty";
   },
  Else
   {$s->call(structures => {tree        => $tree},                              # Print root node
             parameters => {indentation => V(indentation => 0),
                            offset      => $Q});
   };

  PopR;
 }

sub Nasm::X86::Tree::printInOrder($$)                                           # Print a tree in order
 {my ($tree, $title) = @_;                                                      # Tree, title
  @_ == 2 or confess "Two parameters";

  PushR my $F = 31;

  my $s = Subroutine                                                            # Print a tree
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    my $t = $$s{tree};                                                          # Tree
    my $area = $t->area;                                                        # Area

    PushR my $treeBitsR = r10, my $treeBitsIndexR = r11,
          my $K = 30, my $D = 29, my $N = 28;

    Block                                                                       # Print each node in the tree
     {my ($end, $start) = @_;                                                   # Labels
      my $offset = $$p{offset};                                                 # Offset of node to print
      $t->getBlock($offset, $K, $D, $N);                                        # Load node
      my $l = $t->lengthFromKeys($K);                                           # Number of nodes
      $l->for(sub                                                               # Print sub nodes
       {my ($index, $start, $next, $end) = @_;
        my $i = $index * $t->width;                                             # Key/Data?node offset
        my $k = dFromZ $K, $i;                                                  # Key
        my $d = dFromZ $D, $i;                                                  # Data
        my $n = dFromZ $N, $i;                                                  # Sub nodes
        If $n > 0,                                                              # Not a leaf
        Then
         {$sub->call(parameters => {offset => $n},                              # Recurse
                     structures => {tree   => $t});
         };
        $k->outRightInHex(K width => 4);                                        # Print key
       });

      If $l > 0,                                                                # Print final sub tree
      Then
       {my $o = $l * $t->width;                                                 # Final sub tree offset
        my $n = dFromZ $N, $l * $t->width;                                      # Final sub tree
        If $n > 0,                                                              # Not a leaf
        Then
         {$sub->call(parameters => {offset => $n},
                     structures => {tree   => $t});

         };
       };
     };
    PopR;
   } parameters => [qw(offset)],
     structures => {tree => $tree},
     name       => "Nasm::X86::Tree::printInOrder";

  PrintOutString $title;                                                        # Title of the piece so we do not lose it

  $tree->firstFromMemory($F);
  my $R = $tree->rootFromFirst($F);
  my $C = $tree->sizeFromFirst($F);

  If $R == 0,                                                                   # Empty tree
  Then
   {PrintOutStringNL "- empty";
   },
  Else
   {$C->outRightInDec(K width => 4);
    PrintOutString ": ";

     $s->call(structures => {tree  => $tree},                                   # Print root node
             parameters => {offset => $R});
    PrintOutNL;
   };

  PopR;
 }

sub Nasm::X86::Tree::clear($)                                                   # Delete everything in the tree recording the memory so liberated to the free chain for reuse by other trees.
 {my ($tree) = @_;                                                              # Tree
  @_ == 1 or confess "One parameter";

  my $s = Subroutine                                                            # Delete all the sub blocks of a block and then free the block as well
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine definition

    my $t = $$s{tree};                                                          # Tree
    my $area = $t->area;                                                        # Area

    PushR my $K = 31, my $D = 30, my $N = 29;

    Block                                                                       # Free sub blocks then free block
     {my ($end, $start) = @_;

      $t->getBlock($$p{offset}, $K, $D, $N);                                    # Load block

      If $t->leafFromNodes($N) == 0,
      Then                                                                      # Not a leaf so free the sub blocks
       {my $l = $t->lengthFromKeys($K);                                         # Number of nodes
        ($l+1)->for(sub                                                         # Free sub blocks
         {my ($i) = @_;
          $sub->call(parameters => {offset => dFromZ $N, $i * $t->width},       # Recurse
                     structures => {tree   => $t});
         });
       };

      $t->freeBlock($$p{offset}, $K, $D, $N);                                   # Free this block
     };

    PopR;
   } parameters => [qw(offset)],
     structures => {tree => $tree},
     name       => "Nasm::X86::Tree::clear";

  PushR my $F = 31;
  $tree->firstFromMemory($F);
  my $root = $tree->rootFromFirst($F);                                          # Root block if any

  If $root > 0,                                                                 # Non empty tree
  Then
   {$s->call(structures => {tree  => $tree}, parameters => {offset => $root});  # Free from root node
    $tree->rootIntoFirst($F, K root => 0);
    $tree->sizeIntoFirst($F, K size => 0);
    $tree->firstIntoMemory($F);
   };

  PopR;
 }

sub Nasm::X86::Tree::free($)                                                    # Free all the memory used by a tree
 {my ($tree) = @_;                                                              # Tree
  @_ == 1 or confess "One parameter";
  $tree->clear;                                                                 # Clear the tree
 }

#D2 Iteration                                                                   # Iterate through a tree non recursively

sub Nasm::X86::Tree::by($&)                                                     # Call the specified block with each element of the specified tree in ascending order.
 {my ($tree, $block) = @_;                                                      # Tree descriptor, block to execute
  @_ == 2 or confess "Two parameters required";

  $tree->findFirst;                                                             # First element
  my $end   = Label;                                                            # End of processing
  my $next  = Label;                                                            # Next iteration
  my $start = SetLabel;                                                         # Start of this iteration
  If $tree->found == 0, Then {Jmp $end};
  &$block($tree, $start, $next, $end);                                          # Perform the specified block
  SetLabel $next;
  $tree->findNext($tree->key);
  Jmp $start;
  SetLabel $end;
 }

sub Nasm::X86::Tree::yb($&)                                                     # Call the specified block with each element of the specified tree in descending order.
 {my ($tree, $block) = @_;                                                      # Tree descriptor, block to execute
  @_ == 2 or confess "Two parameters required";

  $tree->findLast;                                                              # Last element
  my $end   = Label;                                                            # End of processing
  my $prev  = Label;                                                            # Next iteration
  my $start = SetLabel;                                                         # Start of this iteration
  If $tree->found == 0, Then {Jmp $end};
  &$block($tree, $start, $prev, $end);                                          # Perform the specified block
  SetLabel $prev;
  $tree->findPrev($tree->key);
  Jmp $start;
  SetLabel $end;
 }

#D2 Push and Pop                                                                # Use a tree as a stack: Push elements on to a tree with the next available key; Pop the last element in a tree.

sub Nasm::X86::Tree::push($$)                                                   #P Push a data value onto a tree. If the data is a reference to a tree then the offset of the first block of the tree is pushed.
 {my ($tree, $data) = @_;                                                       # Tree descriptor, variable data
  @_ == 2 or confess "Two parameters";

  $tree->findLast;                                                              # Last element
  If $tree->found == 0,
  Then                                                                          # Empty tree
   {$tree->put(K(key => 0), $data);                                             # First element in tree
   },
  Else                                                                          # Non empty tree
   {$tree->put($tree->key + 1, $data);                                          # Last element in tree
   };
 }

sub Nasm::X86::Tree::pop($)                                                     # Pop the last value out of a tree and return the key/data/subTree in the tree descriptor.
 {my ($tree) = @_;                                                              # Tree descriptor
  @_ == 1 or confess "One parameter";

  $tree->findLast;                                                              # Last element
  If $tree->found > 0,
  Then                                                                          # Empty tree
   {my $k = $tree->key    ->clone('key');
    my $d = $tree->data   ->clone('data');
    my $s = $tree->subTree->clone('subTree');
    $tree->delete($k);                                                          # Delete last key
    $tree->key    ->copy($k);                                                   # Retrieved key
    $tree->data   ->copy($d);                                                   # Retrieved data
    $tree->subTree->copy($s);                                                   # Retrieved sub tree indicator
    $tree->found  ->copy(1);                                                    # Indicate success
   };
 }

sub Nasm::X86::Tree::get($$)                                                    # Retrieves the element at the specified zero based index in the stack.
 {my ($tree, $key) = @_;                                                        # Tree descriptor, zero based index
  @_ == 2 or confess "Two parameters";
  $tree->find($key);
 }

#D2 Trees as Strings                                                            # Use trees as a strings. The characters of the string are stored as an array of characters.  The indices of the array run from 1 to the length of the string.

sub Nasm::X86::Tree::m($$$)                                                     # Append bytes in memory to a tree acting as a string. The address and size of the source memory are specified via variables.
 {my ($string, $address, $size) = @_;                                           # Tree descriptor of string to append to, variable address of memory to append from, variable size of memory
  @_ == 3 or confess "Three parameters";

  my $s = Subroutine
   {my ($parameters, $structures, $sub) = @_;
    PushR rax, 13, 14, 15;
    my $s = $$structures{string};
    $$parameters{address}->setReg(r13);
    $$parameters{size}   ->setReg(r14);
    ClearRegisters r15;
    For                                                                         # Clear memory
     {Mov al, "[r13+r15]";
      $s->push(V byte => rax);
     } r15, r14, 1;
    PopR;
   } structures=>{string=>$string},
     parameters=>[qw(address size)], name => 'Nasm::X86::Tree::m';

  $s->call(parameters=>{address => $address, size=>$size},
           structures=>{string=>$string});
 }

sub Nasm::X86::Tree::append($$)                                                 # Append the second source string to the first target string renumbering the keys of the source string to follow on from those of the target string.  A string can safely be appended to itself.
 {my ($string, $append) = @_;                                                   # Tree descriptor of string to append to, tree descriptor of string to append from
  @_ == 2 or confess "Two parameters";

  my $lt = $string->size;                                                       # Target string size
  my $ls = $append->size;                                                       # Source string size
  $ls->for(sub                                                                  # Look up each character
   {my ($i, $start, $next, $end) = @_;
    $string->get($i);
    $string->put($lt+$string->key, $string->data);
   });
  $string                                                                       # Chain from the target string
 }

sub Nasm::X86::Tree::clone($)                                                   # Clone a string.
 {my ($string) = @_;                                                            # Tree descriptor
  @_ == 1 or confess "One parameter";

  my $t = $string->area->CreateTree;                                            # Cloned copy
  $string->by(sub
   {$t->put($string->key, $string->data);
   });
  $t                                                                            # Chain from the target string
 }

sub Nasm::X86::Tree::substring($$$)                                             # Create the substring of the specified string between the specified start and end keys.
 {my ($string, $start, $finish) = @_;                                           # Tree descriptor of string to extract from, start key, end key
  @_ == 3 or confess "Three parameters";

  my $t = $string->area->CreateTree;                                            # Cloned copy
  If $start == $finish,
  Then                                                                          # Start and end are the same
   {$string->find($start);
    If $string->found > 0,
    Then
     {$t->put($string->key, $string->data);
     };
   },
  Ef {$start < $finish}
  Then                                                                          # Range of several keys
   {$string->find($finish);
    If $string->found > 0,
    Then                                                                        # Finish exists
     {$string->find($start);
      If $string->found > 0,
      Then                                                                      # Start exists
       {$string->size->for(sub                                                  # Each key in range
         {my ($i, $start, $next, $end) = @_;
          $t->put($string->key, $string->data);
          $string->findNext($string->key);
          If $string->key == $finish, Then {Jmp $end};                          # End of range
         });
       };
     };
   };
  $t                                                                            # Chain from the target string
 }

sub Nasm::X86::Tree::reverse($)                                                 # Create a clone of the sstring in reverse order
 {my ($string) = @_;                                                            # Tree descriptor of string
  @_ == 1 or confess "One parameter";

  my $t = $string->area->CreateTree;                                            # Cloned reversed copy
  my $l = $string->size;                                                        # Size of string
  $string->by(sub
   {$t->put($l - $string->key - 1, $string->data);
   });
  $t                                                                            # Chain from the target string
 }

#D3 Print                                                                       # Print tree as a string

sub Nasm::X86::Tree::outAsUtf8($)                                               # Print the data values of the specified string on stdout assuming each data value is a utf32 character and that the output device supports utf8
 {my ($string) = @_;                                                            # Tree descriptor of string
  @_ == 1 or confess "One parameter";

  $string->by(sub                                                               # Each character
   {my ($i, $start, $next, $end) = @_;
    PushR rax;
    $string->data->setReg(rax);
    convert_rax_from_utf32_to_utf8;
    PrintOutRaxAsText;
    PopR;
   });
  $string                                                                       # Chain from the target string
 }

sub Nasm::X86::Tree::outAsUtf8NL($)                                             # Print the data values of the specified string on stdout assuming each data value is a utf32 character and that the output device supports utf8. Follow the print with a new line character.
 {my ($string) = @_;                                                            # Tree descriptor of string
  @_ == 1 or confess "One parameter";
  $string->outAsUtf8;
  PrintOutNL;
  $string                                                                       # Chain from the target string
 }

#D3 Trees of strings                                                            # Trees of strings assign a unique number to a string so that given a string we can produce a unique number representing the string.  The inverse operations is much easier as we just have to look up a string by number in a tree.

sub Nasm::X86::Tree::putString($$)                                              # The last element of the string is the value, the preceding elements are the keys so such a string must have at least two elements. We create a string tree to index strings to values
 {my ($tree, $string) = @_;                                                     # Tree descriptor representing string tree, tree representing a string to be inserted into the string tree.
  @_ == 2 or confess "Two parameters";

  my $size = $string->size;                                                     # Tree size
  If $size > 1,                                                                 # Tree must be two or more
  Then
   {my $size1 = $size - 1;
    my $S = $tree->copyDescription;                                             # Create a new descriptor for the string tree
    my $s = V state => 1;                                                       # 1 - string found so far, 0 - inserting new string
    my $z = V count => 0;                                                       # Count of elements so that we can find the last element to be inserted
    my $l = V last  => 0;                                                       # Last key

    $string->by(sub                                                             # Insert latest tree
     {my ($t) = @_;
      $z->copy($z + 1);
      If $z < $size1,                                                           # First elements are keys
      Then
       {If $s == 1,
        Then
         {$S->find($t->data);
          If $S->found == 0,
          Then                                                                  # Position on new element
           {$s->copy(0);
            my $T = $t->area->CreateTree;
            $S->put($t->data, $T);
            $S->first->copy($T->first);
           },
          Else
           {$S->first->copy($S->data);                                          # Position on found element
           };
         },
        Else
         {my $T = $t->area->CreateTree;
          $S->put($t->data, $T);
          $S->first->copy($T->first);
         };
       },
      Ef {$z == $size1}                                                         # Last key
      Then
       {$l->copy($t->data);
       },
      Else
       {$S->put($l, $t->data);
       };
     });
   };
 }

sub Nasm::X86::Tree::getString($$)                                              # Locate the tree in a string tree representing the specified string and return its data in B<found> and B<data>.
 {my ($tree, $string) = @_;                                                     # Tree descriptor representing string tree, tree representing a string to be inserted into the string tree.
  @_ == 2 or confess "Two parameters";

  my $success = Label;
  my $S = $tree->copyDescription;                                               # Create a new descriptor for the string tree
  $tree->found->copy(1);                                                        # Assume we will find the string
  my $s = $tree->size;
  $string->by(sub                                                               # Insert latest tree
   {my ($t) = @_;
    $S->find($t->key);
    If $S->found == 0,
    Then
     {$tree->found->copy(0);
      Jmp $success
     };
    $S->position($s->first);
   });
  SetLabel $success;

  $tree                                                                         # Chain - the reskt
 }

#D3 Trees as sets                                                               # Trees of trees as sets

sub Nasm::X86::Tree::union($)                                                   # Given a tree of trees consider each sub tree as a set and form the union of all these sets as a new tree
 {my ($tree) = @_;                                                              # Tree descriptor for a tree of trees
  @_ == 1 or confess "One parameter";

  my $u = $tree->area->CreateTree;
  $tree->by(sub                                                                 # Each sub tree
   {my ($T) = @_;
    my $t = $tree->position($T->data);
    $t->by(sub                                                                  # Insert each element of each sub tree
     {my ($s) = @_;
      $u->put($s->key, $s->data);
     });
   });
  $u                                                                            # Union
 }

sub Nasm::X86::Tree::intersection($)                                            # Given a tree of trees consider each sub tree as a set and form the intersection of all these sets as a new tree
 {my ($tree) = @_;                                                              # Tree descriptor for a tree of trees
  @_ == 1 or confess "One parameter";

  my $i = $tree->area->CreateTree;                                              # Resulting intersection
  my $F = V smallest => -1;
  my $S = V size     => -1;

  $tree->by(sub                                                                 # Find smallest sub tree
   {my ($T, $start, $next) = @_;
    my $f = $T->data;
    my $t = $tree->position($f);
    my $s = $t->size;
    OrBlock                                                                     # Update size if no size seen yet or if the size is smaller
     {my ($pass) = @_;
      If $S == -1, Then {Jmp $pass};                                            # No size set yet
      If $S > $s,  Then {Jmp $pass};                                            # Smaller size
     }                                                                          # Do not attempt to put a comma here!
    Then                                                                        # Smallest so far
     {$S->copy($s);
      $F->copy($f);
     };
   });

  If $S > 0,                                                                    # The smallest set is not empty set so the intersection might not be empty either
  Then
   {$tree->findFirst;
    my $f = $tree->position($F);                                                # First tree (but the smallest sub tree would be better)

    $f->by(sub                                                                  # Insert each element of each sub tree
     {my ($t, undef, $nextElement) = @_;
      my $k = $t->key;

      $tree->by(sub                                                             # Each sub tree
       {my ($T, undef, $nextTree) = @_;
        If $F == $T->data, Then {Jmp $nextTree};                                # Skip the first tree

        my $t = $tree->position($T->data);
        $t->find($k);
        If $t->found == 0, Then {Jmp $nextElement};                             # Not found in this sub tree so it cannot be part of the intersection
       });
      $i->put($k, $k);
     });
   };

  $i                                                                            # Intersection
 }

sub Nasm::X86::Tree::intersection2($)                                           # Given a tree of trees consider each sub tree as a set and form the intersection of all these sets as a new tree
 {my ($tree) = @_;                                                              # Tree descriptor for a tree of trees
  @_ == 1 or confess "One parameter";

  my $i = $tree->area->CreateTree;                                              # Resulting intersection
  $tree->findFirst;
  my $F = $tree->data->clone("first");
  my $f = $tree->position($F);                                                  # First tree (but the smallest sub tree would be better)

  $f->by(sub                                                                    # Insert each element of each sub tree
   {my ($t, undef, $nextElement) = @_;
    my $k = $t->key;

    $tree->by(sub                                                               # Each sub tree
     {my ($T, undef, $nextTree) = @_;
      If $F == $T->data, Then {Jmp $nextTree};                                  # Skip the first tree

      my $t = $tree->position($T->data);
      $t->find($k);
      If $t->found == 0, Then {Jmp $nextElement};                               # Not found in this sub tree so it cannot be part of the intersection
     });
    $i->put($k, $k);
   });

  $i                                                                            # Intersection
 }

#D1 Assemble                                                                    # Assemble generated code

sub CallC($@)                                                                   # Call a C subroutine.
 {my ($sub, @parameters) = @_;                                                  # Name of the sub to call, parameters
  my @order = (rdi, rsi, rdx, rcx, r8, r9, r15);
  PushR @order;

  for my $i(keys @parameters)                                                   # Load parameters into designated registers
   {Mov $order[$i], $parameters[$i];
   }

  Push rax;                                                                     # Align stack on 16 bytes
  Mov rax, rsp;                                                                 # Move stack pointer
  Shl rax, 60;                                                                  # Get lowest nibble
  Shr rax, 60;
  IfEq                                                                          # If we are 16 byte aligned push two twos
  Then
   {Mov rax, 2; Push rax; Push rax;
   },
  Else                                                                          # If we are not 16 byte aligned push one one.
   {Mov rax, 1; Push rax;
   };

  if (ref($sub))                                                                # Where do we use this option?
   {Call $sub->start;
   }
  else                                                                          # Call named subroutine
   {Call $sub;
   }

  Pop r15;                                                                      # Decode and reset stack after 16 byte alignment
  Cmp r15, 2;                                                                   # Check for double push
  Pop r15;                                                                      # Single or double push
  IfEq Then {Pop r15};                                                          # Double push
  PopR @order;
 }

sub Extern(@)                                                                   # Name external references.
 {my (@externalReferences) = @_;                                                # External references
  push @extern, @_;
 }

sub Link(@)                                                                     # Libraries to link with.
 {my (@libraries) = @_;                                                         # External references
  push @link, @_;
 }

sub Start()                                                                     # Initialize the assembler.
 {@bss = @data = @rodata = %rodata = %rodatas = %subroutines = @text =
  @PushR = @extern = @link = @VariableStack = ();
# @RegistersAvailable = ({map {$_=>1} @GeneralPurposeRegisters});               # A stack of hashes of registers that are currently free and this can be used without pushing and popping them.
  SubroutineStartStack;                                                         # Number of variables at each lexical level
  $Labels = 0;
 }

sub Exit(;$)                                                                    # Exit with the specified return code or zero if no return code supplied.  Assemble() automatically adds a call to Exit(0) if the last operation in the program is not a call to Exit.
 {my ($c) = @_;                                                                 # Return code
  $c //= 0;
  my $s = Subroutine
   {Comment "Exit code: $c";
    PushR rax, rdi;
    Mov rdi, $c;
    Mov rax, 60;
    Syscall;
    PopR;
   } name => "Exit_$c";

  $s->call;
 }

my $LocateIntelEmulator;                                                        # Location of Intel Software Development Emulator

sub LocateIntelEmulator()                                                       #P Locate the Intel Software Development Emulator.
 {my @locations = qw(/var/isde/sde64 sde/sde64 ./sde64);                        # Locations at which we might find the emulator
  my $downloads = q(/home/phil/Downloads);                                      # Downloads folder

  return $LocateIntelEmulator if defined $LocateIntelEmulator;                  # Location has already been discovered

  for my $l(@locations)                                                         # Try each locations
   {return $LocateIntelEmulator = $l if -e $l;                                  # Found it - cache and return
   }

  if (qx(sde64 -version) =~ m(Intel.R. Software Development Emulator))          # Try path
   {return $LocateIntelEmulator = "sde64";
   }

  return undef unless -e $downloads;                                            # Skip local install if not developing
  my $install = <<END =~ s(\n) (  && )gsr =~ s(&&\s*\Z) ()sr;                   # Install sde
cd $downloads
curl https://software.intel.com/content/dam/develop/external/us/en/documents/downloads/sde-external-8.63.0-2021-01-18-lin.tar.bz2 > sde.tar.bz2
tar -xf sde.tar.bz2
sudo mkdir -p /var/isde/
sudo cp -r * /var/isde/
ls -ls /var/isde/
END

  say STDERR qx($install);                                                      # Execute install

  for my $l(@locations)                                                         # Retry install locations after install
   {return $LocateIntelEmulator = $l if -e $l;                                  # Found it - cache and return
   }
  undef                                                                         # Still not found - give up
 }

sub getInstructionCount()                                                       #P Get the number of instructions executed from the emulator mix file.
 {return 0 unless -e $sdeMixOut;
  my $s = readFile $sdeMixOut;
  if ($s =~ m(\*total\s*(\d+))) {return $1}
  confess;
 }

sub Optimize(%)                                                                 #P Perform code optimizations.
 {my (%options) = @_;                                                           # Options
  my %o = map {$_=>1} $options{optimize}->@*;
  if (1 or $o{if})                                                              # Optimize if statements by looking for the unnecessary reload of the just stored result
   {for my $i(1..@text-2)                                                       # Each line
     {my $t = $text[$i];
      if ($t =~ m(\A\s+push\s+(r\d+)\s*\Z)i)                                    # Push
       {my $R = $1;                                                             # Register being pushed
        my $s = $text[$i-1];                                                    # Previous line
        if ($s =~ m(\A\s+pop\s+$R\s*\Z)i)                                       # Matching push
         {my $r = $text[$i-2];
          if ($r =~ m(\A\s+mov\s+\[rbp-8\*\((\d+)\)],\s*$R\s*\Z)i)              # Save to variable
           {my $n = $1;                                                         # Variable number
            my $u = $text[$i+1];
            if ($u =~ m(\A\s+mov\s+$R,\s*\[rbp-8\*\($n\)]\s*\Z)i)               # Reload register
             {for my $j($i-1..$i+1)
               {$text[$j] = '; out '. $text[$j];
               }
             }
           }
         }
       }
     }
   }
 }

my $hasAvx512;

sub hasAvx512()                                                                 #P Check whether the current device has avx512 instructions or not
 {return $hasAvx512 if defined $hasAvx512;
  $hasAvx512 = qx(cat /proc/cpuinfo | grep avx512) =~ m(\S) ? 1 : 0;            # Cache avx512 result
 }

our $assembliesPerformed  = 0;                                                  # Number of assemblies performed
our $instructionsExecuted = 0;                                                  # Total number of instructions executed
our $totalBytesAssembled  = 0;                                                  # Total size of the output programs

sub Assemble(%)                                                                 # Assemble the generated code.
 {my (%options) = @_;                                                           # Options
  my $aStart = time;
  my $library    = $options{library};                                           # Create  the named library if supplied from the supplied assembler code
  my $debug      = $options{debug}//0;                                          # Debug: 0 - none (minimal output), 1 - normal (debug output and confess of failure), 2 - failures (debug output and no confess on failure) .
  my $debugTrace = $options{trace}//0;                                          # Trace: 0 - none (minimal output), 1 - trace with sde64
  my $keep       = $options{keep};                                              # Keep the executable

  my $sourceFile = q(z.asm);                                                    # Source file
  my $execFile   = $keep // q(z);                                               # Executable file
  my $listFile   = q(z.txt);                                                    # Assembler listing
  my $objectFile = $library // q(z.o);                                          # Object file
  my $o1         = 'zzzOut.txt';                                                # Stdout from run
  my $o2         = 'zzzErr.txt';                                                # Stderr from run

  my $onGitHub = $ENV{GITHUB_REPOSITORY_OWNER};                                 # Whether we are on GitHub or not

  @PushR and confess "Mismatch PushR, PopR";                                    # Match PushR with PopR


  unlink $o1, $o2, $objectFile, $execFile, $listFile, $sourceFile;              # Remove output files

  Exit 0 unless $library or @text > 4 && $text[-4] =~ m(Exit code:);            # Exit with code 0 if an exit was not the last thing coded in a program but ignore for a library.

# Optimize(%options);                                                           # Perform any optimizations requested

  if (1)                                                                        # Concatenate source code
   {my $r = join "\n", map {s/\s+\Z//sr}   @rodata;
    my $d = join "\n", map {s/\s+\Z//sr}   @data;
    my $B = join "\n", map {s/\s+\Z//sr}   @bss;
    my $t = join "\n", map {s/\s+\Z//sr}   @text;
    my $x = join "\n", map {qq(extern $_)} @extern;
    my $N = $VariableStack[0];                                                  # Number of variables needed on the stack

    my $A = <<END;                                                              # Source code
bits 64
default rel
END

    $A .= <<END if $t and !$library;
global _start, main
  _start:
  main:
  Enter $N*8, 0
  $t
  Leave
END

    $A .= <<END if $t and $library;
  $t
END

    $A .= <<END if $r;
section .rodata
  $r
END
    $A .= <<END if $d;
section .data
  $d
END
    $A .= <<END if $B;
section .bss
  $B
  $d
END
    $A .= <<END if $x;
section .text
$x
END

    owf($sourceFile, $A);                                                       # Save source code to source file
   }

  if (!confirmHasCommandLineCommand(q(nasm)))                                   # Check for network assembler
   {my $f = fpf(currentDirectory, $sourceFile);
    say STDERR <<END;
Assember code written to the following file:

$f

I cannot compile this file because you do not have Nasm installed, see:

https://www.nasm.us/
END
    return;
   }

  my $avx512 = hasAvx512 ? 0 : exists $options{avx512} ? $options{avx512} : 1;  # Emulate if necessary
  my $sde      = LocateIntelEmulator;                                           # Locate the emulator
  my $run      = !$keep && !$library;                                           # Are we actually going to run the resulting code?

  if ($run and $avx512 and !$sde)                                               # Complain about the emulator if we are going to run and we have not suppressed the emulator and the emulator is not present
   {my $f = fpf(currentDirectory, $execFile);
    say STDERR <<END;
Executable written to the following file:

$f

I am going to run this without using the Intel emulator. Your program will
crash if it contains instructions not implemented on your computer.

You can get the Intel emulator from:

https://software.intel.com/content/dam/develop/external/us/en/documents/downloads/sde-external-8.63.0-2021-01-18-lin.tar.bz2

To avoid this message, use option(1) below to produce just an executable
without running it, or use the option(2) to run without the emulator:

(1) Assemble(keep=>"executable file name")

(2) Assemble(avx512=>0)
END
    $avx512 = 0;
   }

  if (my @emulatorFiles = searchDirectoryTreesForMatchingFiles(qw(. .txt)))     # Remove prior emulator output files
   {for my $f(@emulatorFiles)
     {unlink $f if $f =~ m(sde-mix-out);
     }
   }
  unlink qw(sde-ptr-check.out.txt sde-mix-out.txt sde-debugtrace-out.txt);

  if (1)                                                                        # Assemble
   {my $I = @link ? $interpreter : '';                                          # Interpreter only required if calling C
    my $L = join " ",  map {qq(-l$_)} @link;                                    # List of libraries to link supplied via Link directive.
    my $e = $execFile;
    my $a = qq(nasm -O0 -l $listFile -o $objectFile $sourceFile);               # Assembly options

    my $cmd  = $library
      ? qq($a -fbin)
      : qq($a -felf64 -g && ld $I $L -o $e $objectFile && chmod 744 $e);

#   say STDERR $cmd;
    qx($cmd);
    confess "Assembly failed $?" if $?;                                         # Stop if assembly failed
   }

  my $aTime = time - $aStart;

  my $out  = $run ? "1>$o1" : '';
  my $err  = $run ? "2>$o2" : '';

  my $exec = sub                                                                # Execution string
   {my $o = qq($sde -mix -ptr-check);                                           # Emulator options
       $o = qq($sde -mix -ptr-check -debugtrace -footprint) if $debugTrace;     # Emulator options - tracing
    my $e = $execFile;
    my $E = $options{emulator};                                                 # Emulator required
    return qq($o -- ./$e $err $out) if $E or $avx512 && !hasAvx512;             # Command to execute program via the  emulator
    qq(./$e $err $out);                                                         # Command to execute program without the emulator
   }->();

  my $eStart = time;
  #say STDERR $exec;
  qx($exec) if $run;                                                            # Run unless suppressed by user or library
  my $er     = $?;                                                              # Execution result
  my $eTime  = time - $eStart;

  if (1)                                                                        # Execution details
   {my $instructions       = getInstructionCount;                               # Instructions executed under emulator
    $instructionsExecuted += $instructions;                                     # Count instructions executed
    my $p = $assembliesPerformed++;                                             # Count assemblies
    my $n = $options{number};
    !$n or $n == $p or warn "Assembly $p versus number => $n";

    my $bytes = (fileSize($execFile)//9448) - 9448;                             # Estimate the size of the output program
    $totalBytesAssembled += $bytes;                                             # Estimate total of all programs assembled

    my (undef, $file, $line) = caller();                                        # Line in caller

    say STDERR sprintf("        %12s    %12s    %12s    %12s  %12s  %12s",      # Header if necessary
       "Clocks", "Bytes", "Total Clocks", "Total Bytes", "Run Time", "Assembler")
      if $assembliesPerformed % 100 == 1;

    say STDERR                                                                  # Rows
      sprintf("%4d    %12s    %12s    %12s    %12s  %12.6f  %12.2f  at $file line $line",
      $assembliesPerformed,
      (map {numberWithCommas $_} $instructions,         $bytes,
                                 $instructionsExecuted, $totalBytesAssembled),
                                 $eTime, $aTime);
   }

  if ($run and $debug == 0 and -e $o2)                                          # Print errors if not debugging
   {say STDERR readBinaryFile($o2);
   }

  if ($run and $debug == 1)                                                     # Print files if soft debugging or error
   {say STDERR readFile($o1) if -e $o1;
    say STDERR readFile($o2) if -e $o2;
   }

  if ($run and $debug < 2 and -e $o2 and readFile($o2) =~ m(SDE ERROR:)s)       # Emulator detected an error
   {confess "SDE ERROR\n".readFile($o2);
   }

  confess "Failed $er" if $debug < 2 and $er;                                   # Check that the run succeeded

  unlink $objectFile unless $library;                                           # Delete files
  unlink $execFile   unless $keep;                                              # Delete executable unless asked to keep it or its a library

  if (my $N = $options{countComments})                                          # Count the comments so we can see what code to put into subroutines
   {my %c; my %b;                                                               # The number of lines between the comments, the number of blocks
    my $s;
    for my $c(readFile $sourceFile)
     {if (!$s)
       {if ($c =~ m(;\s+CommentWithTraceBack\s+PushR))
         {$s = $c =~ s(Push) (Pop)r;
          $b{$s}++;
         }
       }
      elsif ($c eq $s)  {$s = undef}
      else              {$c{$s}++}
     }

    my @c;
    for my $c(keys %c)                                                          # Remove comments that do not appear often
     {push @c, [$c{$c}, $b{$c}, $c] if $c{$c} >= $N;
     }
    my @d = sort {$$b[0] <=> $$a[0]} @c;
    say STDERR formatTable(\@d, [qw(Lines Blocks Comment)]);                    # Print frequently appearing comments
   }

  Start;                                                                        # Clear work areas for next assembly

  if ($run and defined(my $e = $options{eq}))                                   # Diff results against expected
   {my $g = readFile($debug < 2 ? $o1 : $o2);
       $e =~ s(\s+#.*?\n) (\n)gs;                                               # Remove comments so we can annotate listings
    s(Subroutine trace back.*) ()s for $e, $g;                                  # Remove any trace back because the location of the subroutine in memory will vary
    if ($g ne $e)
     {my ($s, $G, $E) = stringsAreNotEqual($g, $e);
      if (length($s))
       {my $line = 1 + length($s =~ s([^\n])  ()gsr);
        my $char = 1 + length($s =~ s(\A.*\n) ()sr);
        say STDERR "Comparing wanted with got failed at line: $line, character: $char";
        say STDERR "Start:\n$s";
       }
      my $b1 = '+' x 80;
      my $b2 = '_' x 80;
      say STDERR "Want $b1\n", firstNChars($E, 80);
      say STDERR "Got  $b2\n", firstNChars($G, 80);
      say STDERR "Want: ", dump($e);
      say STDERR "Got : ", dump($g);
      confess "Test failed" unless $ENV{GITHUB_REPOSITORY_OWNER};               # Test failed unless we are debugging test failures
     }
    return 1;                                                                   # Test passed
   }

  return scalar(readFile($debug < 2 ? $o1 : $o2)) if $run;                      # Show stdout results unless stderr results requested
  $exec;                                                                        # Retained output
 }

sub removeNonAsciiChars($)                                                      #P Return a copy of the specified string with all the non ascii characters removed.
 {my ($string) = @_;                                                            # String
  $string =~ s([^a-z0..9]) ()igsr;                                              # Remove non ascii characters
 }

sub totalBytesAssembled                                                         #P Total size in bytes of all files assembled during testing.
 {$totalBytesAssembled
 }

sub CreateLibrary(%)                                                            # Create a library.
 {my (%library) = @_;                                                           # Library definition

  my @s = sort keys $library{subroutines}->%*;                                  # The names of the subroutines in the library

  my %s = map                                                                   # The library is initialized by calling it - the library loads the addresses of its subroutines onto the stack for easy retrieval by the caller.
   {my $l = Label;                                                              # Start label for subroutine
    my  $o = "qword[rsp-".(($_+1) * RegisterSize rax)."]";                      # Position of subroutine on stack
    Mov $o, $l.'-$$';                                                           # Put offset of subroutine on stack
    Add $o, r15;                                                                # The library must be called via r15 to convert the offset to the address of each subroutine

    $s[$_] => genHash("NasmX86::Library::Subroutine",                           # Subroutine definitions
      number  => $_ + 1,                                                        # Number of subroutine from 1
      label   => $l,                                                            # Label of subroutine
      name    => $s[$_],                                                        # Name of subroutine
      code    => $library{subroutines}{$s[$_]},                                 # Perl subroutine to write code of assembler subroutine
      call    => undef,                                                         # Perl subroutine to call assembler subroutine
   )} keys @s;

  Ret;                                                                          # Return from library initialization

  for my $s(@s{@s})                                                             # Generate code for each subroutine in the library
   {Align 16;
    SetLabel $s->label;                                                         # Start label
    $s->code->();                                                               # Code of subroutine
    Ret;                                                                        # Return from subroutine
   }

  unlink my $l = $library{file};                                                # The name of the file containing the library

  Assemble library => $l;                                                       # Create the library file

  $library{locations} = \%s;                                                    # Location of each subroutine on the stack

  genHash "NasmX86::Library", %library
 }

sub NasmX86::Library::load($)                                                   # Load a library and return the addresses of its subroutines as variables.
 {my ($library) = @_;                                                           # Description of library to load
  my ($address, $size) = ReadFile $$library{file};                              # Read library file into memory
  $address->call(r15);                                                          # Load addresses of subroutines onto stack

  my @s = sort keys $$library{subroutines}->%*;                                 # The names of the subroutines in the library

  my %s = $$library{locations}->%*;                                             # Subroutines in library
  for my $s(@s{@s})                                                             # Copy the address of each subroutine from the stack taking care not to disturb the stack beyond the stack pointer.
   {Mov r15, "[rsp-".(($s->number + 1) * RegisterSize rax)."]";                 # Address of subroutine in this process
    $s->call = V $s->name => r15;                                               # Address of subroutine in this process from stack as a variable
   }

  $$library{address} = $address;                                                # Save address and size of library
  $$library{size}    = $size;

  map {my $c = $_->call; sub {$c->call}} @s{@s};                                # Call subroutine via variable - perl bug because $_ by  itself is not enough
 }

#d
#-------------------------------------------------------------------------------
# Export - eeee
#-------------------------------------------------------------------------------
if (0)                                                                          # Print exports
 {my @e = (@declarations);
  for my $a(readFile $0)
   {next unless $a =~ m(\Asub);
    next if     $a =~ m(#P);
    if ($a =~ m(\s+(.*?)\())
     {push @e, $1;
     }
   }
  say STDERR q/@EXPORT_OK    = qw(/.join(' ', sort @e).q/);/;
  exit;
 }

use Exporter qw(import);

use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);

@ISA          = qw(Exporter);
@EXPORT       = qw();
@EXPORT_OK    = qw(Add Align All8Structure AllocateMemory And AndBlock Andn Assemble Block Bswap Bt Btc Btr Bts Bzhi Call CallC CheckIfMaskRegisterNumber CheckIfMaskRegisterNumber CheckMaskRegister CheckMaskRegisterNumber CheckMaskRegisterNumber ChooseRegisters ClassifyInRange ClassifyWithInRange ClassifyWithInRangeAndSaveOffset ClassifyWithInRangeAndSaveWordOffset ClearMemory ClearRegisters ClearRegisters ClearZF CloseFile Cmova Cmovae Cmovb Cmovbe Cmovc Cmove Cmovg Cmovge Cmovl Cmovle Cmovna Cmovnae Cmovnb Cmp Comment Comment CommentWithTraceBack ConvertUtf8ToUtf32 CopyMemory Cpuid CreateArea CreateLibrary DComment DComment Db Dd Dec DescribeArea Div Dq Ds Dw Ef Else Enter Exit Extern Fail For ForEver ForIn Fork FreeMemory GetNextUtf8CharAsUtf32 GetPPid GetPid GetPidInHex GetUid Hash Idiv If IfC IfEq IfGe IfGt IfLe IfLt IfNc IfNe IfNs IfNz IfS IfZ Imul Imul3 Inc InsertOneIntoRegisterAtPoint InsertZeroIntoRegisterAtPoint Ja Jae Jb Jbe Jc Jcxz Je Jecxz Jg Jge Jl Jle Jmp Jna Jnae Jnb Jnbe Jnc Jne Jng Jnge Jnl Jnle Jno Jnp Jns Jnz Jo Jp Jpe Jpo Jrcxz Js Jz K Kaddb Kaddd Kaddq Kaddw Kandb Kandd Kandnb Kandnd Kandnq Kandnw Kandq Kandw Kmovb Kmovd Kmovq Kmovw Knotb Knotd Knotq Knotw Korb Kord Korq Kortestb Kortestd Kortestq Kortestw Korw Kshiftlb Kshiftld Kshiftlq Kshiftlw Kshiftrb Kshiftrd Kshiftrq Kshiftrw Ktestb Ktestd Ktestq Ktestw Kunpckb Kunpckd Kunpckq Kunpckw Kxnorb Kxnord Kxnorq Kxnorw Kxorb Kxord Kxorq Kxorw Lahf Lea Leave Link LoadBitsIntoMaskRegister LoadConstantIntoMaskRegister LoadRegFromMm LoadZmm Loop Lzcnt Mov Movd Movdqa Mulpd Nasm::X86::Area::CreateTree Nasm::X86::Area::allocZmmBlock Nasm::X86::Area::allocate Nasm::X86::Area::append Nasm::X86::Area::char Nasm::X86::Area::clear Nasm::X86::Area::dump Nasm::X86::Area::free Nasm::X86::Area::freeChainSpace Nasm::X86::Area::m Nasm::X86::Area::makeReadOnly Nasm::X86::Area::makeWriteable Nasm::X86::Area::nl Nasm::X86::Area::out Nasm::X86::Area::outNL Nasm::X86::Area::q Nasm::X86::Area::ql Nasm::X86::Area::read Nasm::X86::Area::size Nasm::X86::Area::used Nasm::X86::Area::write Nasm::X86::Area::z Nasm::X86::Structure::field Nasm::X86::StructureField::addr Nasm::X86::Sub::V Nasm::X86::Sub::call Nasm::X86::Sub::dispatch Nasm::X86::Sub::dispatchV Nasm::X86::Sub::via Nasm::X86::Subroutine::mapStructureVariables Nasm::X86::Subroutine::uploadStructureVariablesToNewStackFrame Nasm::X86::Tree::append Nasm::X86::Tree::by Nasm::X86::Tree::clear Nasm::X86::Tree::clone Nasm::X86::Tree::delete Nasm::X86::Tree::depth Nasm::X86::Tree::dump Nasm::X86::Tree::find Nasm::X86::Tree::findFirst Nasm::X86::Tree::findLast Nasm::X86::Tree::findNext Nasm::X86::Tree::findPrev Nasm::X86::Tree::findShortString Nasm::X86::Tree::free Nasm::X86::Tree::get Nasm::X86::Tree::insertShortString Nasm::X86::Tree::outAsUtf8 Nasm::X86::Tree::outAsUtf8NL Nasm::X86::Tree::pop Nasm::X86::Tree::printInOrder Nasm::X86::Tree::put Nasm::X86::Tree::reverse Nasm::X86::Tree::size Nasm::X86::Tree::substring Nasm::X86::Tree::yb Nasm::X86::Variable::add Nasm::X86::Variable::address Nasm::X86::Variable::allocateMemory Nasm::X86::Variable::and Nasm::X86::Variable::arithmetic Nasm::X86::Variable::assign Nasm::X86::Variable::bFromZ Nasm::X86::Variable::bIntoX Nasm::X86::Variable::bIntoZ Nasm::X86::Variable::boolean Nasm::X86::Variable::booleanC Nasm::X86::Variable::booleanZF Nasm::X86::Variable::call Nasm::X86::Variable::clearBit Nasm::X86::Variable::clearMaskBit Nasm::X86::Variable::clearMemory Nasm::X86::Variable::clone Nasm::X86::Variable::copy Nasm::X86::Variable::copyMemory Nasm::X86::Variable::copyRef Nasm::X86::Variable::copyZF Nasm::X86::Variable::copyZFInverted Nasm::X86::Variable::d Nasm::X86::Variable::dFromPointInZ Nasm::X86::Variable::dFromZ Nasm::X86::Variable::dIntoPointInZ Nasm::X86::Variable::dIntoX Nasm::X86::Variable::dIntoZ Nasm::X86::Variable::debug Nasm::X86::Variable::dec Nasm::X86::Variable::divide Nasm::X86::Variable::division Nasm::X86::Variable::eq Nasm::X86::Variable::equals Nasm::X86::Variable::err Nasm::X86::Variable::errCString Nasm::X86::Variable::errCStringNL Nasm::X86::Variable::errInDec Nasm::X86::Variable::errInDecNL Nasm::X86::Variable::errNL Nasm::X86::Variable::errRightInBin Nasm::X86::Variable::errRightInBinNL Nasm::X86::Variable::errRightInDec Nasm::X86::Variable::errRightInDecNL Nasm::X86::Variable::errRightInHex Nasm::X86::Variable::errRightInHexNL Nasm::X86::Variable::errSpaces Nasm::X86::Variable::for Nasm::X86::Variable::freeMemory Nasm::X86::Variable::ge Nasm::X86::Variable::getConst Nasm::X86::Variable::getReg Nasm::X86::Variable::gt Nasm::X86::Variable::inc Nasm::X86::Variable::incDec Nasm::X86::Variable::isRef Nasm::X86::Variable::le Nasm::X86::Variable::loadZmm Nasm::X86::Variable::lt Nasm::X86::Variable::max Nasm::X86::Variable::min Nasm::X86::Variable::minusAssign Nasm::X86::Variable::mod Nasm::X86::Variable::ne Nasm::X86::Variable::not Nasm::X86::Variable::or Nasm::X86::Variable::out Nasm::X86::Variable::outCString Nasm::X86::Variable::outCStringNL Nasm::X86::Variable::outInDec Nasm::X86::Variable::outInDecNL Nasm::X86::Variable::outNL Nasm::X86::Variable::outRightInBin Nasm::X86::Variable::outRightInBinNL Nasm::X86::Variable::outRightInDec Nasm::X86::Variable::outRightInDecNL Nasm::X86::Variable::outRightInHex Nasm::X86::Variable::outRightInHexNL Nasm::X86::Variable::outSpaces Nasm::X86::Variable::plusAssign Nasm::X86::Variable::printErrMemoryInHexNL Nasm::X86::Variable::printMemoryInHexNL Nasm::X86::Variable::printOutMemoryInHexNL Nasm::X86::Variable::putBwdqIntoMm Nasm::X86::Variable::putWIntoZmm Nasm::X86::Variable::qFromZ Nasm::X86::Variable::qIntoX Nasm::X86::Variable::qIntoZ Nasm::X86::Variable::rightInBin Nasm::X86::Variable::rightInDec Nasm::X86::Variable::rightInHex Nasm::X86::Variable::setBit Nasm::X86::Variable::setMask Nasm::X86::Variable::setMaskBit Nasm::X86::Variable::setMaskFirst Nasm::X86::Variable::setReg Nasm::X86::Variable::setZmm Nasm::X86::Variable::shiftLeft Nasm::X86::Variable::shiftRight Nasm::X86::Variable::spaces Nasm::X86::Variable::str Nasm::X86::Variable::sub Nasm::X86::Variable::times Nasm::X86::Variable::wFromZ Nasm::X86::Variable::wIntoX NasmX86::Library::load Neg Not OnSegv OpenRead OpenWrite Or OrBlock Pass Pextrb Pextrd Pextrq Pextrw Pinsrb Pinsrd Pinsrq Pinsrw Pop PopR PopR PopRR Popcnt Popfq PrintCString PrintCStringNL PrintErrNL PrintErrOneRegisterInHex PrintErrOneRegisterInHexNL PrintErrRaxInHex PrintErrRaxInHexNL PrintErrRaxRightInDec PrintErrRaxRightInDecNL PrintErrRax_InHex PrintErrRax_InHexNL PrintErrRegisterInHex PrintErrRegisterInHex PrintErrRightInBin PrintErrRightInBinNL PrintErrRightInHex PrintErrRightInHexNL PrintErrSpace PrintErrString PrintErrStringNL PrintErrStringNL PrintErrTraceBack PrintMemory PrintMemoryInHex PrintMemory_InHex PrintNL PrintOneRegisterInHex PrintOutNL PrintOutOneRegisterInHex PrintOutOneRegisterInHexNL PrintOutRaxInHex PrintOutRaxInHexNL PrintOutRaxRightInDec PrintOutRaxRightInDecNL PrintOutRax_InHex PrintOutRax_InHexNL PrintOutRegisterInHex PrintOutRegisterInHex PrintOutRightInBin PrintOutRightInBinNL PrintOutRightInHex PrintOutRightInHexNL PrintOutSpace PrintOutString PrintOutStringNL PrintOutStringNL PrintOutTraceBack PrintRaxAsChar PrintRaxAsText PrintRaxInDec PrintRaxInHex PrintRaxRightInDec PrintRax_InHex PrintRegisterInHex PrintRightInBin PrintRightInHex PrintSpace PrintString PrintString PrintStringNL PrintTraceBack Pslldq Psrldq Push PushR PushRR Pushfq R RComment RComment Rb Rd Rdtsc ReadChar ReadFile ReadInteger ReadLine ReadTimeStampCounter RegisterSize RestoreFirstFour RestoreFirstFourExceptRax RestoreFirstFourExceptRaxAndRdi RestoreFirstSeven RestoreFirstSevenExceptRax RestoreFirstSevenExceptRaxAndRdi Ret Rq Rs Rutf8 Rw Sal Sar SaveFirstFour SaveFirstSeven SaveRegIntoMm SetLabel SetMaskRegister SetZF Seta Setae Setb Setbe Setc Sete Setg Setge Setl Setle Setna Setnae Setnb Setnbe Setnc Setne Setng Setnge Setnl Setno Setnp Setns Setnz Seto Setp Setpe Setpo Sets Setz Shl Shr Start StatSize StringLength StringLength Structure Sub Subroutine Subroutine SubroutineStartStack Syscall Syscall Test Then Tzcnt V Vaddd Vaddpd Valignb Valignd Valignq Valignw Variable Vcvtudq2pd Vcvtudq2ps Vcvtuqq2pd Vdpps Vgetman
tps Vmovd Vmovdqa32 Vmovdqa64 Vmovdqu Vmovdqu32 Vmovdqu64 Vmovdqu8 Vmovq Vmulpd Vpaddb Vpaddd Vpaddq Vpaddw Vpandb Vpandd Vpandnb Vpandnd Vpandnq Vpandnw Vpandq Vpandw Vpbroadcastb Vpbroadcastd Vpbroadcastq Vpbroadcastw Vpcmpeqb Vpcmpeqd Vpcmpeqq Vpcmpeqw Vpcmpub Vpcmpud Vpcmpuq Vpcmpuw Vpcompressd Vpcompressq Vpexpandd Vpexpandq Vpextrb Vpextrd Vpextrq Vpextrw Vpinsrb Vpinsrd Vpinsrq Vpinsrw Vpmovb2m Vpmovd2m Vpmovm2b Vpmovm2d Vpmovm2q Vpmovm2w Vpmovq2m Vpmovw2m Vpmullb Vpmulld Vpmullq Vpmullw Vporb Vpord Vporq Vporvpcmpeqb Vporvpcmpeqd Vporvpcmpeqq Vporvpcmpeqw Vporw Vprolq Vpsubb Vpsubd Vpsubq Vpsubw Vptestb Vptestd Vptestq Vptestw Vpxorb Vpxord Vpxorq Vpxorw Vsqrtpd WaitPid Xchg Xor ah al ax bFromX bFromZ bRegFromZmm bRegIntoZmm bh bl bp bpl bx byteRegister ch checkZmmRegister cl copyStructureMinusVariables createBitNumberFromAlternatingPattern cs cx dFromX dFromZ dWordRegister dh di dil dl ds dx eax ebp ebx ecx edi edx es esi esp executeFileViaBash fs getBwdqFromMm gs k0 k1 k2 k3 k4 k5 k6 k7 mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7 qFromX qFromZ r10 r10b r10d r10l r10w r11 r11b r11d r11l r11w r12 r12b r12d r12l r12w r13 r13b r13d r13l r13w r14 r14b r14d r14l r14w r15 r15b r15d r15l r15w r8 r8b r8d r8l r8w r9 r9b r9d r9l r9w rax rbp rbx rcx rdi rdx registerNameFromNumber rflags rip rsi rsp si sil sp spl ss st0 st1 st2 st3 st4 st5 st6 st7 unlinkFile wFromX wFromZ wRegFromZmm wRegIntoZmm wordRegister xmm xmm0 xmm1 xmm10 xmm11 xmm12 xmm13 xmm14 xmm15 xmm16 xmm17 xmm18 xmm19 xmm2 xmm20 xmm21 xmm22 xmm23 xmm24 xmm25 xmm26 xmm27 xmm28 xmm29 xmm3 xmm30 xmm31 xmm4 xmm5 xmm6 xmm7 xmm8 xmm9 ymm ymm0 ymm1 ymm10 ymm11 ymm12 ymm13 ymm14 ymm15 ymm16 ymm17 ymm18 ymm19 ymm2 ymm20 ymm21 ymm22 ymm23 ymm24 ymm25 ymm26 ymm27 ymm28 ymm29 ymm3 ymm30 ymm31 ymm4 ymm5 ymm6 ymm7 ymm8 ymm9 zmm zmm0 zmm1 zmm10 zmm11 zmm12 zmm13 zmm14 zmm15 zmm16 zmm17 zmm18 zmm19 zmm2 zmm20 zmm21 zmm22 zmm23 zmm24 zmm25 zmm26 zmm27 zmm28 zmm29 zmm3 zmm30 zmm31 zmm4 zmm5 zmm6 zmm7 zmm8 zmm9 zmmM zmmMZ);%EXPORT_TAGS  = (all => [@EXPORT, @EXPORT_OK]);

# podDocumentation
=pod

=encoding utf-8

=head1 Name

Nasm::X86 - Generate X86 assembler code using Perl as a macro pre-processor.

=head1 Synopsis

Write and execute B<x64> B<Avx512> assembler code from L<perl> using L<perl> as a
macro assembler.  The generated code can be run under the Intel emulator to
obtain execution trace and instruction counts.

=head2 Examples

=head3 Avx512 instructions

Use B<Avx512> instructions to perform B<64> comparisons in parallel.

  my $P = "2F";                                                                 # Value to test for
  my $l = Rb 0;  Rb $_ for 1..RegisterSize zmm0;                                # 0..63
  Vmovdqu8 zmm0, "[$l]";                                                        # Load data to test
  PrintOutRegisterInHex zmm0;

  Mov rax, "0x$P";                                                              # Broadcast the value to be tested
  Vpbroadcastb zmm1, rax;
  PrintOutRegisterInHex zmm1;

  for my $c(0..7)                                                               # Each possible test
   {my $m = "k$c";
    Vpcmpub $m, zmm1, zmm0, $c;
    PrintOutRegisterInHex $m;
   }

  Kmovq rax, k0;                                                                # Count the number of trailing zeros in k0
  Tzcnt rax, rax;
  PrintOutRegisterInHex rax;

  is_deeply Assemble, <<END;                                                    # Assemble and test
  zmm0: 3F3E 3D3C 3B3A 3938   3736 3534 3332 3130   2F2E 2D2C 2B2A 2928   2726 2524 2322 2120   1F1E 1D1C 1B1A 1918   1716 1514 1312 1110   0F0E 0D0C 0B0A 0908   0706 0504 0302 0100
  zmm1: 2F2F 2F2F 2F2F 2F2F   2F2F 2F2F 2F2F 2F2F   2F2F 2F2F 2F2F 2F2F   2F2F 2F2F 2F2F 2F2F   2F2F 2F2F 2F2F 2F2F   2F2F 2F2F 2F2F 2F2F   2F2F 2F2F 2F2F 2F2F   2F2F 2F2F 2F2F 2F2F
    k0: 0000 8000 0000 0000
    k1: FFFF 0000 0000 0000
    k2: FFFF 8000 0000 0000
    k3: 0000 0000 0000 0000
    k4: FFFF 7FFF FFFF FFFF
    k5: 0000 FFFF FFFF FFFF
    k6: 0000 7FFF FFFF FFFF
    k7: FFFF FFFF FFFF FFFF
   rax: 0000 0000 0000 002F
END

With the print statements removed, the Intel Emulator indicates that 26
instructions were executed:

  CALL_NEAR                                                              1
  ENTER                                                                  2
  JMP                                                                    1
  KMOVQ                                                                  1
  MOV                                                                    5
  POP                                                                    1
  PUSH                                                                   3
  SYSCALL                                                                1
  TZCNT                                                                  1
  VMOVDQU8                                                               1
  VPBROADCASTB                                                           1
  VPCMPUB                                                                8

  *total                                                                26

=head3 Create a library

Create a library with three subroutines in it and save the library to a file:

  my $library = CreateLibrary          # Library definition
   (subroutines =>                     # Sub routines in libray
     {inc => sub {Inc rax},            # Increment rax
      dup => sub {Shl rax, 1},         # Double rax
      put => sub {PrintOutRaxInDecNL}, # Print rax in decimal
     },
    file => q(library),
   );

Reload the library and call its subroutines from a separate assembly:

  my ($dup, $inc, $put) = $library->load; # Load the library into variables

  Mov rax, 1; &$put;
  &$inc;      &$put;                      # Use the subroutines from the library
  &$dup;      &$put;
  &$dup;      &$put;
  &$inc;      &$put;

  ok Assemble eq => <<END;
1
2
4
8
9
END

=head3 Read and write characters

Read a line of characters from stdin and print them out on stdout:

  my $e = q(readChar);

  ForEver
   {my ($start, $end) = @_;
    ReadChar;
    Cmp rax, 0xa;
    Jle $end;
    PrintOutRaxAsChar;
    PrintOutRaxAsChar;
   };
  PrintOutNL;

  Assemble keep => $e;

  is_deeply qx(echo "ABCDCBA" | ./$e), <<END;
AABBCCDDCCBBAA
END

=head3 Write unicode characters

Generate and write some unicode utf8 characters:

  V( loop => 16)->for(sub
   {my ($index, $start, $next, $end) = @_;
    $index->setReg(rax);
    Add rax, 0xb0;   Shl rax, 16;
    Mov  ax, 0x9d9d; Shl rax, 8;
    Mov  al, 0xf0;
    PrintOutRaxAsText;
   });
  PrintOutNL;

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);

END

=head3 Read a file

Read this file:

  ReadFile(V(file, Rs($0)), (my $s = V(size)), my $a = V(address));             # Read file
  $a->setReg(rax);                                                              # Address of file in memory
  $s->setReg(rdi);                                                              # Length  of file in memory
  PrintOutMemory;                                                               # Print contents of memory to stdout

  my $r = Assemble(1 => (my $f = temporaryFile));                               # Assemble and execute
  ok fileMd5Sum($f) eq fileMd5Sum($0);                                          # Output contains this file


=head3 Call functions in Libc

Call B<C> functions by naming them as external and including their library:

  my $format = Rs "Hello %s\n";
  my $data   = Rs "World";

  Extern qw(printf exit malloc strcpy); Link 'c';

  CallC 'malloc', length($format)+1;
  Mov r15, rax;
  CallC 'strcpy', r15, $format;
  CallC 'printf', r15, $data;
  CallC 'exit', 0;

  ok Assemble eq => <<END;
Hello World
END

=head3 Print numbers in decimal from assembly code using nasm and perl:

Debug your programs with powerful print statements:

  Mov rax, 0x2a;
  PrintOutRaxInDecNL;

  ok Assemble eq => <<END;
42
END

=head3 Process management

Start a child process and wait for it, printing out the process identifiers of
each process involved:

   Fork;                                     # Fork

   Test rax,rax;
   IfNz                                      # Parent
   Then
    {Mov rbx, rax;
     WaitPid;
     GetPid;                                 # Pid of parent as seen in parent
     Mov rcx,rax;
     PrintOutRegisterInHex rax, rbx, rcx;
    },
   Else                                      # Child
    {Mov r8,rax;
     GetPid;                                 # Child pid as seen in child
     Mov r9,rax;
     GetPPid;                                # Parent pid as seen in child
     Mov r10,rax;
     PrintOutRegisterInHex r8, r9, r10;
    };

   my $r = Assemble;

 #    r8: 0000 0000 0000 0000   #1 Return from fork as seen by child
 #    r9: 0000 0000 0003 0C63   #2 Pid of child
 #   r10: 0000 0000 0003 0C60   #3 Pid of parent from child
 #   rax: 0000 0000 0003 0C63   #4 Return from fork as seen by parent
 #   rbx: 0000 0000 0003 0C63   #5 Wait for child pid result
 #   rcx: 0000 0000 0003 0C60   #6 Pid of parent

=head3 Dynamic area

Arenas are resizeable, relocatable blocks of memory that hold other dynamic
data structures. Arenas can be transferred between processes and relocated as
needed as all addressing is relative to the start of the block of memory
containing each area.

Create two dynamic arenas, add some content to them, write each area to
stdout:

  my $a = CreateArea;

  my $b = CreateArea;
  $a->q('aa');
  $b->q('bb');
  $a->q('AA');
  $b->q('BB');
  $a->q('aa');
  $b->q('bb');

  $a->out;
  $b->out;

  PrintOutNL;

  is_deeply Assemble, <<END;
aaAAaabbBBbb
END

=head4 Dynamic string held in an area

Create a dynamic string within an area and add some content to it:

  my $s = Rb(0..255);
  my $A = CreateArea;
  my $S = $A->CreateString;

  $S->append(V(source, $s), K(size, 256));
  $S->len->outNL;
  $S->clear;

  $S->append(V(source, $s), K(size,  16));
  $S->len->outNL;
  $S->dump;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
size: 0000 0000 0000 0100
size: 0000 0000 0000 0010
string Dump
Offset: 0000 0000 0000 0018   Length: 0000 0000 0000 0010
 zmm31: 0000 0018 0000 0018   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 000F   0E0D 0C0B 0A09 0807   0605 0403 0201 0010

END

=head4 Dynamic array held in an area

Create a dynamic array within an area, push some content on to it then pop it
off again:

  my $N = 15;
  my $A = CreateArea;
  my $a = $A->CreateArray;

  $a->push(V(element, $_)) for 1..$N;

  K(loop, $N)->for(sub
   {my ($start, $end, $next) = @_;
    my $l = $a->size;
    If $l == 0, Then {Jmp $end};
    $a->pop(my $e = V(element));
    $e->outNL;
   });

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
element: 0000 0000 0000 000F
element: 0000 0000 0000 000E
element: 0000 0000 0000 000D
element: 0000 0000 0000 000C
element: 0000 0000 0000 000B
element: 0000 0000 0000 000A
element: 0000 0000 0000 0009
element: 0000 0000 0000 0008
element: 0000 0000 0000 0007
element: 0000 0000 0000 0006
element: 0000 0000 0000 0005
element: 0000 0000 0000 0004
element: 0000 0000 0000 0003
element: 0000 0000 0000 0002
element: 0000 0000 0000 0001
END

=head4 Create a multi way tree in an area using SIMD instructions

Create a multiway tree as in L<Tree::Multi> using B<Avx512> instructions and
iterate through it:

  my $N = 12;
  my $b = CreateArea;                   # Resizable memory block
  my $t = $b->CreateTree;        # Multi way tree in memory block

  K(count, $N)->for(sub                      # Add some entries to the tree
   {my ($index, $start, $next, $end) = @_;
    my $k = $index + 1;
    $t->insert($k,      $k + 0x100);
    $t->insert($k + $N, $k + 0x200);
   });

  $t->by(sub                                  # Iterate through the tree
   {my ($iter, $end) = @_;
    $iter->key ->out('key: ');
    $iter->data->out(' data: ');
    $iter->tree->depth($iter->node, my $D = V(depth));

    $t->find($iter->key);
    $t->found->out(' found: '); $t->data->out(' data: '); $D->outNL(' depth: ');
   });

  $t->find(K(key, 0xffff));  $t->found->outNL('Found: ');  # Find some entries
  $t->find(K(key, 0xd));     $t->found->outNL('Found: ');

  If ($t->found,
  Then
   {$t->data->outNL("Data : ");
   });

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
key: 0000 0000 0000 0001 data: 0000 0000 0000 0101 found: 0000 0000 0000 0001 data: 0000 0000 0000 0101 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0002 data: 0000 0000 0000 0102 found: 0000 0000 0000 0001 data: 0000 0000 0000 0102 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0003 data: 0000 0000 0000 0103 found: 0000 0000 0000 0001 data: 0000 0000 0000 0103 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0004 data: 0000 0000 0000 0104 found: 0000 0000 0000 0001 data: 0000 0000 0000 0104 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0005 data: 0000 0000 0000 0105 found: 0000 0000 0000 0001 data: 0000 0000 0000 0105 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0006 data: 0000 0000 0000 0106 found: 0000 0000 0000 0001 data: 0000 0000 0000 0106 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0007 data: 0000 0000 0000 0107 found: 0000 0000 0000 0001 data: 0000 0000 0000 0107 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0008 data: 0000 0000 0000 0108 found: 0000 0000 0000 0001 data: 0000 0000 0000 0108 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0009 data: 0000 0000 0000 0109 found: 0000 0000 0000 0001 data: 0000 0000 0000 0109 depth: 0000 0000 0000 0002
key: 0000 0000 0000 000A data: 0000 0000 0000 010A found: 0000 0000 0000 0001 data: 0000 0000 0000 010A depth: 0000 0000 0000 0002
key: 0000 0000 0000 000B data: 0000 0000 0000 010B found: 0000 0000 0000 0001 data: 0000 0000 0000 010B depth: 0000 0000 0000 0002
key: 0000 0000 0000 000C data: 0000 0000 0000 010C found: 0000 0000 0000 0001 data: 0000 0000 0000 010C depth: 0000 0000 0000 0002
key: 0000 0000 0000 000D data: 0000 0000 0000 0201 found: 0000 0000 0000 0001 data: 0000 0000 0000 0201 depth: 0000 0000 0000 0001
key: 0000 0000 0000 000E data: 0000 0000 0000 0202 found: 0000 0000 0000 0001 data: 0000 0000 0000 0202 depth: 0000 0000 0000 0002
key: 0000 0000 0000 000F data: 0000 0000 0000 0203 found: 0000 0000 0000 0001 data: 0000 0000 0000 0203 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0010 data: 0000 0000 0000 0204 found: 0000 0000 0000 0001 data: 0000 0000 0000 0204 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0011 data: 0000 0000 0000 0205 found: 0000 0000 0000 0001 data: 0000 0000 0000 0205 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0012 data: 0000 0000 0000 0206 found: 0000 0000 0000 0001 data: 0000 0000 0000 0206 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0013 data: 0000 0000 0000 0207 found: 0000 0000 0000 0001 data: 0000 0000 0000 0207 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0014 data: 0000 0000 0000 0208 found: 0000 0000 0000 0001 data: 0000 0000 0000 0208 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0015 data: 0000 0000 0000 0209 found: 0000 0000 0000 0001 data: 0000 0000 0000 0209 depth: 0000 0000 0000 0002
key: 0000 0000 0000 0016 data: 0000 0000 0000 020A found: 0000 0000 0000 0001 data: 0000 0000 0000 020A depth: 0000 0000 0000 0002
key: 0000 0000 0000 0017 data: 0000 0000 0000 020B found: 0000 0000 0000 0001 data: 0000 0000 0000 020B depth: 0000 0000 0000 0002
key: 0000 0000 0000 0018 data: 0000 0000 0000 020C found: 0000 0000 0000 0001 data: 0000 0000 0000 020C depth: 0000 0000 0000 0002
Found: 0000 0000 0000 0000
Found: 0000 0000 0000 0001
Data : 0000 0000 0000 0201
END

=head4 Quarks held in an area

Quarks replace unique strings with unique numbers and in doing so unite all
that is best and brightest in dynamic trees, arrays, strings and short
strings, all written in X86 assembler, all generated by Perl:

  my $N = 5;
  my $a = CreateArea;                      # Area containing quarks
  my $Q = $a->CreateQuarks;                 # Quarks

  my $s = CreateShortString(0);             # Short string used to load and unload quarks
  my $d = Rb(1..63);

  for my $i(1..$N)                          # Load a set of quarks
   {my $j = $i - 1;
    $s->load(K(address, $d), K(size, 4+$i));
    my $q = $Q->quarkFromShortString($s);
    $q->outNL("New quark    $j: ");         # New quark, new number
   }
  PrintOutNL;

  for my $i(reverse 1..$N)                  # Reload a set of quarks
   {my $j = $i - 1;
    $s->load(K(address, $d), K(size, 4+$i));
    my $q = $Q->quarkFromShortString($s);
    $q->outNL("Old quark    $j: ");         # Old quark, old number
   }
  PrintOutNL;

  for my $i(1..$N)                          # Dump quarks
   {my $j = $i - 1;
     $s->clear;
    $Q->shortStringFromQuark(K(quark, $j), $s);
    PrintOutString "Quark string $j: ";
    PrintOutRegisterInHex xmm0;
   }

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
  New quark    0: 0000 0000 0000 0000
  New quark    1: 0000 0000 0000 0001
  New quark    2: 0000 0000 0000 0002
  New quark    3: 0000 0000 0000 0003
  New quark    4: 0000 0000 0000 0004

  Old quark    4: 0000 0000 0000 0004
  Old quark    3: 0000 0000 0000 0003
  Old quark    2: 0000 0000 0000 0002
  Old quark    1: 0000 0000 0000 0001
  Old quark    0: 0000 0000 0000 0000

  Quark string 0:   xmm0: 0000 0000 0000 0000   0000 0504 0302 0105
  Quark string 1:   xmm0: 0000 0000 0000 0000   0006 0504 0302 0106
  Quark string 2:   xmm0: 0000 0000 0000 0000   0706 0504 0302 0107
  Quark string 3:   xmm0: 0000 0000 0000 0008   0706 0504 0302 0108
  Quark string 4:   xmm0: 0000 0000 0000 0908   0706 0504 0302 0109
  END

=head3 Recursion with stack and parameter tracing

Call a subroutine recursively and get a trace back showing the procedure calls
and parameters passed to each call. Parameters are passed by reference not
value.

  my $d = V depth => 3;                                                         # Create a variable on the stack

  my $s = Subroutine33
   {my ($p, $s) = @_;                                                           # Parameters, subroutine descriptor
    PrintOutTraceBack;

    my $d = $$p{depth}->copy($$p{depth} - 1);                                   # Modify the variable referenced by the parameter

    If ($d > 0,
    Then
     {$s->call($d);                                                             # Recurse
     });

    PrintOutTraceBack;
   } [qw(depth)], name => 'ref';

  $s->call($d);                                                                 # Call the subroutine

  ok Assemble(debug => 0, eq => <<END, avx512=>0);

  Subroutine trace back, depth:  1
  0000 0000 0000 0003    ref


  Subroutine trace back, depth:  2
  0000 0000 0000 0002    ref
  0000 0000 0000 0002    ref


  Subroutine trace back, depth:  3
  0000 0000 0000 0001    ref
  0000 0000 0000 0001    ref
  0000 0000 0000 0001    ref


  Subroutine trace back, depth:  3
  0000 0000 0000 0000    ref
  0000 0000 0000 0000    ref
  0000 0000 0000 0000    ref


  Subroutine trace back, depth:  2
  0000 0000 0000 0000    ref
  0000 0000 0000 0000    ref


  Subroutine trace back, depth:  1
  0000 0000 0000 0000    ref

  END

=head2 Installation

The Intel Software Development Emulator will be required if you do not have a
computer with the avx512 instruction set and wish to execute code containing
these instructions. For details see:

L<https://software.intel.com/content/dam/develop/external/us/en/documents/downloads/sde-external-8.63.0-2021-01-18-lin.tar.bz2>


The Networkwide Assembler is required to assemble the code produced  For full
details see:

L<https://github.com/philiprbrenan/NasmX86/blob/main/.github/workflows/main.yml>

=head2 Execution Options

The L</Assemble(%)> function takes the keywords described below to
control assembly and execution of the assembled code:

L</Assemble(%)> runs the generated program after a successful assembly
unless the B<keep> option is specified. The output on B<stdout> is captured in
file B<zzzOut.txt> and that on B<stderr> is captured in file B<zzzErr.txt>.

The amount of output displayed is controlled by the B<debug> keyword.

The B<eq> keyword can be used to test that the output by the run.

The output produced by the program execution is returned as the result of the
L</Assemble(%)> function.

=head3 Keep

To produce a named executable without running it, specify:

 keep=>"executable file name"

=head3 Library

To produce a shared library file:

 library=>"library.so"

=head3 Emulator

To run the executable produced by L</Assemble(%)> without the Intel
emulator, which is used by default if it is present, specify:

 avx512=>0

=head3 eq

The B<eq> keyword supplies the expected output from the execution of the
assembled program.  If the expected output is not obtained on B<stdout> then we
confess and stop further testing. Output on B<stderr> is ignored for test
purposes.

The point at which the wanted output diverges from the output actually got is
displayed to assist debugging as in:

  Comparing wanted with got failed at line: 4, character: 22
  Start:
      k7: 0000 0000 0000 0001
      k6: 0000 0000 0000 0003
      k5: 0000 0000 0000 0007
      k4: 0000 0000 000
  Want ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  1 0002
      k3: 0000 0000 0000 0006
      k2: 0000 0000 0000 000E
      k1: 0000 0000
  Got  ________________________________________________________________________________
  0 0002
      k3: 0000 0000 0000 0006
      k2: 0000 0000 0000 000E
      k1: 0000 0000


=head3 Debug

The debug keyword controls how much output is printed after each assemble and
run.

  debug => 0

produces no output unless the B<eq> keyword was specified and the actual output
fails to match the expected output. If such a test fails we L<Carp::confess>.

  debug => 1

shows all the output produces and conducts the test specified by the B<eq> is
present. If the test fails we L<Carp::confess>.

  debug => 2

shows all the output produces and conducts the test specified by the B<eq> is
present. If the test fails we continue rather than calling L<Carp::confess>.

=head1 Description

Generate X86 assembler code using Perl as a macro pre-processor.


Version "20211204".


The following sections describe the methods in each functional area of this
module.  For an alphabetic listing of all methods by name see L<Index|/Index>.



=head1 Data

Layout data

=head2 SetLabel($l)

Create (if necessary) and set a label in the code section returning the label so set.

     Parameter  Description
  1  $l         Label

B<Example:>


    Mov rax, 1;
    Mov rdi, 1;
    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSeven;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFour;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRax;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRax;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;

    SetLabel $l;  # 


    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END

    ok 8 == RegisterSize rax;


=head2 Ds(@d)

Layout bytes in memory and return their label.

     Parameter  Description
  1  @d         Data to be laid out

B<Example:>


    my $q = Rs('a'..'z');

    Mov rax, Ds('0'x64);                                                        # Output area  # 

    Vmovdqu32(xmm0, "[$q]");                                                    # Load
    Vprolq   (xmm0,   xmm0, 32);                                                # Rotate double words in quad words
    Vmovdqu32("[rax]", xmm0);                                                   # Save
    Mov rdi, 16;
    PrintOutMemory;

    ok Assemble =~ m(efghabcdmnopijkl)s;


=head2 Rs(@d)

Layout bytes in read only memory and return their label.

     Parameter  Description
  1  @d         Data to be laid out

B<Example:>


    Comment "Print a string from memory";
    my $s = "Hello World";

    Mov rax, Rs($s);  # 

    Mov rdi, length $s;
    PrintOutMemory;
    Exit(0);

    ok Assemble =~ m(Hello World);


    my $q = Rs('abababab');  # 

    Mov(rax, 1);
    Mov(rbx, 2);
    Mov(rcx, 3);
    Mov(rdx, 4);
    Mov(r8,  5);
    Lea r9,  "[rax+rbx]";
    PrintOutRegistersInHex;

    my $r = Assemble;
    ok $r =~ m( r8: 0000 0000 0000 0005.* r9: 0000 0000 0000 0003.*rax: 0000 0000 0000 0001)s;
    ok $r =~ m(rbx: 0000 0000 0000 0002.*rcx: 0000 0000 0000 0003.*rdx: 0000 0000 0000 0004)s;


=head2 Rutf8(@d)

Layout a utf8 encoded string as bytes in read only memory and return their label.

     Parameter  Description
  1  @d         Data to be laid out

=head2 Db(@bytes)

Layout bytes in the data segment and return their label.

     Parameter  Description
  1  @bytes     Bytes to layout

B<Example:>


    my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;

    my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;  # 


    Vmovdqu8 xmm0, "[$s]";
    Vmovdqu8 xmm1, "[$t]";
    PrintOutRegisterInHex xmm0;
    PrintOutRegisterInHex xmm1;
    Sub rsp, 16;

    Mov rax, rsp;                                                               # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
    Mov rdi, 16;
    Mov rsi, $s;
    CopyMemory(V(source, rsi), V(target, rax), V(size, rdi));
    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    xmm0: 0000 0000 0000 0004   0000 0003 0002 0100
    xmm1: 0000 0000 0000 0004   0000 0003 0002 0100
  __01 02__ 03__ ____  04__ ____ ____ ____
  END


=head2 Dw(@words)

Layout words in the data segment and return their label.

     Parameter  Description
  1  @words     Words to layout

B<Example:>


    my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;

    my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;  # 


    Vmovdqu8 xmm0, "[$s]";
    Vmovdqu8 xmm1, "[$t]";
    PrintOutRegisterInHex xmm0;
    PrintOutRegisterInHex xmm1;
    Sub rsp, 16;

    Mov rax, rsp;                                                               # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
    Mov rdi, 16;
    Mov rsi, $s;
    CopyMemory(V(source, rsi), V(target, rax), V(size, rdi));
    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    xmm0: 0000 0000 0000 0004   0000 0003 0002 0100
    xmm1: 0000 0000 0000 0004   0000 0003 0002 0100
  __01 02__ 03__ ____  04__ ____ ____ ____
  END


=head2 Dd(@dwords)

Layout double words in the data segment and return their label.

     Parameter  Description
  1  @dwords    Double words to layout

B<Example:>


    my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;

    my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;  # 


    Vmovdqu8 xmm0, "[$s]";
    Vmovdqu8 xmm1, "[$t]";
    PrintOutRegisterInHex xmm0;
    PrintOutRegisterInHex xmm1;
    Sub rsp, 16;

    Mov rax, rsp;                                                               # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
    Mov rdi, 16;
    Mov rsi, $s;
    CopyMemory(V(source, rsi), V(target, rax), V(size, rdi));
    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    xmm0: 0000 0000 0000 0004   0000 0003 0002 0100
    xmm1: 0000 0000 0000 0004   0000 0003 0002 0100
  __01 02__ 03__ ____  04__ ____ ____ ____
  END


=head2 Dq(@qwords)

Layout quad words in the data segment and return their label.

     Parameter  Description
  1  @qwords    Quad words to layout

B<Example:>


    my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;

    my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;  # 


    Vmovdqu8 xmm0, "[$s]";
    Vmovdqu8 xmm1, "[$t]";
    PrintOutRegisterInHex xmm0;
    PrintOutRegisterInHex xmm1;
    Sub rsp, 16;

    Mov rax, rsp;                                                               # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
    Mov rdi, 16;
    Mov rsi, $s;
    CopyMemory(V(source, rsi), V(target, rax), V(size, rdi));
    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    xmm0: 0000 0000 0000 0004   0000 0003 0002 0100
    xmm1: 0000 0000 0000 0004   0000 0003 0002 0100
  __01 02__ 03__ ____  04__ ____ ____ ____
  END


=head2 Rb(@bytes)

Layout bytes in the data segment and return their label.

     Parameter  Description
  1  @bytes     Bytes to layout

B<Example:>



    my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;  # 

    my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;

    Vmovdqu8 xmm0, "[$s]";
    Vmovdqu8 xmm1, "[$t]";
    PrintOutRegisterInHex xmm0;
    PrintOutRegisterInHex xmm1;
    Sub rsp, 16;

    Mov rax, rsp;                                                               # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
    Mov rdi, 16;
    Mov rsi, $s;
    CopyMemory(V(source, rsi), V(target, rax), V(size, rdi));
    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    xmm0: 0000 0000 0000 0004   0000 0003 0002 0100
    xmm1: 0000 0000 0000 0004   0000 0003 0002 0100
  __01 02__ 03__ ____  04__ ____ ____ ____
  END


=head2 Rw(@words)

Layout words in the data segment and return their label.

     Parameter  Description
  1  @words     Words to layout

B<Example:>



    my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;  # 

    my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;

    Vmovdqu8 xmm0, "[$s]";
    Vmovdqu8 xmm1, "[$t]";
    PrintOutRegisterInHex xmm0;
    PrintOutRegisterInHex xmm1;
    Sub rsp, 16;

    Mov rax, rsp;                                                               # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
    Mov rdi, 16;
    Mov rsi, $s;
    CopyMemory(V(source, rsi), V(target, rax), V(size, rdi));
    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    xmm0: 0000 0000 0000 0004   0000 0003 0002 0100
    xmm1: 0000 0000 0000 0004   0000 0003 0002 0100
  __01 02__ 03__ ____  04__ ____ ____ ____
  END


=head2 Rd(@dwords)

Layout double words in the data segment and return their label.

     Parameter  Description
  1  @dwords    Double words to layout

B<Example:>



    my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;  # 

    my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;

    Vmovdqu8 xmm0, "[$s]";
    Vmovdqu8 xmm1, "[$t]";
    PrintOutRegisterInHex xmm0;
    PrintOutRegisterInHex xmm1;
    Sub rsp, 16;

    Mov rax, rsp;                                                               # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
    Mov rdi, 16;
    Mov rsi, $s;
    CopyMemory(V(source, rsi), V(target, rax), V(size, rdi));
    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    xmm0: 0000 0000 0000 0004   0000 0003 0002 0100
    xmm1: 0000 0000 0000 0004   0000 0003 0002 0100
  __01 02__ 03__ ____  04__ ____ ____ ____
  END


=head2 Rq(@qwords)

Layout quad words in the data segment and return their label.

     Parameter  Description
  1  @qwords    Quad words to layout

B<Example:>



    my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;  # 

    my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;

    Vmovdqu8 xmm0, "[$s]";
    Vmovdqu8 xmm1, "[$t]";
    PrintOutRegisterInHex xmm0;
    PrintOutRegisterInHex xmm1;
    Sub rsp, 16;

    Mov rax, rsp;                                                               # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
    Mov rdi, 16;
    Mov rsi, $s;
    CopyMemory(V(source, rsi), V(target, rax), V(size, rdi));
    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    xmm0: 0000 0000 0000 0004   0000 0003 0002 0100
    xmm1: 0000 0000 0000 0004   0000 0003 0002 0100
  __01 02__ 03__ ____  04__ ____ ____ ____
  END


=head1 Registers

Operations on registers

=head2 Size

Sizes of each register

=head3 RegisterSize($r)

Return the size of a register.

     Parameter  Description
  1  $r         Register

B<Example:>


    Mov rax, 1;
    Mov rdi, 1;
    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSeven;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFour;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRax;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRax;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;
    SetLabel $l;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END


    ok 8 == RegisterSize rax;  # 



=head2 Push, Pop, Peek

Generic versions of push, pop, peek

=head3 PopR(@r)

Pop registers from the stack. Use the last stored set if none explicitly supplied.  Pops are done in reverse order to match the original pushing order.

     Parameter  Description
  1  @r         Register

B<Example:>


    Mov rax, 0x11111111;
    Mov rbx, 0x22222222;
    PushR my @save = (rax, rbx);
    Mov rax, 0x33333333;

    PopR;  # 

    PrintOutRegisterInHex rax;
    PrintOutRegisterInHex rbx;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 1111 1111
     rbx: 0000 0000 2222 2222
  END


=head2 General

Actions specific to general purpose registers

=head3 registerNameFromNumber($r)

Register name from number where possible

     Parameter  Description
  1  $r         Register number

=head3 ChooseRegisters($number, @registers)

Choose the specified numbers of registers excluding those on the specified list.

     Parameter   Description
  1  $number     Number of registers needed
  2  @registers  Registers not to choose

=head3 InsertZeroIntoRegisterAtPoint($point, $in)

Insert a zero into the specified register at the point indicated by another general purpose or mask register moving the higher bits one position to the left.

     Parameter  Description
  1  $point     Register with a single 1 at the insertion point
  2  $in        Register to be inserted into.

B<Example:>


    Mov r15, 0x100;                                                             # Given a register with a single one in it indicating the desired position,
    Mov r14, 0xFFDC;                                                            # Insert a zero into the register at that position shifting the bits above that position up left one to make space for the new zero.
    Mov r13, 0xF03F;
    PrintOutRegisterInHex         r14, r15;

    InsertZeroIntoRegisterAtPoint r15, r14;  # 

    PrintOutRegisterInHex r14;
    Or r14, r15;                                                                # Replace the inserted zero with a one
    PrintOutRegisterInHex r14;
    InsertOneIntoRegisterAtPoint r15, r13;
    PrintOutRegisterInHex r13;
    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     r14: 0000 0000 0000 FFDC
     r15: 0000 0000 0000 0100
     r14: 0000 0000 0001 FEDC
     r14: 0000 0000 0001 FFDC
     r13: 0000 0000 0001 E13F
  END


=head3 InsertOneIntoRegisterAtPoint($point, $in)

Insert a one into the specified register at the point indicated by another register.

     Parameter  Description
  1  $point     Register with a single 1 at the insertion point
  2  $in        Register to be inserted into.

B<Example:>


    Mov r15, 0x100;                                                             # Given a register with a single one in it indicating the desired position,
    Mov r14, 0xFFDC;                                                            # Insert a zero into the register at that position shifting the bits above that position up left one to make space for the new zero.
    Mov r13, 0xF03F;
    PrintOutRegisterInHex         r14, r15;
    InsertZeroIntoRegisterAtPoint r15, r14;
    PrintOutRegisterInHex r14;
    Or r14, r15;                                                                # Replace the inserted zero with a one
    PrintOutRegisterInHex r14;

    InsertOneIntoRegisterAtPoint r15, r13;  # 

    PrintOutRegisterInHex r13;
    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     r14: 0000 0000 0000 FFDC
     r15: 0000 0000 0000 0100
     r14: 0000 0000 0001 FEDC
     r14: 0000 0000 0001 FFDC
     r13: 0000 0000 0001 E13F
  END


=head2 Save and Restore

Saving and restoring registers via the stack

=head3 SaveFirstFour(@keep)

Save the first 4 parameter registers making any parameter registers read only.

     Parameter  Description
  1  @keep      Registers to mark as read only

B<Example:>


    Mov rax, 1;
    Mov rdi, 1;

    SaveFirstFour;  # 

    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSeven;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFour;
    PrintOutRegisterInHex rax, rdi;


    SaveFirstFour;  # 

    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRax;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRax;
    PrintOutRegisterInHex rax, rdi;


    SaveFirstFour;  # 

    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;
    SetLabel $l;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END

    ok 8 == RegisterSize rax;


=head3 RestoreFirstFour()

Restore the first 4 parameter registers.


B<Example:>


    Mov rax, 1;
    Mov rdi, 1;
    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSeven;
    PrintOutRegisterInHex rax, rdi;

    RestoreFirstFour;  # 

    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRax;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRax;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;
    SetLabel $l;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END

    ok 8 == RegisterSize rax;


=head3 RestoreFirstFourExceptRax()

Restore the first 4 parameter registers except rax so it can return its value.


B<Example:>


    Mov rax, 1;
    Mov rdi, 1;
    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSeven;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFour;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRax;
    PrintOutRegisterInHex rax, rdi;

    RestoreFirstFourExceptRax;  # 

    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;
    SetLabel $l;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END

    ok 8 == RegisterSize rax;


=head3 RestoreFirstFourExceptRaxAndRdi()

Restore the first 4 parameter registers except rax  and rdi so we can return a pair of values.


B<Example:>


    Mov rax, 1;
    Mov rdi, 1;
    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSeven;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFour;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRax;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRax;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    RestoreFirstFourExceptRaxAndRdi;  # 

    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;
    SetLabel $l;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END

    ok 8 == RegisterSize rax;


=head3 SaveFirstSeven()

Save the first 7 parameter registers.


B<Example:>


    Mov rax, 1;
    Mov rdi, 1;
    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;

    SaveFirstSeven;  # 

    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSeven;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFour;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;

    SaveFirstSeven;  # 

    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRax;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRax;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;

    SaveFirstSeven;  # 

    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;
    SetLabel $l;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END

    ok 8 == RegisterSize rax;


=head3 RestoreFirstSeven()

Restore the first 7 parameter registers.


B<Example:>


    Mov rax, 1;
    Mov rdi, 1;
    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;

    RestoreFirstSeven;  # 

    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFour;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRax;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRax;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;
    SetLabel $l;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END

    ok 8 == RegisterSize rax;


=head3 RestoreFirstSevenExceptRax()

Restore the first 7 parameter registers except rax which is being used to return the result.


B<Example:>


    Mov rax, 1;
    Mov rdi, 1;
    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSeven;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFour;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;

    RestoreFirstSevenExceptRax;  # 

    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRax;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;
    SetLabel $l;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END

    ok 8 == RegisterSize rax;


=head3 RestoreFirstSevenExceptRaxAndRdi()

Restore the first 7 parameter registers except rax and rdi which are being used to return the results.


B<Example:>


    Mov rax, 1;
    Mov rdi, 1;
    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSeven;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFour;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstSevenExceptRax;
    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRax;
    PrintOutRegisterInHex rax, rdi;

    SaveFirstFour;
    Mov rax, 2;
    Mov rdi, 2;
    SaveFirstSeven;
    Mov rax, 3;
    Mov rdi, 4;
    PrintOutRegisterInHex rax, rdi;

    RestoreFirstSevenExceptRaxAndRdi;  # 

    PrintOutRegisterInHex rax, rdi;
    RestoreFirstFourExceptRaxAndRdi;
    PrintOutRegisterInHex rax, rdi;

    Bswap rax;
    PrintOutRegisterInHex rax;

    my $l = Label;
    Jmp $l;
    SetLabel $l;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0002
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0001
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0002
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0001
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0000 0000 0000 0003
     rdi: 0000 0000 0000 0004
     rax: 0300 0000 0000 0000
  END

    ok 8 == RegisterSize rax;


=head3 ClearRegisters(@registers)

Clear registers by setting them to zero.

     Parameter   Description
  1  @registers  Registers

B<Example:>


    Mov rax,1;
    Kmovq k0,  rax;
    Kaddb k0,  k0, k0;
    Kaddb k0,  k0, k0;
    Kaddb k0,  k0, k0;
    Kmovq rax, k0;
    PushR k0;

    ClearRegisters k0;  # 

    Kmovq k1, k0;
    PopR  k0;
    PrintOutRegisterInHex k0;
    PrintOutRegisterInHex k1;

    ok Assemble =~ m(k0: 0000 0000 0000 0008.*k1: 0000 0000 0000 0000)s;


=head3 SetZF()

Set the zero flag.


B<Example:>



    SetZF;  # 

    PrintOutZF;
    ClearZF;
    PrintOutZF;

    SetZF;  # 

    PrintOutZF;

    SetZF;  # 

    PrintOutZF;
    ClearZF;
    PrintOutZF;


    SetZF;  # 

    IfZ  Then {PrintOutStringNL "Zero"},     Else {PrintOutStringNL "NOT zero"};
    ClearZF;
    IfNz Then {PrintOutStringNL "NOT zero"}, Else {PrintOutStringNL "Zero"};

    Mov r15, 5;
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};
    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  Zero
  NOT zero
  Carry
  NO carry
  Carry
  NO carry
  END


=head3 ClearZF()

Clear the zero flag.


B<Example:>


    SetZF;
    PrintOutZF;

    ClearZF;  # 

    PrintOutZF;
    SetZF;
    PrintOutZF;
    SetZF;
    PrintOutZF;

    ClearZF;  # 

    PrintOutZF;

    SetZF;
    IfZ  Then {PrintOutStringNL "Zero"},     Else {PrintOutStringNL "NOT zero"};

    ClearZF;  # 

    IfNz Then {PrintOutStringNL "NOT zero"}, Else {PrintOutStringNL "Zero"};

    Mov r15, 5;
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};
    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  Zero
  NOT zero
  Carry
  NO carry
  Carry
  NO carry
  END


=head2 x, y, zmm

Actions specific to mm registers

=head3 xmm(@r)

Add xmm to the front of a list of register expressions.

     Parameter  Description
  1  @r         Register numbers

=head3 ymm(@r)

Add ymm to the front of a list of register expressions.

     Parameter  Description
  1  @r         Register numbers

=head3 zmm(@r)

Add zmm to the front of a list of register expressions.

     Parameter  Description
  1  @r         Register numbers

B<Example:>


    LoadZmm 0, 0..63;

    PrintOutRegisterInHex zmm 0;  # 


    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    zmm0: 3F3E 3D3C 3B3A 3938   3736 3534 3332 3130   2F2E 2D2C 2B2A 2928   2726 2524 2322 2120   1F1E 1D1C 1B1A 1918   1716 1514 1312 1110   0F0E 0D0C 0B0A 0908   0706 0504 0302 0100
  END


=head3 zmmM($z, $m)

Add zmm to the front of a register number and a mask after it

     Parameter  Description
  1  $z         Zmm number
  2  $m         Mask register

=head3 zmmMZ($z, $m)

Add zmm to the front of a register number and mask and zero after it

     Parameter  Description
  1  $z         Zmm number
  2  $m         Mask register number

=head3 LoadZmm($zmm, @bytes)

Load a numbered zmm with the specified bytes.

     Parameter  Description
  1  $zmm       Numbered zmm
  2  @bytes     Bytes

B<Example:>



    LoadZmm 0, 0..63;  # 

    PrintOutRegisterInHex zmm 0;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    zmm0: 3F3E 3D3C 3B3A 3938   3736 3534 3332 3130   2F2E 2D2C 2B2A 2928   2726 2524 2322 2120   1F1E 1D1C 1B1A 1918   1716 1514 1312 1110   0F0E 0D0C 0B0A 0908   0706 0504 0302 0100
  END


=head3 checkZmmRegister($z)

Check that a register is a zmm register

     Parameter  Description
  1  $z         Parameters

=head3 bRegFromZmm($register, $zmm, $offset)

Load the specified register from the byte at the specified offset located in the numbered zmm.

     Parameter  Description
  1  $register  Register to load
  2  $zmm       Numbered zmm register to load from
  3  $offset    Constant offset in bytes

=head3 bRegIntoZmm($register, $zmm, $offset)

Put the byte content of the specified register into the byte in the numbered zmm at the specified offset in the zmm.

     Parameter  Description
  1  $register  Register to load
  2  $zmm       Numbered zmm register to load from
  3  $offset    Constant offset in bytes

=head3 wRegFromZmm($register, $zmm, $offset)

Load the specified register from the word at the specified offset located in the numbered zmm.

     Parameter  Description
  1  $register  Register to load
  2  $zmm       Numbered zmm register to load from
  3  $offset    Constant offset in bytes

=head3 wRegIntoZmm($register, $zmm, $offset)

Put the specified register into the word in the numbered zmm at the specified offset in the zmm.

     Parameter  Description
  1  $register  Register to load
  2  $zmm       Numbered zmm register to load from
  3  $offset    Constant offset in bytes

=head3 LoadRegFromMm($mm, $offset, $reg)

Load the specified register from the numbered zmm at the quad offset specified as a constant number.

     Parameter  Description
  1  $mm        Mm register
  2  $offset    Offset in quads
  3  $reg       General purpose register to load

=head3 SaveRegIntoMm($mm, $offset, $reg)

Save the specified register into the numbered zmm at the quad offset specified as a constant number.

     Parameter  Description
  1  $mm        Mm register
  2  $offset    Offset in quads
  3  $reg       General purpose register to load

=head3 getBwdqFromMm($size, $mm, $offset)

Get the numbered byte|word|double word|quad word from the numbered zmm register and return it in a variable.

     Parameter  Description
  1  $size      Size of get
  2  $mm        Mm register
  3  $offset    Offset in bytes either as a constant or as a variable

=head3 bFromX($xmm, $offset)

Get the byte from the numbered xmm register and return it in a variable.

     Parameter  Description
  1  $xmm       Numbered xmm
  2  $offset    Offset in bytes

=head3 wFromX($xmm, $offset)

Get the word from the numbered xmm register and return it in a variable.

     Parameter  Description
  1  $xmm       Numbered xmm
  2  $offset    Offset in bytes

=head3 dFromX($xmm, $offset)

Get the double word from the numbered xmm register and return it in a variable.

     Parameter  Description
  1  $xmm       Numbered xmm
  2  $offset    Offset in bytes

=head3 qFromX($xmm, $offset)

Get the quad word from the numbered xmm register and return it in a variable.

     Parameter  Description
  1  $xmm       Numbered xmm
  2  $offset    Offset in bytes

=head3 bFromZ($zmm, $offset)

Get the byte from the numbered zmm register and return it in a variable.

     Parameter  Description
  1  $zmm       Numbered zmm
  2  $offset    Offset in bytes

=head3 wFromZ($zmm, $offset)

Get the word from the numbered zmm register and return it in a variable.

     Parameter  Description
  1  $zmm       Numbered zmm
  2  $offset    Offset in bytes

=head3 dFromZ($zmm, $offset)

Get the double word from the numbered zmm register and return it in a variable.

     Parameter  Description
  1  $zmm       Numbered zmm
  2  $offset    Offset in bytes

=head3 qFromZ($zmm, $offset)

Get the quad word from the numbered zmm register and return it in a variable.

     Parameter  Description
  1  $zmm       Numbered zmm
  2  $offset    Offset in bytes

=head2 Mask

Operations on mask registers

=head3 CheckMaskRegister($reg)

Check that a register is in fact a numbered mask register

     Parameter  Description
  1  $reg       Register to check

=head3 CheckIfMaskRegisterNumber($mask)

Check that a register is in fact a mask register.

     Parameter  Description
  1  $mask      Mask register to check

=head3 CheckMaskRegisterNumber($mask)

Check that a register is in fact a mask register and confess if it is not.

     Parameter  Description
  1  $mask      Mask register to check

=head3 SetMaskRegister($mask, $start, $length)

Set the mask register to ones starting at the specified position for the specified length and zeroes elsewhere.

     Parameter  Description
  1  $mask      Number of mask register to set
  2  $start     Register containing start position or 0 for position 0
  3  $length    Register containing end position

B<Example:>


    Mov rax, 8;
    Mov rsi, -1;

    Inc rsi; SetMaskRegister(0, rax, rsi); PrintOutRegisterInHex k0;  # 


    Inc rsi; SetMaskRegister(1, rax, rsi); PrintOutRegisterInHex k1;  # 


    Inc rsi; SetMaskRegister(2, rax, rsi); PrintOutRegisterInHex k2;  # 


    Inc rsi; SetMaskRegister(3, rax, rsi); PrintOutRegisterInHex k3;  # 


    Inc rsi; SetMaskRegister(4, rax, rsi); PrintOutRegisterInHex k4;  # 


    Inc rsi; SetMaskRegister(5, rax, rsi); PrintOutRegisterInHex k5;  # 


    Inc rsi; SetMaskRegister(6, rax, rsi); PrintOutRegisterInHex k6;  # 


    Inc rsi; SetMaskRegister(7, rax, rsi); PrintOutRegisterInHex k7;  # 


    ok Assemble(debug => 0, eq => <<END, avx512=>0);
      k0: 0000 0000 0000 0000
      k1: 0000 0000 0000 0100
      k2: 0000 0000 0000 0300
      k3: 0000 0000 0000 0700
      k4: 0000 0000 0000 0F00
      k5: 0000 0000 0000 1F00
      k6: 0000 0000 0000 3F00
      k7: 0000 0000 0000 7F00
  END


=head3 LoadConstantIntoMaskRegister($mask, $value)

Set a mask register equal to a constant.

     Parameter  Description
  1  $mask      Number of mask register to load
  2  $value     Constant to load

=head3 createBitNumberFromAlternatingPattern($prefix, @values)

Create a number from a bit pattern.

     Parameter  Description
  1  $prefix    Prefix bits
  2  @values    +n 1 bits -n 0 bits

=head3 LoadBitsIntoMaskRegister($mask, $prefix, @values)

Load a bit string specification into a mask register in two clocks.

     Parameter  Description
  1  $mask      Number of mask register to load
  2  $prefix    Prefix bits
  3  @values    +n 1 bits -n 0 bits

B<Example:>


    for (0..7)
     {ClearRegisters "k$_";
      K($_,$_)->setMaskBit("k$_");
      PrintOutRegisterInHex "k$_";
     }

    ClearRegisters k7;

    LoadBitsIntoMaskRegister(7, '1010', -4, +4, -2, +2, -1, +1, -1, +1);  # 

    PrintOutRegisterInHex "k7";

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
      k0: 0000 0000 0000 0001
      k1: 0000 0000 0000 0002
      k2: 0000 0000 0000 0004
      k3: 0000 0000 0000 0008
      k4: 0000 0000 0000 0010
      k5: 0000 0000 0000 0020
      k6: 0000 0000 0000 0040
      k7: 0000 0000 0000 0080
      k7: 0000 0000 000A 0F35
  END


=head1 Comparison codes

The codes used to specify what sort of comparison to perform

=head1 Structured Programming

Structured programming constructs

=head2 If($jump, $then, $else)

If statement.

     Parameter  Description
  1  $jump      Jump op code of variable
  2  $then      Then - required
  3  $else      Else - optional

B<Example:>


    my $c = K(one,1);

    If ($c == 0,  # 

    Then
     {PrintOutStringNL "1 == 0";
     },
    Else
     {PrintOutStringNL "1 != 0";
     });

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  1 != 0
  END


=head2 Then($block)

Then block for an If statement.

     Parameter  Description
  1  $block     Then block

B<Example:>


    my $a = V(a, 3);  $a->outNL;
    my $b = K(b, 2);  $b->outNL;
    my $c = $a +  $b; $c->outNL;
    my $d = $c -  $a; $d->outNL;
    my $g = $a *  $b; $g->outNL;
    my $h = $g /  $b; $h->outNL;
    my $i = $a %  $b; $i->outNL;

    If ($a == 3,

    Then  # 

     {PrintOutStringNL "a == 3"
     },
    Else
     {PrintOutStringNL "a != 3"
     });

    ++$a; $a->outNL;
    --$a; $a->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  a: 0000 0000 0000 0003
  b: 0000 0000 0000 0002
  (a add b): 0000 0000 0000 0005
  ((a add b) sub a): 0000 0000 0000 0002
  (a times b): 0000 0000 0000 0006
  ((a times b) / b): 0000 0000 0000 0003
  (a % b): 0000 0000 0000 0001
  a == 3
  a: 0000 0000 0000 0004
  a: 0000 0000 0000 0003
  END


=head2 Else($block)

Else block for an If statement.

     Parameter  Description
  1  $block     Else block

B<Example:>


    my $a = V(a, 3);  $a->outNL;
    my $b = K(b, 2);  $b->outNL;
    my $c = $a +  $b; $c->outNL;
    my $d = $c -  $a; $d->outNL;
    my $g = $a *  $b; $g->outNL;
    my $h = $g /  $b; $h->outNL;
    my $i = $a %  $b; $i->outNL;

    If ($a == 3,
    Then
     {PrintOutStringNL "a == 3"
     },

    Else  # 

     {PrintOutStringNL "a != 3"
     });

    ++$a; $a->outNL;
    --$a; $a->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  a: 0000 0000 0000 0003
  b: 0000 0000 0000 0002
  (a add b): 0000 0000 0000 0005
  ((a add b) sub a): 0000 0000 0000 0002
  (a times b): 0000 0000 0000 0006
  ((a times b) / b): 0000 0000 0000 0003
  (a % b): 0000 0000 0000 0001
  a == 3
  a: 0000 0000 0000 0004
  a: 0000 0000 0000 0003
  END


=head2 Ef($condition, $then, $else)

Else if block for an If statement.

     Parameter   Description
  1  $condition  Condition
  2  $then       Then block
  3  $else       Else block

=head2 IfEq($then, $else)

If equal execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    my $cmp = sub
     {my ($a, $b) = @_;

      for my $op(qw(eq ne lt le gt ge))
       {Mov rax, $a;
        Cmp rax, $b;
        my $Op = ucfirst $op;
        eval qq(If$Op Then {PrintOutStringNL("$a $op $b")}, Else {PrintOutStringNL("$a NOT $op $b")});
        $@ and confess $@;
       }
     };
    &$cmp(1,1);
    &$cmp(1,2);
    &$cmp(3,2);
    Assemble(debug => 0, eq => <<END, avx512=>0);
  1 eq 1
  1 NOT ne 1
  1 NOT lt 1
  1 le 1
  1 NOT gt 1
  1 ge 1
  1 NOT eq 2
  1 ne 2
  1 lt 2
  1 le 2
  1 NOT gt 2
  1 NOT ge 2
  3 NOT eq 2
  3 ne 2
  3 NOT lt 2
  3 NOT le 2
  3 gt 2
  3 ge 2
  END


=head2 IfNe($then, $else)

If not equal execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    my $cmp = sub
     {my ($a, $b) = @_;

      for my $op(qw(eq ne lt le gt ge))
       {Mov rax, $a;
        Cmp rax, $b;
        my $Op = ucfirst $op;
        eval qq(If$Op Then {PrintOutStringNL("$a $op $b")}, Else {PrintOutStringNL("$a NOT $op $b")});
        $@ and confess $@;
       }
     };
    &$cmp(1,1);
    &$cmp(1,2);
    &$cmp(3,2);
    Assemble(debug => 0, eq => <<END, avx512=>0);
  1 eq 1
  1 NOT ne 1
  1 NOT lt 1
  1 le 1
  1 NOT gt 1
  1 ge 1
  1 NOT eq 2
  1 ne 2
  1 lt 2
  1 le 2
  1 NOT gt 2
  1 NOT ge 2
  3 NOT eq 2
  3 ne 2
  3 NOT lt 2
  3 NOT le 2
  3 gt 2
  3 ge 2
  END


=head2 IfNz($then, $else)

If the zero flag is not set then execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    Mov rax, 0;
    Test rax,rax;

    IfNz  # 

    Then
     {PrintOutRegisterInHex rax;
     },
    Else
     {PrintOutRegisterInHex rbx;
     };
    Mov rax, 1;
    Test rax,rax;

    IfNz  # 

    Then
     {PrintOutRegisterInHex rcx;
     },
    Else
     {PrintOutRegisterInHex rdx;
     };

    ok Assemble =~ m(rbx.*rcx)s;


=head2 IfZ($then, $else)

If the zero flag is set then execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    SetZF;
    PrintOutZF;
    ClearZF;
    PrintOutZF;
    SetZF;
    PrintOutZF;
    SetZF;
    PrintOutZF;
    ClearZF;
    PrintOutZF;

    SetZF;

    IfZ  Then {PrintOutStringNL "Zero"},     Else {PrintOutStringNL "NOT zero"};# 

    ClearZF;
    IfNz Then {PrintOutStringNL "NOT zero"}, Else {PrintOutStringNL "Zero"};

    Mov r15, 5;
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};
    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  Zero
  NOT zero
  Carry
  NO carry
  Carry
  NO carry
  END


=head2 IfC($then, $else)

If the carry flag is set then execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    SetZF;
    PrintOutZF;
    ClearZF;
    PrintOutZF;
    SetZF;
    PrintOutZF;
    SetZF;
    PrintOutZF;
    ClearZF;
    PrintOutZF;

    SetZF;
    IfZ  Then {PrintOutStringNL "Zero"},     Else {PrintOutStringNL "NOT zero"};
    ClearZF;
    IfNz Then {PrintOutStringNL "NOT zero"}, Else {PrintOutStringNL "Zero"};

    Mov r15, 5;

    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};  # 


    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};  # 

    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};
    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  Zero
  NOT zero
  Carry
  NO carry
  Carry
  NO carry
  END


=head2 IfNc($then, $else)

If the carry flag is not set then execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    SetZF;
    PrintOutZF;
    ClearZF;
    PrintOutZF;
    SetZF;
    PrintOutZF;
    SetZF;
    PrintOutZF;
    ClearZF;
    PrintOutZF;

    SetZF;
    IfZ  Then {PrintOutStringNL "Zero"},     Else {PrintOutStringNL "NOT zero"};
    ClearZF;
    IfNz Then {PrintOutStringNL "NOT zero"}, Else {PrintOutStringNL "Zero"};

    Mov r15, 5;
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};

    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};  # 


    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};  # 


    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  Zero
  NOT zero
  Carry
  NO carry
  Carry
  NO carry
  END


=head2 IfLt($then, $else)

If less than execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    my $cmp = sub
     {my ($a, $b) = @_;

      for my $op(qw(eq ne lt le gt ge))
       {Mov rax, $a;
        Cmp rax, $b;
        my $Op = ucfirst $op;
        eval qq(If$Op Then {PrintOutStringNL("$a $op $b")}, Else {PrintOutStringNL("$a NOT $op $b")});
        $@ and confess $@;
       }
     };
    &$cmp(1,1);
    &$cmp(1,2);
    &$cmp(3,2);
    Assemble(debug => 0, eq => <<END, avx512=>0);
  1 eq 1
  1 NOT ne 1
  1 NOT lt 1
  1 le 1
  1 NOT gt 1
  1 ge 1
  1 NOT eq 2
  1 ne 2
  1 lt 2
  1 le 2
  1 NOT gt 2
  1 NOT ge 2
  3 NOT eq 2
  3 ne 2
  3 NOT lt 2
  3 NOT le 2
  3 gt 2
  3 ge 2
  END


=head2 IfLe($then, $else)

If less than or equal execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    my $cmp = sub
     {my ($a, $b) = @_;

      for my $op(qw(eq ne lt le gt ge))
       {Mov rax, $a;
        Cmp rax, $b;
        my $Op = ucfirst $op;
        eval qq(If$Op Then {PrintOutStringNL("$a $op $b")}, Else {PrintOutStringNL("$a NOT $op $b")});
        $@ and confess $@;
       }
     };
    &$cmp(1,1);
    &$cmp(1,2);
    &$cmp(3,2);
    Assemble(debug => 0, eq => <<END, avx512=>0);
  1 eq 1
  1 NOT ne 1
  1 NOT lt 1
  1 le 1
  1 NOT gt 1
  1 ge 1
  1 NOT eq 2
  1 ne 2
  1 lt 2
  1 le 2
  1 NOT gt 2
  1 NOT ge 2
  3 NOT eq 2
  3 ne 2
  3 NOT lt 2
  3 NOT le 2
  3 gt 2
  3 ge 2
  END


=head2 IfGt($then, $else)

If greater than execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    my $cmp = sub
     {my ($a, $b) = @_;

      for my $op(qw(eq ne lt le gt ge))
       {Mov rax, $a;
        Cmp rax, $b;
        my $Op = ucfirst $op;
        eval qq(If$Op Then {PrintOutStringNL("$a $op $b")}, Else {PrintOutStringNL("$a NOT $op $b")});
        $@ and confess $@;
       }
     };
    &$cmp(1,1);
    &$cmp(1,2);
    &$cmp(3,2);
    Assemble(debug => 0, eq => <<END, avx512=>0);
  1 eq 1
  1 NOT ne 1
  1 NOT lt 1
  1 le 1
  1 NOT gt 1
  1 ge 1
  1 NOT eq 2
  1 ne 2
  1 lt 2
  1 le 2
  1 NOT gt 2
  1 NOT ge 2
  3 NOT eq 2
  3 ne 2
  3 NOT lt 2
  3 NOT le 2
  3 gt 2
  3 ge 2
  END


=head2 IfGe($then, $else)

If greater than or equal execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

B<Example:>


    my $cmp = sub
     {my ($a, $b) = @_;

      for my $op(qw(eq ne lt le gt ge))
       {Mov rax, $a;
        Cmp rax, $b;
        my $Op = ucfirst $op;
        eval qq(If$Op Then {PrintOutStringNL("$a $op $b")}, Else {PrintOutStringNL("$a NOT $op $b")});
        $@ and confess $@;
       }
     };
    &$cmp(1,1);
    &$cmp(1,2);
    &$cmp(3,2);
    Assemble(debug => 0, eq => <<END, avx512=>0);
  1 eq 1
  1 NOT ne 1
  1 NOT lt 1
  1 le 1
  1 NOT gt 1
  1 ge 1
  1 NOT eq 2
  1 ne 2
  1 lt 2
  1 le 2
  1 NOT gt 2
  1 NOT ge 2
  3 NOT eq 2
  3 ne 2
  3 NOT lt 2
  3 NOT le 2
  3 gt 2
  3 ge 2
  END


=head2 IfS($then, $else)

If signed greater than or equal execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

=head2 IfNs($then, $else)

If signed less than execute the then block else the else block.

     Parameter  Description
  1  $then      Then - required
  2  $else      Else - optional

=head2 Pass($block)

Pass block for an L<OrBlock>.

     Parameter  Description
  1  $block     Block

B<Example:>


    Mov rax, 1;
    OrBlock
     {my ($pass, $end, $start) = @_;
      Cmp rax, 1;
      Je  $pass;
      Cmp rax, 2;
      Je  $pass;
      PrintOutStringNL "Fail";
     }

    Pass  # 

     {my ($end, $pass, $start) = @_;

      PrintOutStringNL "Pass";  # 

     };

    ok Assemble(debug => 0, eq => <<END, avx512=>0);

  Pass  # 

  END


=head2 Fail($block)

Fail block for an L<AndBlock>.

     Parameter  Description
  1  $block     Block

B<Example:>


    Mov rax, 1; Mov rdx, 2;
    AndBlock
     {my ($fail, $end, $start) = @_;
      Cmp rax, 1;
      Jne $fail;
      Cmp rdx, 2;
      Jne $fail;
      PrintOutStringNL "Pass";
     }

    Fail  # 

     {my ($end, $fail, $start) = @_;

      PrintOutStringNL "Fail";  # 

     };

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  Pass
  END


=head2 Block($code)

Execute a block of code with labels supplied for the start and end of this code

     Parameter  Description
  1  $code      Block of code

=head2 AndBlock($test, $fail)

Short circuit B<and>: execute a block of code to test conditions which, if all of them pass, allows the first block to continue successfully else if one of the conditions fails we execute the optional fail block.

     Parameter  Description
  1  $test      Block
  2  $fail      Optional failure block

B<Example:>


    Mov rax, 1; Mov rdx, 2;

    AndBlock  # 

     {my ($fail, $end, $start) = @_;
      Cmp rax, 1;
      Jne $fail;
      Cmp rdx, 2;
      Jne $fail;
      PrintOutStringNL "Pass";
     }
    Fail
     {my ($end, $fail, $start) = @_;
      PrintOutStringNL "Fail";
     };

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  Pass
  END


=head2 OrBlock($test, $pass)

Short circuit B<or>: execute a block of code to test conditions which, if one of them is met, leads on to the execution of the pass block, if all of the tests fail we continue withe the test block.

     Parameter  Description
  1  $test      Tests
  2  $pass      Optional block to execute on success

B<Example:>


    Mov rax, 1;

    OrBlock  # 

     {my ($pass, $end, $start) = @_;
      Cmp rax, 1;
      Je  $pass;
      Cmp rax, 2;
      Je  $pass;
      PrintOutStringNL "Fail";
     }
    Pass
     {my ($end, $pass, $start) = @_;
      PrintOutStringNL "Pass";
     };

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  Pass
  END


=head2 For($block, $register, $limit, $increment)

For - iterate the block as long as register is less than limit incrementing by increment each time. Nota Bene: The register is not explicitly set to zero as you might want to start at some other number.

     Parameter   Description
  1  $block      Block
  2  $register   Register
  3  $limit      Limit on loop
  4  $increment  Increment on each iteration

B<Example:>



    For  # 

     {my ($start, $end, $next) = @_;
      Cmp rax, 3;
      Jge $end;
      PrintOutRegisterInHex rax;
     } rax, 16, 1;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0000
     rax: 0000 0000 0000 0001
     rax: 0000 0000 0000 0002
  END


=head2 ForIn($full, $last, $register, $limitRegister, $increment)

For - iterate the full block as long as register plus increment is less than than limit incrementing by increment each time then increment the last block for the last non full block.

     Parameter       Description
  1  $full           Block for full block
  2  $last           Block for last block
  3  $register       Register
  4  $limitRegister  Register containing upper limit of loop
  5  $increment      Increment on each iteration

=head2 ForEver($block)

Iterate for ever.

     Parameter  Description
  1  $block     Block to iterate

=head2 Call

Call a subroutine

=head3 SubroutineStartStack()

Initialize a new stack frame.  The first quad of each frame has the address of the name of the sub in the low dword, and the parameter count in the upper byte of the quad.  This field is all zeroes in the initial frame.


=head3 Nasm::X86::Sub::call($sub, @parameters)

Call a sub passing it some parameters.

     Parameter    Description
  1  $sub         Subroutine descriptor
  2  @parameters  Parameter variables

=head3 Nasm::X86::Sub::via($sub, $ref, @parameters)

Call a sub by reference passing it some parameters.

     Parameter    Description
  1  $sub         Subroutine descriptor
  2  $ref         Variable containing a reference to the sub
  3  @parameters  Parameter variables

=head3 Nasm::X86::Sub::V($sub)

Put the address of a subroutine into a stack variable so that it can be passed as a parameter.

     Parameter  Description
  1  $sub       Subroutine descriptor

=head3 Nasm::X86::Sub::dispatch($sub)

Jump into the specified subroutine so that code of the target subroutine is executed instead of the code of the current subroutine allowing the target subroutine to be dispatched to process the parameter list of the current subroutine.  When the target subroutine returns it returns to the caller of the current sub, not to the current subroutine.

     Parameter  Description
  1  $sub       Subroutine descriptor of target subroutine

B<Example:>


    my $p = Subroutine                                                          # Prototype subroutine to establish parameter list
     {} [qw(p)], name => 'prototype';

    my $a = Subroutine                                                          # Subroutine we are actually going to call
     {$p->variables->{p}->outNL;
     } [], name => 'actual', with => $p;

    my $d = Subroutine                                                          # Dispatcher
     {my ($p, $s) = @_;
      $a->dispatch;
      PrintOutStringNL "This should NOT happen!";
     } [], name => 'dispatch', with => $p;

    $d->call(p => 0xcc);
    PrintOutStringNL "This should happen!";

    ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
  p: 0000 0000 0000 00CC
  This should happen!
  END


=head3 Nasm::X86::Sub::dispatchV($sub, $reference)

L<Dispatch|/Nasm::X86::Sub::dispatch> the variable subroutine using the specified register.

     Parameter   Description
  1  $sub        Subroutine descriptor
  2  $reference  Variable referring to the target subroutine

B<Example:>


    my $s = Subroutine                                                          # Containing sub
     {my ($parameters, $sub) = @_;

      my $p = Subroutine                                                        # Prototype subroutine with cascading parameter lists
       {} [qw(q)], with => $sub, name => 'prototype';

      my $a = Subroutine                                                        # Subroutine we are actually going to call with extended parameter list
       {$p->variables->{p}->outNL;
        $p->variables->{q}->outNL;
       } [], name => 'actual', with => $p;

      my $d = Subroutine                                                        # Dispatcher
       {my ($p, $s) = @_;
        $a->dispatchV($a->V);
        PrintOutStringNL "This should NOT happen!";
       } [], name => 'dispatch', with => $p;

      $d->call(q => 0xdd) ;                                                     # Extend cascading parameter list
     } [qw(p)], name => 'outer';

    $s->call(p => 0xcc);                                                        # Start cascading parameter list
    PrintOutStringNL "This should happen!";

    ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
  p: 0000 0000 0000 00CC
  q: 0000 0000 0000 00DD
  This should happen!
  END


=head3 PrintTraceBack($channel)

Trace the call stack.

     Parameter  Description
  1  $channel   Channel to write on

=head3 PrintErrTraceBack($message)

Print sub routine track back on stderr and then exit with a message.

     Parameter  Description
  1  $message   Reason why we are printing the trace back and then stopping

=head3 PrintOutTraceBack($message)

Print sub routine track back on stdout and then exit with a message.

     Parameter  Description
  1  $message   Reason why we are printing the trace back and then stopping

B<Example:>


    my $d = V depth => 3;                                                       # Create a variable on the stack

    my $s = Subroutine
     {my ($p, $s, $sub) = @_;                                                   # Parameters, structures, subroutine descriptor

      my $d = $$p{depth}->copy($$p{depth} - 1);                                 # Modify the variable referenced by the parameter

      If $d > 0,
      Then
       {$sub->call(parameters => {depth => $d});                                # Recurse
       };


      #PrintOutTraceBack 'AAAA';  # 

     } parameters =>[qw(depth)], name => 'ref';

    $s->call(parameters=>{depth => V depth => 0});

    ok Assemble(debug => 0, eq => <<END, avx512=>0);

  Subroutine trace back, depth:  3
  0000 0000 0000 0001    ref
  0000 0000 0000 0001    ref
  0000 0000 0000 0001    ref
  END


=head3 OnSegv()

Request a trace back followed by exit on a B<segv> signal.


B<Example:>



    OnSegv();                                                                   # Request a trace back followed by exit on a segv signal.  # 


    my $t = Subroutine                                                          # Subroutine that will cause an error to occur to force a trace back to be printed
     {Mov r15, 0;
      Mov r15, "[r15]";                                                         # Try to read an unmapped memory location
     } [qw(in)], name => 'sub that causes a segv';                              # The name that will appear in the trace back

    $t->call(K(in, 42));

    ok Assemble(debug => 0, keep2 => 'signal', avx512=>0, eq => <<END, avx512=>0);         # Cannot use the emulator because it does not understand signals

  Subroutine trace back, depth:  1
  0000 0000 0000 002A    sub that causes a segv

  END


=head3 copyStructureMinusVariables($s)

Copy a non recursive structure ignoring variables

     Parameter  Description
  1  $s         Structure to copy

=head3 Subroutine($block, %options)

Create a subroutine that can be called in assembler code.

     Parameter  Description
  1  $block     Block of code as a sub
  2  %options   Options

B<Example:>


    my $g = V g => 3;

    my $s = Subroutine  # 

     {my ($p, $s, $sub) = @_;
      my $g = $$p{g};
      $g->copy($g - 1);
      $g->outNL;
      If ($g > 0,
      Then
       {$sub->call(parameters=>{g => $g});
       });
     } parameters=>[qw(g)], name => 'ref';

    $s->call(parameters=>{g => $g});

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  g: 0000 0000 0000 0002
  g: 0000 0000 0000 0001
  g: 0000 0000 0000 0000
  END

    my $g = V g, 2;
    my $u = Subroutine33
     {my ($p, $s) = @_;
      $$p{g}->copy(K gg, 1);
      PrintOutTraceBack '';
     } [qw(g)], name => 'uuuu';
    my $t = Subroutine33
     {my ($p, $s) = @_;
      $u->call($$p{g});
     } [qw(g)], name => 'tttt';
    my $s = Subroutine33
     {my ($p, $s) = @_;
      $t->call($$p{g});
     } [qw(g)], name => 'ssss';

    $g->outNL;
    $s->call($g);
    $g->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);

  Subroutine trace back, depth:  3  # 

  0000 0000 0000 0002    uuuu
  0000 0000 0000 0002    tttt
  0000 0000 0000 0002    ssss
  END

    my $r = V r, 2;

    my $u = Subroutine33
     {my ($p, $s) = @_;
      $$p{u}->copy(K gg, 1);
      PrintOutTraceBack '';
     } [qw(u)], name => 'uuuu';

    my $t = Subroutine33
     {my ($p, $s) = @_;
      $u->call(u => $$p{t});
     } [qw(t)], name => 'tttt';

    my $s = Subroutine33
     {my ($p, $s) = @_;
     $t->call(t => $$p{s});
     } [qw(s)], name => 'ssss';

    $r->outNL;
    $s->call(s=>$r);
    $r->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  r: 0000 0000 0000 0002


  Subroutine trace back, depth:  3  # 

  0000 0000 0000 0002    uuuu
  0000 0000 0000 0002    tttt
  0000 0000 0000 0002    ssss



  Subroutine trace back, depth:  3  # 

  0000 0000 0000 0001    uuuu
  0000 0000 0000 0001    tttt
  0000 0000 0000 0001    ssss

  r: 0000 0000 0000 0001
  END


=head3 Nasm::X86::Subroutine::mapStructureVariables($sub, $S, @P)

Find the paths to variables in the copies of the structures passed as parameters and replace those variables with references so that in the subroutine we can refer to these variables regardless of where they are actually defined

     Parameter  Description
  1  $sub       Sub definition
  2  $S         Copies of source structures
  3  @P         Path through copies of source structures to a variable that becomes a reference

=head3 Nasm::X86::Subroutine::uploadStructureVariablesToNewStackFrame($sub, $S, @P)

Create references to variables in parameter structures from variables in the stack frame of the subroutine.

     Parameter  Description
  1  $sub       Sub definition
  2  $S         Source tree of input structures
  3  @P         Path through sourtce structures tree

=head1 Comments

Inserts comments into the generated assember code.

=head2 CommentWithTraceBack(@comment)

Insert a comment into the assembly code with a traceback showing how it was generated.

     Parameter  Description
  1  @comment   Text of comment

=head2 Comment(@comment)

Insert a comment into the assembly code.

     Parameter  Description
  1  @comment   Text of comment

B<Example:>



    Comment "Print a string from memory";  # 

    my $s = "Hello World";
    Mov rax, Rs($s);
    Mov rdi, length $s;
    PrintOutMemory;
    Exit(0);

    ok Assemble =~ m(Hello World);


=head2 DComment(@comment)

Insert a comment into the data segment.

     Parameter  Description
  1  @comment   Text of comment

=head2 RComment(@comment)

Insert a comment into the read only data segment.

     Parameter  Description
  1  @comment   Text of comment

=head1 Print

Print

=head2 PrintNL($channel)

Print a new line to stdout  or stderr.

     Parameter  Description
  1  $channel   Channel to write on

=head2 PrintErrNL()

Print a new line to stderr.


=head2 PrintOutNL()

Print a new line to stderr.


B<Example:>


    my $q = Rs('abababab');
    Mov(rax, "[$q]");
    PrintOutString "rax: ";
    PrintOutRaxInHex;

    PrintOutNL;  # 

    Xor rax, rax;
    PrintOutString "rax: ";
    PrintOutRaxInHex;

    PrintOutNL;  # 


    ok Assemble =~ m(rax: 6261 6261 6261 6261.*rax: 0000 0000 0000 0000)s;


=head2 PrintString($channel, @string)

Print a constant string to the specified channel.

     Parameter  Description
  1  $channel   Channel
  2  @string    Strings

=head2 PrintStringNL($channel, @string)

Print a constant string to the specified channel followed by a new line.

     Parameter  Description
  1  $channel   Channel
  2  @string    Strings

=head2 PrintErrString(@string)

Print a constant string to stderr.

     Parameter  Description
  1  @string    String

=head2 PrintErrStringNL(@string)

Print a constant string to stderr followed by a new line.

     Parameter  Description
  1  @string    String

B<Example:>


    PrintOutStringNL "Hello World";
    PrintOutStringNL "Hello
World";

    PrintErrStringNL "Hello World";  # 


    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  Hello World
  Hello
  World
  END


=head2 PrintOutString(@string)

Print a constant string to stdout.

     Parameter  Description
  1  @string    String

B<Example:>


    my $q = Rs('abababab');
    Mov(rax, "[$q]");

    PrintOutString "rax: ";  # 

    PrintOutRaxInHex;
    PrintOutNL;
    Xor rax, rax;

    PrintOutString "rax: ";  # 

    PrintOutRaxInHex;
    PrintOutNL;

    ok Assemble =~ m(rax: 6261 6261 6261 6261.*rax: 0000 0000 0000 0000)s;


=head2 PrintOutStringNL(@string)

Print a constant string to stdout followed by a new line.

     Parameter  Description
  1  @string    String

B<Example:>



    PrintOutStringNL "Hello World";  # 


    PrintOutStringNL "Hello
World";  # 

    PrintErrStringNL "Hello World";

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  Hello World
  Hello
  World
  END


=head2 PrintCString($channel, $string)

Print a zero terminated C style string addressed by a variable on the specified channel.

     Parameter  Description
  1  $channel   Channel
  2  $string    String

=head2 PrintCStringNL($channel, $string)

Print a zero terminated C style string addressed by a variable on the specified channel followed by a new line.

     Parameter  Description
  1  $channel   Channel
  2  $string    Strings

=head2 PrintSpace($channel, $spaces)

Print a constant number of spaces to the specified channel.

     Parameter  Description
  1  $channel   Channel
  2  $spaces    Number of spaces if not one.

=head2 PrintErrSpace($spaces)

Print  a constant number of spaces to stderr.

     Parameter  Description
  1  $spaces    Number of spaces if not one.

=head2 PrintOutSpace($spaces)

Print a constant number of spaces to stdout.

     Parameter  Description
  1  $spaces    Number of spaces if not one.

=head2 PrintRaxInHex($channel, $end)

Write the content of register rax in hexadecimal in big endian notation to the specified channel.

     Parameter  Description
  1  $channel   Channel
  2  $end       Optional end byte

=head2 PrintErrRaxInHex()

Write the content of register rax in hexadecimal in big endian notation to stderr.


=head2 PrintErrRaxInHexNL()

Write the content of register rax in hexadecimal in big endian notation to stderr followed by a new line.


=head2 PrintOutRaxInHex()

Write the content of register rax in hexadecimal in big endian notation to stout.


B<Example:>


    my $q = Rs('abababab');
    Mov(rax, "[$q]");
    PrintOutString "rax: ";

    PrintOutRaxInHex;  # 

    PrintOutNL;
    Xor rax, rax;
    PrintOutString "rax: ";

    PrintOutRaxInHex;  # 

    PrintOutNL;

    ok Assemble =~ m(rax: 6261 6261 6261 6261.*rax: 0000 0000 0000 0000)s;


=head2 PrintOutRaxInHexNL()

Write the content of register rax in hexadecimal in big endian notation to stdout followed by a new line.


=head2 PrintRax_InHex($channel, $end)

Write the content of register rax in hexadecimal in big endian notation to the specified channel replacing zero bytes with __.

     Parameter  Description
  1  $channel   Channel
  2  $end       Optional end byte

=head2 PrintErrRax_InHex()

Write the content of register rax in hexadecimal in big endian notation to stderr.


=head2 PrintErrRax_InHexNL()

Write the content of register rax in hexadecimal in big endian notation to stderr followed by a new line.


=head2 PrintOutRax_InHex()

Write the content of register rax in hexadecimal in big endian notation to stout.


=head2 PrintOutRax_InHexNL()

Write the content of register rax in hexadecimal in big endian notation to stdout followed by a new line.


=head2 PrintOutRaxInReverseInHex()

Write the content of register rax to stderr in hexadecimal in little endian notation.


B<Example:>


    Mov rax, 0x07654321;
    Shl rax, 32;
    Or  rax, 0x07654321;
    PushR rax;

    PrintOutRaxInHex;
    PrintOutNL;

    PrintOutRaxInReverseInHex;  # 

    PrintOutNL;

    Mov rax, rsp;
    Mov rdi, 8;
    PrintOutMemoryInHex;
    PrintOutNL;
    PopR rax;

    Mov rax, 4096;
    PushR rax;
    Mov rax, rsp;
    Mov rdi, 8;
    PrintOutMemoryInHex;
    PrintOutNL;
    PopR rax;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  0765 4321 0765 4321
  2143 6507 2143 6507
  2143 6507 2143 6507
  0010 0000 0000 0000
  END


=head2 PrintOneRegisterInHex($channel, $r)

Print the named register as a hex string.

     Parameter  Description
  1  $channel   Channel to print on
  2  $r         Register to print

=head2 PrintErrOneRegisterInHex($r)

Print the named register as a hex string on stderr.

     Parameter  Description
  1  $r         Register to print

=head2 PrintErrOneRegisterInHexNL($r)

Print the named register as a hex string on stderr followed by new line.

     Parameter  Description
  1  $r         Register to print

=head2 PrintOutOneRegisterInHex($r)

Print the named register as a hex string on stdout.

     Parameter  Description
  1  $r         Register to print

=head2 PrintOutOneRegisterInHexNL($r)

Print the named register as a hex string on stdout followed by new line.

     Parameter  Description
  1  $r         Register to print

=head2 PrintRegisterInHex($channel, @r)

Print the named registers as hex strings.

     Parameter  Description
  1  $channel   Channel to print on
  2  @r         Names of the registers to print

=head2 PrintErrRegisterInHex(@r)

Print the named registers as hex strings on stderr.

     Parameter  Description
  1  @r         Names of the registers to print

=head2 PrintOutRegisterInHex(@r)

Print the named registers as hex strings on stdout.

     Parameter  Description
  1  @r         Names of the registers to print

B<Example:>


    my $q = Rs(('a'..'p')x4);
    Mov r8,"[$q]";

    PrintOutRegisterInHex r8;  # 


    ok Assemble(debug => 0, eq => <<END, avx512=>0);
      r8: 6867 6665 6463 6261
  END


=head2 PrintOutRegistersInHex()

Print the general purpose registers in hex.


B<Example:>


    my $q = Rs('abababab');
    Mov(rax, 1);
    Mov(rbx, 2);
    Mov(rcx, 3);
    Mov(rdx, 4);
    Mov(r8,  5);
    Lea r9,  "[rax+rbx]";

    PrintOutRegistersInHex;  # 


    my $r = Assemble;
    ok $r =~ m( r8: 0000 0000 0000 0005.* r9: 0000 0000 0000 0003.*rax: 0000 0000 0000 0001)s;
    ok $r =~ m(rbx: 0000 0000 0000 0002.*rcx: 0000 0000 0000 0003.*rdx: 0000 0000 0000 0004)s;


=head2 PrintErrZF()

Print the zero flag without disturbing it on stderr.


=head2 PrintOutZF()

Print the zero flag without disturbing it on stdout.


B<Example:>


    SetZF;

    PrintOutZF;  # 

    ClearZF;

    PrintOutZF;  # 

    SetZF;

    PrintOutZF;  # 

    SetZF;

    PrintOutZF;  # 

    ClearZF;

    PrintOutZF;  # 


    SetZF;
    IfZ  Then {PrintOutStringNL "Zero"},     Else {PrintOutStringNL "NOT zero"};
    ClearZF;
    IfNz Then {PrintOutStringNL "NOT zero"}, Else {PrintOutStringNL "Zero"};

    Mov r15, 5;
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
    Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};
    Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  Zero
  NOT zero
  Carry
  NO carry
  Carry
  NO carry
  END


=head2 Print hexadecimal

Print numbers in hexadecimal right justified in a field

=head3 PrintRightInHex($channel, $number, $width)

Print out a number in hex right justified in a field of specified width on the specified channel

     Parameter  Description
  1  $channel   Channel
  2  $number    Number as a variable
  3  $width     Width of output field as a variable

=head3 PrintErrRightInHex($number, $width)

Write the specified variable in hexadecimal right justified in a field of specified width on stderr.

     Parameter  Description
  1  $number    Number as a variable
  2  $width     Width of output field as a variable

=head3 PrintErrRightInHexNL($number, $width)

Write the specified variable in hexadecimal right justified in a field of specified width on stderr followed by a new line.

     Parameter  Description
  1  $number    Number as a variable
  2  $width     Width of output field as a variable

=head3 PrintOutRightInHex($number, $width)

Write the specified variable in hexadecimal right justified in a field of specified width on stdout.

     Parameter  Description
  1  $number    Number as a variable
  2  $width     Width of output field as a variable

=head3 PrintOutRightInHexNL($number, $width)

Write the specified variable in hexadecimal right justified in a field of specified width on stdout followed by a new line.

     Parameter  Description
  1  $number    Number as a variable
  2  $width     Width of output field as a variable

B<Example:>


    my $N = K number => 0x12345678;

    for my $i(reverse 1..16)

     {PrintOutRightInHexNL($N, K width => $i);  # 

     }
    ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
          12345678
         12345678
        12345678
       12345678
      12345678
     12345678
    12345678
   12345678
  12345678
  2345678
  345678
  45678
  5678
  678
  78
  8
  END


=head2 Print binary

Print numbers in binary right justified in a field

=head3 PrintRightInBin($channel, $number, $width)

Print out a number in hex right justified in a field of specified width on the specified channel

     Parameter  Description
  1  $channel   Channel
  2  $number    Number as a variable
  3  $width     Width of output field as a variable

=head3 PrintErrRightInBin($number, $width)

Write the specified variable in binary right justified in a field of specified width on stderr.

     Parameter  Description
  1  $number    Number as a variable
  2  $width     Width of output field as a variable

=head3 PrintErrRightInBinNL($number, $width)

Write the specified variable in binary right justified in a field of specified width on stderr followed by a new line.

     Parameter  Description
  1  $number    Number as a variable
  2  $width     Width of output field as a variable

=head3 PrintOutRightInBin($number, $width)

Write the specified variable in binary right justified in a field of specified width on stdout.

     Parameter  Description
  1  $number    Number as a variable
  2  $width     Width of output field as a variable

=head3 PrintOutRightInBinNL($number, $width)

Write the specified variable in binary right justified in a field of specified width on stdout followed by a new line.

     Parameter  Description
  1  $number    Number as a variable
  2  $width     Width of output field as a variable

B<Example:>


    K(count => 64)->for(sub
     {my ($index, $start, $next, $end) = @_;

      PrintOutRightInBinNL K(number => 0x99), K(max => 64) - $index;  # 

     });
    ok Assemble(debug => 0, eq => <<END, avx512=>0);
                                                          10011001
                                                         10011001
                                                        10011001
                                                       10011001
                                                      10011001
                                                     10011001
                                                    10011001
                                                   10011001
                                                  10011001
                                                 10011001
                                                10011001
                                               10011001
                                              10011001
                                             10011001
                                            10011001
                                           10011001
                                          10011001
                                         10011001
                                        10011001
                                       10011001
                                      10011001
                                     10011001
                                    10011001
                                   10011001
                                  10011001
                                 10011001
                                10011001
                               10011001
                              10011001
                             10011001
                            10011001
                           10011001
                          10011001
                         10011001
                        10011001
                       10011001
                      10011001
                     10011001
                    10011001
                   10011001
                  10011001
                 10011001
                10011001
               10011001
              10011001
             10011001
            10011001
           10011001
          10011001
         10011001
        10011001
       10011001
      10011001
     10011001
    10011001
   10011001
  10011001
  0011001
  011001
  11001
  1001
  001
  01
  1
  END


=head2 Print in decimal

Print numbers in decimal right justified in fields of specified width.

=head3 PrintRaxInDec($channel)

Print rax in decimal on the specified channel.

     Parameter  Description
  1  $channel   Channel to write on

=head3 PrintOutRaxInDec()

Print rax in decimal on stdout.


=head3 PrintOutRaxInDecNL()

Print rax in decimal on stdout followed by a new line.


B<Example:>


    my $w = V width => 12;

    Mov rax, 0;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 0x2a;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 1;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 255;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 123456;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 1234567890;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 0x2;
    Shl rax, 16;
    Mov rdx, 0xdfdc;
    Or rax, rdx;
    Shl rax, 16;
    Mov rdx, 0x1c35;
    Or rax, rdx;
    PrintOutRaxRightInDecNL $w;

  # 1C BE99 1A14
    Mov rax, 0x1c;
    Shl rax, 16;
    Mov rdx, 0xbe99;
    Or rax, rdx;
    Shl rax, 16;
    Mov rdx, 0x1a14;
    Or rax, rdx;

    PrintOutRaxInDecNL;  # 


  # 2 EE33 3961
    Mov rax, 0x2;
    Shl rax, 16;
    Mov rdx, 0xee33;
    Or rax, rdx;
    Shl rax, 16;
    Mov rdx, 0x3961;
    Or rax, rdx;
    PrintOutRaxRightInDecNL $w;

    ok Assemble eq => <<END;
             0
            42
             1
           255
        123456
    1234567890
   12345678901
  123456789012
   12586269025
  END


=head3 PrintErrRaxInDec()

Print rax in decimal on stderr.


=head3 PrintErrRaxInDecNL()

Print rax in decimal on stderr followed by a new line.


=head3 PrintRaxRightInDec($width, $channel)

Print rax in decimal right justified in a field of the specified width on the specified channel.

     Parameter  Description
  1  $width     Width
  2  $channel   Channel

=head3 PrintErrRaxRightInDec($width)

Print rax in decimal right justified in a field of the specified width on stderr.

     Parameter  Description
  1  $width     Width

=head3 PrintErrRaxRightInDecNL($width)

Print rax in decimal right justified in a field of the specified width on stderr followed by a new line.

     Parameter  Description
  1  $width     Width

=head3 PrintOutRaxRightInDec($width)

Print rax in decimal right justified in a field of the specified width on stdout.

     Parameter  Description
  1  $width     Width

B<Example:>


    my $w = V width => 12;

    Mov rax, 0;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 0x2a;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 1;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 255;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 123456;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 1234567890;
    PrintOutRaxRightInDecNL $w;

    Mov rax, 0x2;
    Shl rax, 16;
    Mov rdx, 0xdfdc;
    Or rax, rdx;
    Shl rax, 16;
    Mov rdx, 0x1c35;
    Or rax, rdx;
    PrintOutRaxRightInDecNL $w;

  # 1C BE99 1A14
    Mov rax, 0x1c;
    Shl rax, 16;
    Mov rdx, 0xbe99;
    Or rax, rdx;
    Shl rax, 16;
    Mov rdx, 0x1a14;
    Or rax, rdx;
    PrintOutRaxInDecNL;

  # 2 EE33 3961
    Mov rax, 0x2;
    Shl rax, 16;
    Mov rdx, 0xee33;
    Or rax, rdx;
    Shl rax, 16;
    Mov rdx, 0x3961;
    Or rax, rdx;
    PrintOutRaxRightInDecNL $w;

    ok Assemble eq => <<END;
             0
            42
             1
           255
        123456
    1234567890
   12345678901
  123456789012
   12586269025
  END

    Mov rax, 0x2a;

    PrintOutRaxRightInDec   V width=> 4;  # 

    Shl rax, 1;
    PrintOutRaxRightInDecNL V width=> 6;

    ok Assemble eq => <<END;
    42    84
  END


=head3 PrintOutRaxRightInDecNL($width)

Print rax in decimal right justified in a field of the specified width on stdout followed by a new line.

     Parameter  Description
  1  $width     Width

B<Example:>


    Mov rax, 0x2a;
    PrintOutRaxRightInDec   V width=> 4;
    Shl rax, 1;

    PrintOutRaxRightInDecNL V width=> 6;  # 


    ok Assemble eq => <<END;
    42    84
  END


=head3 PrintRaxAsText($channel)

Print the string in rax on the specified channel.

     Parameter  Description
  1  $channel   Channel to write on

=head3 PrintOutRaxAsText()

Print rax as text on stdout.


=head3 PrintOutRaxAsTextNL()

Print rax as text on stdout followed by a new line.


B<Example:>


    my $t = Rs('abcdefghi');
    Mov rax, $t;
    Mov rax, "[rax]";

    PrintOutRaxAsTextNL;  # 

    ok Assemble eq => <<END;
  abcdefgh
  END
  }

  #latest:
  if (1) {                                                                         ;
    my $e = q(parameters);

    (V string => "[rbp+8]")->outInDecNL;
    (V string => "[rbp+16]")->outCStringNL;
    (V string => "[rbp+24]")->outCStringNL;
    (V string => "[rbp+32]")->outCStringNL;
    (V string => "[rbp+40]")->outCStringNL;
    (V string => "[rbp+48]")->outInDecNL;

    (V string => "[rbp+8]")->for(sub
     {my ($index, $start, $next, $end) = @_;
      $index->setReg(rax);
      Inc rax;
      PrintOutRaxInDec;
      Inc rax;
      PrintOutString " : ";
      Shl rax, 3;
      (V string => "[rbp+rax]")->outCStringNL;
     });

    Assemble keep => $e;

    is_deeply scalar(qx(./$e AaAaAaAaAa BbCcDdEe 123456789)), <<END;
  string: 4
  ./parameters
  AaAaAaAaAa
  BbCcDdEe
  123456789
  string: 0
  1 : ./parameters
  2 : AaAaAaAaAa
  3 : BbCcDdEe
  4 : 123456789
  END

    unlink $e;

    V( loop => 16)->for(sub
     {my ($index, $start, $next, $end) = @_;
      $index->setReg(rax);
      Add rax, 0xb0;   Shl rax, 16;
      Mov  ax, 0x9d9d; Shl rax, 8;
      Mov  al, 0xf0;
      PrintOutRaxAsText;
     });
    PrintOutNL;

    ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
  
  END


=head3 PrintErrRaxAsText()

Print rax as text on stderr.


=head3 PrintErrRaxAsTextNL()

Print rax as text on stderr followed by a new line.


=head3 PrintRaxAsChar($channel)

Print the ascii character in rax on the specified channel.

     Parameter  Description
  1  $channel   Channel to write on

=head3 PrintOutRaxAsChar()

Print the character in on stdout.


B<Example:>


    my $e = q(readChar);

    ForEver
     {my ($start, $end) = @_;
      ReadChar;
      Cmp rax, 0xa;
      Jle $end;

      PrintOutRaxAsChar;  # 


      PrintOutRaxAsChar;  # 

     };
    PrintOutNL;

    Assemble keep => $e;

    is_deeply qx(echo "ABCDCBA" | ./$e), <<END;
  AABBCCDDCCBBAA
  END
    unlink $e;


=head3 PrintOutRaxAsCharNL()

Print the character in on stdout followed by a new line.


=head3 PrintErrRaxAsChar()

Print the character in on stderr.


=head3 PrintErrRaxAsCharNL()

Print the character in on stderr followed by a new line.


=head1 Variables

Variable definitions and operations

=head2 Definitions

Variable definitions

=head3 Variable($name, $expr, %options)

Create a new variable with the specified name initialized via an optional expression.

     Parameter  Description
  1  $name      Name of variable
  2  $expr      Optional expression initializing variable
  3  %options   Options

=head3 K($name, $expr, %options)

Define a constant variable.

     Parameter  Description
  1  $name      Name of variable
  2  $expr      Initializing expression
  3  %options   Options

B<Example:>


    my $s = Subroutine
     {my ($p) = @_;
      $$p{v}->copy($$p{v} + $$p{k} + $$p{g} + 1);
     } name => 'add', parameters=>[qw(v k g)];

    my $v = V(v, 1);

    my $k = K(k, 2);  # 

    my $g = V(g, 3);
    $s->call(parameters=>{v=>$v, k=>$k, g=>$g});
    $v->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  v: 0000 0000 0000 0007
  END

    my $g = V g => 0;
    my $s = Subroutine
     {my ($p) = @_;

      $$p{g}->copy(K value, 1);  # 

     } name => 'ref2', parameters=>[qw(g)];

    my $t = Subroutine
     {my ($p) = @_;
      $s->call(parameters=>{g=>$$p{g}});
     } name => 'ref', parameters=>[qw(g)];

    $t->call(parameters=>{g=>$g});
    $g->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  g: 0000 0000 0000 0001
  END

    my $a = V(a, 3);  $a->outNL;

    my $b = K(b, 2);  $b->outNL;  # 

    my $c = $a +  $b; $c->outNL;
    my $d = $c -  $a; $d->outNL;
    my $g = $a *  $b; $g->outNL;
    my $h = $g /  $b; $h->outNL;
    my $i = $a %  $b; $i->outNL;

    If ($a == 3,
    Then
     {PrintOutStringNL "a == 3"
     },
    Else
     {PrintOutStringNL "a != 3"
     });

    ++$a; $a->outNL;
    --$a; $a->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  a: 0000 0000 0000 0003
  b: 0000 0000 0000 0002
  (a add b): 0000 0000 0000 0005
  ((a add b) sub a): 0000 0000 0000 0002
  (a times b): 0000 0000 0000 0006
  ((a times b) / b): 0000 0000 0000 0003
  (a % b): 0000 0000 0000 0001
  a == 3
  a: 0000 0000 0000 0004
  a: 0000 0000 0000 0003
  END


=head3 R($name)

Define a reference variable.

     Parameter  Description
  1  $name      Name of variable

=head3 V($name, $expr, %options)

Define a variable.

     Parameter  Description
  1  $name      Name of variable
  2  $expr      Initializing expression
  3  %options   Options

B<Example:>


    my $s = Subroutine
     {my ($p) = @_;
      $$p{v}->copy($$p{v} + $$p{k} + $$p{g} + 1);
     } name => 'add', parameters=>[qw(v k g)];


    my $v = V(v, 1);  # 

    my $k = K(k, 2);

    my $g = V(g, 3);  # 

    $s->call(parameters=>{v=>$v, k=>$k, g=>$g});
    $v->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  v: 0000 0000 0000 0007
  END


    my $g = V g => 0;  # 

    my $s = Subroutine
     {my ($p) = @_;
      $$p{g}->copy(K value, 1);
     } name => 'ref2', parameters=>[qw(g)];

    my $t = Subroutine
     {my ($p) = @_;
      $s->call(parameters=>{g=>$$p{g}});
     } name => 'ref', parameters=>[qw(g)];

    $t->call(parameters=>{g=>$g});
    $g->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  g: 0000 0000 0000 0001
  END


    my $a = V(a, 3);  $a->outNL;  # 

    my $b = K(b, 2);  $b->outNL;
    my $c = $a +  $b; $c->outNL;
    my $d = $c -  $a; $d->outNL;
    my $g = $a *  $b; $g->outNL;
    my $h = $g /  $b; $h->outNL;
    my $i = $a %  $b; $i->outNL;

    If ($a == 3,
    Then
     {PrintOutStringNL "a == 3"
     },
    Else
     {PrintOutStringNL "a != 3"
     });

    ++$a; $a->outNL;
    --$a; $a->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  a: 0000 0000 0000 0003
  b: 0000 0000 0000 0002
  (a add b): 0000 0000 0000 0005
  ((a add b) sub a): 0000 0000 0000 0002
  (a times b): 0000 0000 0000 0006
  ((a times b) / b): 0000 0000 0000 0003
  (a % b): 0000 0000 0000 0001
  a == 3
  a: 0000 0000 0000 0004
  a: 0000 0000 0000 0003
  END


=head2 Print variables

Print the values of variables or the memory addressed by them

=head3 Nasm::X86::Variable::err($left, $title1, $title2)

Dump the value of a variable on stderr.

     Parameter  Description
  1  $left      Left variable
  2  $title1    Optional leading title
  3  $title2    Optional trailing title

=head3 Nasm::X86::Variable::out($left, $title1, $title2)

Dump the value of a variable on stdout.

     Parameter  Description
  1  $left      Left variable
  2  $title1    Optional leading title
  3  $title2    Optional trailing title

=head3 Nasm::X86::Variable::errNL($left, $title1, $title2)

Dump the value of a variable on stderr and append a new line.

     Parameter  Description
  1  $left      Left variable
  2  $title1    Optional leading title
  3  $title2    Optional trailing title

=head3 Nasm::X86::Variable::d($left, $title1, $title2)

Dump the value of a variable on stderr and append a new line.

     Parameter  Description
  1  $left      Left variable
  2  $title1    Optional leading title
  3  $title2    Optional trailing title

=head3 Nasm::X86::Variable::outNL($left, $title1, $title2)

Dump the value of a variable on stdout and append a new line.

     Parameter  Description
  1  $left      Left variable
  2  $title1    Optional leading title
  3  $title2    Optional trailing title

=head3 Nasm::X86::Variable::debug($left)

Dump the value of a variable on stdout with an indication of where the dump came from.

     Parameter  Description
  1  $left      Left variable

=head3 Decimal representation

Print out a variable as a decimal number

=head4 Nasm::X86::Variable::errInDec($number, $title1, $title2)

Dump the value of a variable on stderr in decimal.

     Parameter  Description
  1  $number    Number as variable
  2  $title1    Optional leading title
  3  $title2    Optional trailing title

=head4 Nasm::X86::Variable::errInDecNL($number, $title1, $title2)

Dump the value of a variable on stderr in decimal followed by a new line.

     Parameter  Description
  1  $number    Number as variable
  2  $title1    Optional leading title
  3  $title2    Optional trailing title

=head4 Nasm::X86::Variable::outInDec($number, $title1, $title2)

Dump the value of a variable on stdout in decimal.

     Parameter  Description
  1  $number    Number as variable
  2  $title1    Optional leading title
  3  $title2    Optional trailing title

=head4 Nasm::X86::Variable::outInDecNL($number, $title1, $title2)

Dump the value of a variable on stdout in decimal followed by a new line.

     Parameter  Description
  1  $number    Number as variable
  2  $title1    Optional leading title
  3  $title2    Optional trailing title

B<Example:>


    my $e = q(parameters);

    (V string => "[rbp+8]")->outInDecNL;
    (V string => "[rbp+16]")->outCStringNL;
    (V string => "[rbp+24]")->outCStringNL;
    (V string => "[rbp+32]")->outCStringNL;
    (V string => "[rbp+40]")->outCStringNL;
    (V string => "[rbp+48]")->outInDecNL;

    (V string => "[rbp+8]")->for(sub
     {my ($index, $start, $next, $end) = @_;
      $index->setReg(rax);
      Inc rax;
      PrintOutRaxInDec;
      Inc rax;
      PrintOutString " : ";
      Shl rax, 3;
      (V string => "[rbp+rax]")->outCStringNL;
     });

    Assemble keep => $e;

    is_deeply scalar(qx(./$e AaAaAaAaAa BbCcDdEe 123456789)), <<END;
  string: 4
  ./parameters
  AaAaAaAaAa
  BbCcDdEe
  123456789
  string: 0
  1 : ./parameters
  2 : AaAaAaAaAa
  3 : BbCcDdEe
  4 : 123456789
  END

    unlink $e;


=head3 Decimal representation right justified

Print out a variable as a decimal number right adjusted in a field of specified width

=head4 Nasm::X86::Variable::rightInDec($number, $channel, $width)

Dump the value of a variable on the specified channel as a decimal  number right adjusted in a field of specified width.

     Parameter  Description
  1  $number    Number as variable
  2  $channel   Channel
  3  $width     Width

=head4 Nasm::X86::Variable::errRightInDec($number, $width)

Dump the value of a variable on stderr as a decimal number right adjusted in a field of specified width.

     Parameter  Description
  1  $number    Number
  2  $width     Width

=head4 Nasm::X86::Variable::errRightInDecNL($number, $width)

Dump the value of a variable on stderr as a decimal number right adjusted in a field of specified width followed by a new line.

     Parameter  Description
  1  $number    Number
  2  $width     Width

=head4 Nasm::X86::Variable::outRightInDec($number, $width)

Dump the value of a variable on stdout as a decimal number right adjusted in a field of specified width.

     Parameter  Description
  1  $number    Number
  2  $width     Width

=head4 Nasm::X86::Variable::outRightInDecNL($number, $width)

Dump the value of a variable on stdout as a decimal number right adjusted in a field of specified width followed by a new line.

     Parameter  Description
  1  $number    Number
  2  $width     Width

=head2 Hexadecimal representation, right justified

Print number variables in hexadecimal right justified in fields of specified width.

=head3 Nasm::X86::Variable::rightInHex($number, $channel, $width)

Write the specified variable number in hexadecimal right justified in a field of specified width to the specified channel.

     Parameter  Description
  1  $number    Number to print as a variable
  2  $channel   Channel to print on
  3  $width     Width of output field

=head3 Nasm::X86::Variable::errRightInHex($number, $width)

Write the specified variable number in hexadecimal right justified in a field of specified width to stderr

     Parameter  Description
  1  $number    Number to print as a variable
  2  $width     Width of output field

=head3 Nasm::X86::Variable::errRightInHexNL($number, $width)

Write the specified variable number in hexadecimal right justified in a field of specified width to stderr followed by a new line

     Parameter  Description
  1  $number    Number to print as a variable
  2  $width     Width of output field

=head3 Nasm::X86::Variable::outRightInHex($number, $width)

Write the specified variable number in hexadecimal right justified in a field of specified width to stdout

     Parameter  Description
  1  $number    Number to print as a variable
  2  $width     Width of output field

=head3 Nasm::X86::Variable::outRightInHexNL($number, $width)

Write the specified variable number in hexadecimal right justified in a field of specified width to stdout followed by a new line

     Parameter  Description
  1  $number    Number to print as a variable
  2  $width     Width of output field

=head2 Binary representation, right justified

Print number variables in binary right justified in fields of specified width.

=head3 Nasm::X86::Variable::rightInBin($number, $channel, $width)

Write the specified variable number in binary right justified in a field of specified width to the specified channel.

     Parameter  Description
  1  $number    Number to print as a variable
  2  $channel   Channel to print on
  3  $width     Width of output field

=head3 Nasm::X86::Variable::errRightInBin($number, $width)

Write the specified variable number in binary right justified in a field of specified width to stderr

     Parameter  Description
  1  $number    Number to print as a variable
  2  $width     Width of output field

=head3 Nasm::X86::Variable::errRightInBinNL($number, $width)

Write the specified variable number in binary right justified in a field of specified width to stderr followed by a new line

     Parameter  Description
  1  $number    Number to print as a variable
  2  $width     Width of output field

=head3 Nasm::X86::Variable::outRightInBin($number, $width)

Write the specified variable number in binary right justified in a field of specified width to stdout

     Parameter  Description
  1  $number    Number to print as a variable
  2  $width     Width of output field

=head3 Nasm::X86::Variable::outRightInBinNL($number, $width)

Write the specified variable number in binary right justified in a field of specified width to stdout followed by a new line

     Parameter  Description
  1  $number    Number to print as a variable
  2  $width     Width of output field

=head3 Spaces

Print out a variable number of spaces

=head4 Nasm::X86::Variable::spaces($count, $channel)

Print the specified number of spaces to the specified channel.

     Parameter  Description
  1  $count     Number of spaces
  2  $channel   Channel

=head4 Nasm::X86::Variable::errSpaces($count)

Print the specified number of spaces to stderr.

     Parameter  Description
  1  $count     Number of spaces

=head4 Nasm::X86::Variable::outSpaces($count)

Print the specified number of spaces to stdout.

     Parameter  Description
  1  $count     Number of spaces

=head3 C style zero terminated strings

Print out C style zero terminated strings.

=head4 Nasm::X86::Variable::errCString($string)

Print a zero terminated C style string addressed by a variable on stderr.

     Parameter  Description
  1  $string    String

=head4 Nasm::X86::Variable::errCStringNL($string)

Print a zero terminated C style string addressed by a variable on stderr followed by a new line.

     Parameter  Description
  1  $string    String

=head4 Nasm::X86::Variable::outCString($string)

Print a zero terminated C style string addressed by a variable on stdout.

     Parameter  Description
  1  $string    String

=head4 Nasm::X86::Variable::outCStringNL($string)

Print a zero terminated C style string addressed by a variable on stdout followed by a new line.

     Parameter  Description
  1  $string    String

B<Example:>


    my $s = Rutf8 '';
    V(address, $s)->outCStringNL;

    ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
  
  END

    my $e = q(parameters);

    (V string => "[rbp+8]")->outInDecNL;
    (V string => "[rbp+16]")->outCStringNL;
    (V string => "[rbp+24]")->outCStringNL;
    (V string => "[rbp+32]")->outCStringNL;
    (V string => "[rbp+40]")->outCStringNL;
    (V string => "[rbp+48]")->outInDecNL;

    (V string => "[rbp+8]")->for(sub
     {my ($index, $start, $next, $end) = @_;
      $index->setReg(rax);
      Inc rax;
      PrintOutRaxInDec;
      Inc rax;
      PrintOutString " : ";
      Shl rax, 3;
      (V string => "[rbp+rax]")->outCStringNL;
     });

    Assemble keep => $e;

    is_deeply scalar(qx(./$e AaAaAaAaAa BbCcDdEe 123456789)), <<END;
  string: 4
  ./parameters
  AaAaAaAaAa
  BbCcDdEe
  123456789
  string: 0
  1 : ./parameters
  2 : AaAaAaAaAa
  3 : BbCcDdEe
  4 : 123456789
  END

    unlink $e;


=head2 Operations

Variable operations

=head3 Nasm::X86::Variable::call($target)

Execute the call instruction for a target whose address is held in the specified variable.

     Parameter  Description
  1  $target    Variable containing the address of the code to call

B<Example:>


    my $l = "aaa.so";
    Mov rax, 0x12345678;
    Ret;

    ok Assemble library => $l;                                                  # Create the library file
    ok -e $l;

    my ($address, $size) = ReadFile $l;                                         # Read library file into memory

    Mov rax, 0;
    PrintOutRaxInHexNL;

    $address->call;                                                             # Call code in memory loaded from library file

    PrintOutRaxInHexNL;                                                         # Print value set in library

    ok Assemble eq =><<END;
  0000 0000 0000 0000
  0000 0000 1234 5678
  END
    unlink $l;


=head3 Nasm::X86::Variable::address($left, $offset)

Get the address of a variable with an optional offset.

     Parameter  Description
  1  $left      Left variable
  2  $offset    Optional offset

=head3 Nasm::X86::Variable::clone($variable, $name)

Clone a variable to make a new variable.

     Parameter  Description
  1  $variable  Variable to clone
  2  $name      New name for variable

B<Example:>


  if (11) {
    my $a = V('a', 1);
    my $b = $a->clone('a');

    $_->outNL for $a, $b;

    ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
  a: 0000 0000 0000 0001
  a: 0000 0000 0000 0001
  END
   }

  #latest:
  if (1) {                                                                         Nasm::X86::Variable::loadZmm
    my $l = V('low',   Rd(2, 7, (0) x 14));
    my $h = V('high' , Rd(3, 9, (0) x 14));
    my $o = V('off',   Rd(2, 5, (0) x 14));
    my $u = V('utf32', Dd(2, 3, 7, 8, 9, (0) x 11));


    $l->loadZmm(0);
    $h->loadZmm(1);
    $o->loadZmm(2);

    ClassifyWithInRangeAndSaveWordOffset($u, V('size', 5), V('classification', 7));
    $u->loadZmm(3);

    PrintOutRegisterInHex zmm 0..3;

    ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
    zmm0: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0007 0000 0002
    zmm1: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0009 0000 0003
    zmm2: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0005 0000 0002
    zmm3: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0700 0004   0700 0003 0700 0002   0700 0001 0700 0000
  END
   }


=head3 Nasm::X86::Variable::copy($left, $right)

Copy one variable into another.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

B<Example:>


    my $s = Subroutine
     {my ($p) = @_;
      $$p{v}->copy($$p{v} + $$p{k} + $$p{g} + 1);
     } name => 'add', parameters=>[qw(v k g)];

    my $v = V(v, 1);
    my $k = K(k, 2);
    my $g = V(g, 3);
    $s->call(parameters=>{v=>$v, k=>$k, g=>$g});
    $v->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  v: 0000 0000 0000 0007
  END

    my $g = V g => 0;
    my $s = Subroutine
     {my ($p) = @_;
      $$p{g}->copy(K value, 1);
     } name => 'ref2', parameters=>[qw(g)];

    my $t = Subroutine
     {my ($p) = @_;
      $s->call(parameters=>{g=>$$p{g}});
     } name => 'ref', parameters=>[qw(g)];

    $t->call(parameters=>{g=>$g});
    $g->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  g: 0000 0000 0000 0001
  END


=head3 Nasm::X86::Variable::copyRef($left, $right)

Copy a reference to a variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::copyZF($var)

Copy the current state of the zero flag into a variable.

     Parameter  Description
  1  $var       Variable

B<Example:>


    Mov r15, 1;
    my $z = V(zf);
    Cmp r15, 1; $z->copyZF;         $z->outNL;
    Cmp r15, 2; $z->copyZF;         $z->outNL;
    Cmp r15, 1; $z->copyZFInverted; $z->outNL;
    Cmp r15, 2; $z->copyZFInverted; $z->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  zf: 0000 0000 0000 0001
  zf: 0000 0000 0000 0000
  zf: 0000 0000 0000 0000
  zf: 0000 0000 0000 0001
  END


=head3 Nasm::X86::Variable::copyZFInverted($var)

Copy the opposite of the current state of the zero flag into a variable.

     Parameter  Description
  1  $var       Variable

B<Example:>


    Mov r15, 1;
    my $z = V(zf);
    Cmp r15, 1; $z->copyZF;         $z->outNL;
    Cmp r15, 2; $z->copyZF;         $z->outNL;
    Cmp r15, 1; $z->copyZFInverted; $z->outNL;
    Cmp r15, 2; $z->copyZFInverted; $z->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  zf: 0000 0000 0000 0001
  zf: 0000 0000 0000 0000
  zf: 0000 0000 0000 0000
  zf: 0000 0000 0000 0001
  END


=head3 Nasm::X86::Variable::equals($op, $left, $right)

Equals operator.

     Parameter  Description
  1  $op        Operator
  2  $left      Left variable
  3  $right     Right variable

=head3 Nasm::X86::Variable::assign($left, $op, $right)

Assign to the left hand side the value of the right hand side.

     Parameter  Description
  1  $left      Left variable
  2  $op        Operator
  3  $right     Right variable

=head3 Nasm::X86::Variable::plusAssign($left, $right)

Implement plus and assign.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::minusAssign($left, $right)

Implement minus and assign.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::arithmetic($op, $name, $left, $right)

Return a variable containing the result of an arithmetic operation on the left hand and right hand side variables.

     Parameter  Description
  1  $op        Operator
  2  $name      Operator name
  3  $left      Left variable
  4  $right     Right variable

=head3 Nasm::X86::Variable::add($left, $right)

Add the right hand variable to the left hand variable and return the result as a new variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::sub($left, $right)

Subtract the right hand variable from the left hand variable and return the result as a new variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::times($left, $right)

Multiply the left hand variable by the right hand variable and return the result as a new variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::division($op, $left, $right)

Return a variable containing the result or the remainder that occurs when the left hand side is divided by the right hand side.

     Parameter  Description
  1  $op        Operator
  2  $left      Left variable
  3  $right     Right variable

=head3 Nasm::X86::Variable::divide($left, $right)

Divide the left hand variable by the right hand variable and return the result as a new variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::mod($left, $right)

Divide the left hand variable by the right hand variable and return the remainder as a new variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::shiftLeft($left, $right)

Shift the left hand variable left by the number of bits specified in the right hand variable and return the result as a new variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::shiftRight($left, $right)

Shift the left hand variable right by the number of bits specified in the right hand variable and return the result as a new variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::not($left)

Form two complement of left hand side and return it as a variable.

     Parameter  Description
  1  $left      Left variable

=head3 Nasm::X86::Variable::boolean($sub, $op, $left, $right)

Combine the left hand variable with the right hand variable via a boolean operator.

     Parameter  Description
  1  $sub       Operator
  2  $op        Operator name
  3  $left      Left variable
  4  $right     Right variable

=head3 Nasm::X86::Variable::booleanZF($sub, $op, $left, $right)

Combine the left hand variable with the right hand variable via a boolean operator and indicate the result by setting the zero flag if the result is true.

     Parameter  Description
  1  $sub       Operator
  2  $op        Operator name
  3  $left      Left variable
  4  $right     Right variable

=head3 Nasm::X86::Variable::booleanC($cmov, $op, $left, $right)

Combine the left hand variable with the right hand variable via a boolean operator using a conditional move instruction.

     Parameter  Description
  1  $cmov      Conditional move instruction name
  2  $op        Operator name
  3  $left      Left variable
  4  $right     Right variable

=head3 Nasm::X86::Variable::eq($left, $right)

Check whether the left hand variable is equal to the right hand variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::ne($left, $right)

Check whether the left hand variable is not equal to the right hand variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::ge($left, $right)

Check whether the left hand variable is greater than or equal to the right hand variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::gt($left, $right)

Check whether the left hand variable is greater than the right hand variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::le($left, $right)

Check whether the left hand variable is less than or equal to the right hand variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::lt($left, $right)

Check whether the left hand variable is less than the right hand variable.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::isRef($variable)

Check whether the specified  variable is a reference to another variable.

     Parameter  Description
  1  $variable  Variable

=head3 Nasm::X86::Variable::setReg($variable, $register)

Set the named registers from the content of the variable.

     Parameter  Description
  1  $variable  Variable
  2  $register  Register to load

=head3 Nasm::X86::Variable::getReg($variable, $register)

Load the variable from a register expression.

     Parameter  Description
  1  $variable  Variable
  2  $register  Register expression to load

=head3 Nasm::X86::Variable::getConst($variable, $constant)

Load the variable from a constant in effect setting a variable to a specified value.

     Parameter  Description
  1  $variable  Variable
  2  $constant  Constant to load

=head3 Nasm::X86::Variable::incDec($left, $op)

Increment or decrement a variable.

     Parameter  Description
  1  $left      Left variable operator
  2  $op        Address of operator to perform inc or dec

=head3 Nasm::X86::Variable::inc($left)

Increment a variable.

     Parameter  Description
  1  $left      Variable

=head3 Nasm::X86::Variable::dec($left)

Decrement a variable.

     Parameter  Description
  1  $left      Variable

=head3 Nasm::X86::Variable::str($left)

The name of the variable.

     Parameter  Description
  1  $left      Variable

=head3 Nasm::X86::Variable::min($left, $right)

Minimum of two variables.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable or constant

B<Example:>


    my $a = V("a", 1);
    my $b = V("b", 2);
    my $c = $a->min($b);
    my $d = $a->max($b);
    $a->outNL;
    $b->outNL;
    $c->outNL;
    $d->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  a: 0000 0000 0000 0001
  b: 0000 0000 0000 0002
  min: 0000 0000 0000 0001
  max: 0000 0000 0000 0002
  END


=head3 Nasm::X86::Variable::max($left, $right)

Maximum of two variables.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable or constant

B<Example:>


    my $a = V("a", 1);
    my $b = V("b", 2);
    my $c = $a->min($b);
    my $d = $a->max($b);
    $a->outNL;
    $b->outNL;
    $c->outNL;
    $d->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  a: 0000 0000 0000 0001
  b: 0000 0000 0000 0002
  min: 0000 0000 0000 0001
  max: 0000 0000 0000 0002
  END


=head3 Nasm::X86::Variable::and($left, $right)

And two variables.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::or($left, $right)

Or two variables.

     Parameter  Description
  1  $left      Left variable
  2  $right     Right variable

=head3 Nasm::X86::Variable::setMask($start, $length, $mask)

Set the mask register to ones starting at the specified position for the specified length and zeroes elsewhere.

     Parameter  Description
  1  $start     Variable containing start of mask
  2  $length    Variable containing length of mask
  3  $mask      Mask register

B<Example:>


    my $start  = V("Start",  7);
    my $length = V("Length", 3);
    $start->setMask($length, k7);
    PrintOutRegisterInHex k7;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
      k7: 0000 0000 0000 0380
  END

    my $z = V('zero', 0);
    my $o = V('one',  1);
    my $t = V('two',  2);
    $z->setMask($o,       k7); PrintOutRegisterInHex k7;
    $z->setMask($t,       k6); PrintOutRegisterInHex k6;
    $z->setMask($o+$t,    k5); PrintOutRegisterInHex k5;
    $o->setMask($o,       k4); PrintOutRegisterInHex k4;
    $o->setMask($t,       k3); PrintOutRegisterInHex k3;
    $o->setMask($o+$t,    k2); PrintOutRegisterInHex k2;

    $t->setMask($o,       k1); PrintOutRegisterInHex k1;
    $t->setMask($t,       k0); PrintOutRegisterInHex k0;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
      k7: 0000 0000 0000 0001
      k6: 0000 0000 0000 0003
      k5: 0000 0000 0000 0007
      k4: 0000 0000 0000 0002
      k3: 0000 0000 0000 0006
      k2: 0000 0000 0000 000E
      k1: 0000 0000 0000 0004
      k0: 0000 0000 0000 000C
  END


=head3 Nasm::X86::Variable::setMaskFirst($length, $mask)

Set the first bits in the specified mask register.

     Parameter  Description
  1  $length    Variable containing length to set
  2  $mask      Mask register

=head3 Nasm::X86::Variable::setMaskBit($index, $mask)

Set a bit in the specified mask register retaining the other bits.

     Parameter  Description
  1  $index     Variable containing bit position to set
  2  $mask      Mask register

=head3 Nasm::X86::Variable::clearMaskBit($index, $mask)

Clear a bit in the specified mask register retaining the other bits.

     Parameter  Description
  1  $index     Variable containing bit position to clear
  2  $mask      Mask register

=head3 Nasm::X86::Variable::setBit($index, $mask)

Set a bit in the specified register retaining the other bits.

     Parameter  Description
  1  $index     Variable containing bit position to set
  2  $mask      Mask register

=head3 Nasm::X86::Variable::clearBit($index, $mask)

Clear a bit in the specified mask register retaining the other bits.

     Parameter  Description
  1  $index     Variable containing bit position to clear
  2  $mask      Mask register

=head3 Nasm::X86::Variable::setZmm($source, $zmm, $offset, $length)

Load bytes from the memory addressed by specified source variable into the numbered zmm register at the offset in the specified offset moving the number of bytes in the specified variable.

     Parameter  Description
  1  $source    Variable containing the address of the source
  2  $zmm       Number of zmm to load
  3  $offset    Variable containing offset in zmm to move to
  4  $length    Variable containing length of move

B<Example:>


    my $s = Rb(0..128);
    my $source = V(Source, $s);

    if (1)                                                                      # First block
     {my $offset = V(Offset, 7);
      my $length = V(Length, 3);
      $source->setZmm(0, $offset, $length);
     }

    if (1)                                                                      # Second block
     {my $offset = V(Offset, 33);
      my $length = V(Length, 12);
      $source->setZmm(0, $offset, $length);
     }

    PrintOutRegisterInHex zmm0;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    zmm0: 0000 0000 0000 0000   0000 0000 0000 0000   0000 000B 0A09 0807   0605 0403 0201 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0201   0000 0000 0000 0000
  END


=head3 Nasm::X86::Variable::loadZmm($source, $zmm)

Load bytes from the memory addressed by the specified source variable into the numbered zmm register.

     Parameter  Description
  1  $source    Variable containing the address of the source
  2  $zmm       Number of zmm to get

=head3 Nasm::X86::Variable::bFromZ($variable, $zmm, $offset)

Get the byte from the numbered zmm register and put it in a variable.

     Parameter  Description
  1  $variable  Variable
  2  $zmm       Numbered zmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::wFromZ($variable, $zmm, $offset)

Get the word from the numbered zmm register and put it in a variable.

     Parameter  Description
  1  $variable  Variable
  2  $zmm       Numbered zmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::dFromZ($variable, $zmm, $offset)

Get the double word from the numbered zmm register and put it in a variable.

     Parameter  Description
  1  $variable  Variable
  2  $zmm       Numbered zmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::qFromZ($variable, $zmm, $offset)

Get the quad word from the numbered zmm register and put it in a variable.

     Parameter  Description
  1  $variable  Variable
  2  $zmm       Numbered zmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::dFromPointInZ($point, $zmm)

Get the double word from the numbered zmm register at a point specified by the variable and return it in a variable.

     Parameter  Description
  1  $point     Point
  2  $zmm       Numbered zmm

B<Example:>


    my $tree = DescribeTree(length => 7);

    my $K = 31;

    K(K => Rd(0..15))->loadZmm($K);

    PrintOutRegisterInHex zmm $K;
    K( offset => 1 << 5)->dFromPointInZ($K)->outNL;

    ok Assemble eq => <<END;
   zmm31: 0000 000F 0000 000E   0000 000D 0000 000C   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
  d: 0000 0000 0000 0005
  END


=head3 Nasm::X86::Variable::dIntoPointInZ($point, $zmm, $content)

Put the variable double word content into the numbered zmm register at a point specified by the variable.

     Parameter  Description
  1  $point     Point
  2  $zmm       Numbered zmm
  3  $content   Content to be inserted as a variable

=head3 Nasm::X86::Variable::putBwdqIntoMm($content, $size, $mm, $offset)

Place the value of the content variable at the byte|word|double word|quad word in the numbered zmm register.

     Parameter  Description
  1  $content   Variable with content
  2  $size      Size of put
  3  $mm        Numbered zmm
  4  $offset    Offset in bytes

=head3 Nasm::X86::Variable::bIntoX($content, $xmm, $offset)

Place the value of the content variable at the byte in the numbered xmm register.

     Parameter  Description
  1  $content   Variable with content
  2  $xmm       Numbered xmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::wIntoX($content, $xmm, $offset)

Place the value of the content variable at the word in the numbered xmm register.

     Parameter  Description
  1  $content   Variable with content
  2  $xmm       Numbered xmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::dIntoX($content, $xmm, $offset)

Place the value of the content variable at the double word in the numbered xmm register.

     Parameter  Description
  1  $content   Variable with content
  2  $xmm       Numbered xmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::qIntoX($content, $xmm, $offset)

Place the value of the content variable at the quad word in the numbered xmm register.

     Parameter  Description
  1  $content   Variable with content
  2  $xmm       Numbered xmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::bIntoZ($content, $zmm, $offset)

Place the value of the content variable at the byte in the numbered zmm register.

     Parameter  Description
  1  $content   Variable with content
  2  $zmm       Numbered zmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::putWIntoZmm($content, $zmm, $offset)

Place the value of the content variable at the word in the numbered zmm register.

     Parameter  Description
  1  $content   Variable with content
  2  $zmm       Numbered zmm
  3  $offset    Offset in bytes

=head3 Nasm::X86::Variable::dIntoZ($content, $zmm, $offset)

Place the value of the content variable at the double word in the numbered zmm register.

     Parameter  Description
  1  $content   Variable with content
  2  $zmm       Numbered zmm
  3  $offset    Offset in bytes

B<Example:>


    my $s = Rb(0..8);
    my $c = V("Content",   "[$s]");
       $c->bIntoZ(0,  4);
       $c->putWIntoZmm(0,  6);
       $c->dIntoZ(0, 10);
       $c->qIntoZ(0, 16);
    PrintOutRegisterInHex zmm0;
    bFromZ(0, 12)->outNL;
    wFromZ(0, 12)->outNL;
    dFromZ(0, 12)->outNL;
    qFromZ(0, 12)->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    zmm0: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0706 0504 0302 0100   0000 0302 0100 0000   0100 0000 0000 0000
  b at offset 12 in zmm0: 0000 0000 0000 0002
  w at offset 12 in zmm0: 0000 0000 0000 0302
  d at offset 12 in zmm0: 0000 0000 0000 0302
  q at offset 12 in zmm0: 0302 0100 0000 0302
  END


=head3 Nasm::X86::Variable::qIntoZ($content, $zmm, $offset)

Place the value of the content variable at the quad word in the numbered zmm register.

     Parameter  Description
  1  $content   Variable with content
  2  $zmm       Numbered zmm
  3  $offset    Offset in bytes

=head2 Memory

Actions on memory described by variables

=head3 Nasm::X86::Variable::clearMemory($address, $size)

Clear the memory described in this variable.

     Parameter  Description
  1  $address   Address of memory to clear
  2  $size      Size of the memory to clear

=head3 Nasm::X86::Variable::copyMemory($target, $source, $size)

Copy from one block of memory to another.

     Parameter  Description
  1  $target    Address of target
  2  $source    Address of source
  3  $size      Length to copy

=head3 Nasm::X86::Variable::printMemoryInHexNL($address, $channel, $size)

Write, in hexadecimal, the memory addressed by a variable to stdout or stderr.

     Parameter  Description
  1  $address   Address of memory
  2  $channel   Channel to print on
  3  $size      Number of bytes to print

=head3 Nasm::X86::Variable::printErrMemoryInHexNL($address, $size)

Write the memory addressed by a variable to stderr.

     Parameter  Description
  1  $address   Address of memory
  2  $size      Number of bytes to print

=head3 Nasm::X86::Variable::printOutMemoryInHexNL($address, $size)

Write the memory addressed by a variable to stdout.

     Parameter  Description
  1  $address   Address of memory
  2  $size      Number of bytes to print

B<Example:>


    my $u = Rd(ord(''), ord(''), ord(''), ord(''));
    Mov rax, $u;
    my $address = V(address)->getReg(rax);
    $address->printOutMemoryInHexNL(K(size, 16));

    ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
  70D7 0100 71D7 0100  72D7 0100 73D7 0100
  END

    my $v = V(var, 2);

    If  $v == 0, Then {Mov rax, 0},
    Ef {$v == 1} Then {Mov rax, 1},
    Ef {$v == 2} Then {Mov rax, 2},
                 Else {Mov rax, 3};
    PrintOutRegisterInHex rax;
    ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0002
  END


=head3 Nasm::X86::Variable::freeMemory($address, $size)

Free the memory addressed by this variable for the specified length.

     Parameter  Description
  1  $address   Address of memory to free
  2  $size      Size of the memory to free

B<Example:>


    my $N = K size => 2048;
    my $q = Rs('a'..'p');
    my $address = AllocateMemory $N;

    Vmovdqu8 xmm0, "[$q]";
    $address->setReg(rax);
    Vmovdqu8 "[rax]", xmm0;
    Mov rdi, 16;
    PrintOutMemory;
    PrintOutNL;

    FreeMemory $address, $N;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  abcdefghijklmnop
  END


=head3 Nasm::X86::Variable::allocateMemory($size)

Allocate the specified amount of memory via mmap and return its address.

     Parameter  Description
  1  $size      Size

=head2 Structured Programming with variables

Structured programming operations driven off variables.

=head3 Nasm::X86::Variable::for($limit, $block)

Iterate a block a variable number of times.

     Parameter  Description
  1  $limit     Number of times
  2  $block     Block

B<Example:>


    V(limit,10)->for(sub
     {my ($i, $start, $next, $end) = @_;
      $i->outNL;
     });

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  index: 0000 0000 0000 0000
  index: 0000 0000 0000 0001
  index: 0000 0000 0000 0002
  index: 0000 0000 0000 0003
  index: 0000 0000 0000 0004
  index: 0000 0000 0000 0005
  index: 0000 0000 0000 0006
  index: 0000 0000 0000 0007
  index: 0000 0000 0000 0008
  index: 0000 0000 0000 0009
  END


=head1 Operating system

Interacting with the operating system.

=head2 Processes

Create and manage processes

=head3 Fork()

Fork: create and execute a copy of the current process.


B<Example:>



    Fork;                                                                       # Fork  # 


    Test rax,rax;
    IfNz                                                                        # Parent
    Then
     {Mov rbx, rax;
      WaitPid;
      GetPid;                                                                   # Pid of parent as seen in parent
      Mov rcx,rax;
      PrintOutRegisterInHex rax, rbx, rcx;
     },
    Else                                                                        # Child
     {Mov r8,rax;
      GetPid;                                                                   # Child pid as seen in child
      Mov r9,rax;
      GetPPid;                                                                  # Parent pid as seen in child
      Mov r10,rax;
      PrintOutRegisterInHex r8, r9, r10;
     };

    my $r = Assemble;

  #    r8: 0000 0000 0000 0000   #1 Return from fork as seen by child
  #    r9: 0000 0000 0003 0C63   #2 Pid of child
  #   r10: 0000 0000 0003 0C60   #3 Pid of parent from child
  #   rax: 0000 0000 0003 0C63   #4 Return from fork as seen by parent
  #   rbx: 0000 0000 0003 0C63   #5 Wait for child pid result
  #   rcx: 0000 0000 0003 0C60   #6 Pid of parent

    if ($r =~ m(r8:( 0000){4}.*r9:(.*)\s{5,}r10:(.*)\s{5,}rax:(.*)\s{5,}rbx:(.*)\s{5,}rcx:(.*)\s{2,})s)
     {ok $2 eq $4;
      ok $2 eq $5;
      ok $3 eq $6;
      ok $2 gt $6;
     }


=head3 GetPid()

Get process identifier.


B<Example:>


    Fork;                                                                       # Fork

    Test rax,rax;
    IfNz                                                                        # Parent
    Then
     {Mov rbx, rax;
      WaitPid;

      GetPid;                                                                   # Pid of parent as seen in parent  # 

      Mov rcx,rax;
      PrintOutRegisterInHex rax, rbx, rcx;
     },
    Else                                                                        # Child
     {Mov r8,rax;

      GetPid;                                                                   # Child pid as seen in child  # 

      Mov r9,rax;
      GetPPid;                                                                  # Parent pid as seen in child
      Mov r10,rax;
      PrintOutRegisterInHex r8, r9, r10;
     };

    my $r = Assemble;

  #    r8: 0000 0000 0000 0000   #1 Return from fork as seen by child
  #    r9: 0000 0000 0003 0C63   #2 Pid of child
  #   r10: 0000 0000 0003 0C60   #3 Pid of parent from child
  #   rax: 0000 0000 0003 0C63   #4 Return from fork as seen by parent
  #   rbx: 0000 0000 0003 0C63   #5 Wait for child pid result
  #   rcx: 0000 0000 0003 0C60   #6 Pid of parent

    if ($r =~ m(r8:( 0000){4}.*r9:(.*)\s{5,}r10:(.*)\s{5,}rax:(.*)\s{5,}rbx:(.*)\s{5,}rcx:(.*)\s{2,})s)
     {ok $2 eq $4;
      ok $2 eq $5;
      ok $3 eq $6;
      ok $2 gt $6;
     }


=head3 GetPidInHex()

Get process identifier in hex as 8 zero terminated bytes in rax.


B<Example:>



    GetPidInHex;  # 

    PrintOutRegisterInHex rax;

    ok Assemble =~ m(rax: 00);


=head3 GetPPid()

Get parent process identifier.


B<Example:>


    Fork;                                                                       # Fork

    Test rax,rax;
    IfNz                                                                        # Parent
    Then
     {Mov rbx, rax;
      WaitPid;
      GetPid;                                                                   # Pid of parent as seen in parent
      Mov rcx,rax;
      PrintOutRegisterInHex rax, rbx, rcx;
     },
    Else                                                                        # Child
     {Mov r8,rax;
      GetPid;                                                                   # Child pid as seen in child
      Mov r9,rax;

      GetPPid;                                                                  # Parent pid as seen in child  # 

      Mov r10,rax;
      PrintOutRegisterInHex r8, r9, r10;
     };

    my $r = Assemble;

  #    r8: 0000 0000 0000 0000   #1 Return from fork as seen by child
  #    r9: 0000 0000 0003 0C63   #2 Pid of child
  #   r10: 0000 0000 0003 0C60   #3 Pid of parent from child
  #   rax: 0000 0000 0003 0C63   #4 Return from fork as seen by parent
  #   rbx: 0000 0000 0003 0C63   #5 Wait for child pid result
  #   rcx: 0000 0000 0003 0C60   #6 Pid of parent

    if ($r =~ m(r8:( 0000){4}.*r9:(.*)\s{5,}r10:(.*)\s{5,}rax:(.*)\s{5,}rbx:(.*)\s{5,}rcx:(.*)\s{2,})s)
     {ok $2 eq $4;
      ok $2 eq $5;
      ok $3 eq $6;
      ok $2 gt $6;
     }


=head3 GetUid()

Get userid of current process.


B<Example:>



    GetUid;                                                                     # Userid  # 

    PrintOutRegisterInHex rax;

    my $r = Assemble;
    ok $r =~ m(rax:( 0000){3});


=head3 WaitPid()

Wait for the pid in rax to complete.


B<Example:>


    Fork;                                                                       # Fork

    Test rax,rax;
    IfNz                                                                        # Parent
    Then
     {Mov rbx, rax;

      WaitPid;  # 

      GetPid;                                                                   # Pid of parent as seen in parent
      Mov rcx,rax;
      PrintOutRegisterInHex rax, rbx, rcx;
     },
    Else                                                                        # Child
     {Mov r8,rax;
      GetPid;                                                                   # Child pid as seen in child
      Mov r9,rax;
      GetPPid;                                                                  # Parent pid as seen in child
      Mov r10,rax;
      PrintOutRegisterInHex r8, r9, r10;
     };

    my $r = Assemble;

  #    r8: 0000 0000 0000 0000   #1 Return from fork as seen by child
  #    r9: 0000 0000 0003 0C63   #2 Pid of child
  #   r10: 0000 0000 0003 0C60   #3 Pid of parent from child
  #   rax: 0000 0000 0003 0C63   #4 Return from fork as seen by parent
  #   rbx: 0000 0000 0003 0C63   #5 Wait for child pid result
  #   rcx: 0000 0000 0003 0C60   #6 Pid of parent

    if ($r =~ m(r8:( 0000){4}.*r9:(.*)\s{5,}r10:(.*)\s{5,}rax:(.*)\s{5,}rbx:(.*)\s{5,}rcx:(.*)\s{2,})s)
     {ok $2 eq $4;
      ok $2 eq $5;
      ok $3 eq $6;
      ok $2 gt $6;
     }


=head3 ReadTimeStampCounter()

Read the time stamp counter and return the time in nanoseconds in rax.


B<Example:>


    for(1..10)

     {ReadTimeStampCounter;  # 

      PrintOutRegisterInHex rax;
     }

    my @s = split /
/, Assemble;
    my @S = sort @s;
    is_deeply \@s, \@S;


=head2 Memory

Allocate and print memory

=head3 PrintMemoryInHex($channel)

Dump memory from the address in rax for the length in rdi on the specified channel. As this method prints in blocks of 8 up to 7 bytes will be missing from the end unless the length is a multiple of 8 .

     Parameter  Description
  1  $channel   Channel

=head3 PrintErrMemoryInHex()

Dump memory from the address in rax for the length in rdi on stderr.


=head3 PrintOutMemoryInHex()

Dump memory from the address in rax for the length in rdi on stdout.


B<Example:>


    Mov rax, 0x07654321;
    Shl rax, 32;
    Or  rax, 0x07654321;
    PushR rax;

    PrintOutRaxInHex;
    PrintOutNL;
    PrintOutRaxInReverseInHex;
    PrintOutNL;

    Mov rax, rsp;
    Mov rdi, 8;

    PrintOutMemoryInHex;  # 

    PrintOutNL;
    PopR rax;

    Mov rax, 4096;
    PushR rax;
    Mov rax, rsp;
    Mov rdi, 8;

    PrintOutMemoryInHex;  # 

    PrintOutNL;
    PopR rax;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  0765 4321 0765 4321
  2143 6507 2143 6507
  2143 6507 2143 6507
  0010 0000 0000 0000
  END


=head3 PrintErrMemoryInHexNL()

Dump memory from the address in rax for the length in rdi and then print a new line.


=head3 PrintOutMemoryInHexNL()

Dump memory from the address in rax for the length in rdi and then print a new line.


B<Example:>


    my $N = 256;
    my $s = Rb 0..$N-1;
    my $a = AllocateMemory K size => $N;
    CopyMemory(V(source => $s), $a, K(size => $N));

    my $b = AllocateMemory K size => $N;
    CopyMemory($a, $b, K size => $N);

    $b->setReg(rax);
    Mov rdi, $N;
    PrintOutMemory_InHexNL;

    ok Assemble(debug=>0, eq => <<END, avx512=>0);
  __01 0203 0405 0607  0809 0A0B 0C0D 0E0F  1011 1213 1415 1617  1819 1A1B 1C1D 1E1F  2021 2223 2425 2627  2829 2A2B 2C2D 2E2F  3031 3233 3435 3637  3839 3A3B 3C3D 3E3F  4041 4243 4445 4647  4849 4A4B 4C4D 4E4F  5051 5253 5455 5657  5859 5A5B 5C5D 5E5F  6061 6263 6465 6667  6869 6A6B 6C6D 6E6F  7071 7273 7475 7677  7879 7A7B 7C7D 7E7F  8081 8283 8485 8687  8889 8A8B 8C8D 8E8F  9091 9293 9495 9697  9899 9A9B 9C9D 9E9F  A0A1 A2A3 A4A5 A6A7  A8A9 AAAB ACAD AEAF  B0B1 B2B3 B4B5 B6B7  B8B9 BABB BCBD BEBF  C0C1 C2C3 C4C5 C6C7  C8C9 CACB CCCD CECF  D0D1 D2D3 D4D5 D6D7  D8D9 DADB DCDD DEDF  E0E1 E2E3 E4E5 E6E7  E8E9 EAEB ECED EEEF  F0F1 F2F3 F4F5 F6F7  F8F9 FAFB FCFD FEFF
  END


=head3 PrintMemory_InHex($channel)

Dump memory from the address in rax for the length in rdi on the specified channel. As this method prints in blocks of 8 up to 7 bytes will be missing from the end unless the length is a multiple of 8 .

     Parameter  Description
  1  $channel   Channel

=head3 PrintErrMemory_InHex()

Dump memory from the address in rax for the length in rdi on stderr.


=head3 PrintOutMemory_InHex()

Dump memory from the address in rax for the length in rdi on stdout.


=head3 PrintErrMemory_InHexNL()

Dump memory from the address in rax for the length in rdi and then print a new line.


=head3 PrintOutMemory_InHexNL()

Dump memory from the address in rax for the length in rdi and then print a new line.


=head3 PrintMemory($channel)

Print the memory addressed by rax for a length of rdi on the specified channel.

     Parameter  Description
  1  $channel   Channel

B<Example:>


    my $file = V(file => Rs $0);
    my ($address, $size) = ReadFile $file;                                      # Read file into memory
    $address->setReg(rax);                                                      # Address of file in memory
    $size   ->setReg(rdi);                                                      # Length  of file in memory
    PrintOutMemory;                                                             # Print contents of memory to stdout

    my $r = Assemble;                                                           # Assemble and execute
    ok stringMd5Sum($r) eq fileMd5Sum($0);                                      # Output contains this file


=head3 PrintMemoryNL()

Print the memory addressed by rax for a length of rdi on the specified channel followed by a new line.


=head3 PrintErrMemory()

Print the memory addressed by rax for a length of rdi on stderr.


=head3 PrintOutMemory()

Print the memory addressed by rax for a length of rdi on stdout.


B<Example:>


    Comment "Print a string from memory";
    my $s = "Hello World";
    Mov rax, Rs($s);
    Mov rdi, length $s;

    PrintOutMemory;  # 

    Exit(0);

    ok Assemble =~ m(Hello World);


=head3 PrintErrMemoryNL()

Print the memory addressed by rax for a length of rdi followed by a new line on stderr.


=head3 PrintOutMemoryNL()

Print the memory addressed by rax for a length of rdi followed by a new line on stdout.


B<Example:>


    my $s = Rs("Hello World

Hello Skye");
    my $l = StringLength(my $t = V string => $s);
    $t->setReg(rax);
    $l->setReg(rdi);

    PrintOutMemoryNL;  # 


    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  Hello World

  Hello Skye
  END


=head3 AllocateMemory($size)

Allocate the variable specified amount of memory via mmap and return its address as a variable.

     Parameter  Description
  1  $size      Size as a variable

B<Example:>


    my $N = K size => 2048;
    my $q = Rs('a'..'p');

    my $address = AllocateMemory $N;  # 


    Vmovdqu8 xmm0, "[$q]";
    $address->setReg(rax);
    Vmovdqu8 "[rax]", xmm0;
    Mov rdi, 16;
    PrintOutMemory;
    PrintOutNL;

    FreeMemory $address, $N;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  abcdefghijklmnop
  END

    my $N = K size => 4096;                                                     # Size of the initial allocation which should be one or more pages


    my $A = AllocateMemory $N;  # 


    ClearMemory($A, $N);

    $A->setReg(rax);
    Mov rdi, 128;
    PrintOutMemory_InHexNL;

    FreeMemory $A, $N;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  END

    my $N = 256;
    my $s = Rb 0..$N-1;

    my $a = AllocateMemory K size => $N;  # 

    CopyMemory(V(source => $s), $a, K(size => $N));


    my $b = AllocateMemory K size => $N;  # 

    CopyMemory($a, $b, K size => $N);

    $b->setReg(rax);
    Mov rdi, $N;
    PrintOutMemory_InHexNL;

    ok Assemble(debug=>0, eq => <<END, avx512=>0);
  __01 0203 0405 0607  0809 0A0B 0C0D 0E0F  1011 1213 1415 1617  1819 1A1B 1C1D 1E1F  2021 2223 2425 2627  2829 2A2B 2C2D 2E2F  3031 3233 3435 3637  3839 3A3B 3C3D 3E3F  4041 4243 4445 4647  4849 4A4B 4C4D 4E4F  5051 5253 5455 5657  5859 5A5B 5C5D 5E5F  6061 6263 6465 6667  6869 6A6B 6C6D 6E6F  7071 7273 7475 7677  7879 7A7B 7C7D 7E7F  8081 8283 8485 8687  8889 8A8B 8C8D 8E8F  9091 9293 9495 9697  9899 9A9B 9C9D 9E9F  A0A1 A2A3 A4A5 A6A7  A8A9 AAAB ACAD AEAF  B0B1 B2B3 B4B5 B6B7  B8B9 BABB BCBD BEBF  C0C1 C2C3 C4C5 C6C7  C8C9 CACB CCCD CECF  D0D1 D2D3 D4D5 D6D7  D8D9 DADB DCDD DEDF  E0E1 E2E3 E4E5 E6E7  E8E9 EAEB ECED EEEF  F0F1 F2F3 F4F5 F6F7  F8F9 FAFB FCFD FEFF
  END


=head3 FreeMemory($address, $size)

Free memory specified by variables.

     Parameter  Description
  1  $address   Variable address of memory
  2  $size      Variable size of memory

B<Example:>


    my $N = K size => 4096;                                                     # Size of the initial allocation which should be one or more pages

    my $A = AllocateMemory $N;

    ClearMemory($A, $N);

    $A->setReg(rax);
    Mov rdi, 128;
    PrintOutMemory_InHexNL;


    FreeMemory $A, $N;  # 


    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  END


=head3 ClearMemory($address, $size)

Clear memory wit a variable address and variable length

     Parameter  Description
  1  $address   Address of memory as a variable
  2  $size      Size of memory as a variable

B<Example:>


    K(loop, 8+1)->for(sub
     {my ($index, $start, $next, $end) = @_;
      $index->setReg(15);
      Push r15;
     });

    Mov rax, rsp;
    Mov rdi, 8*9;
    PrintOutMemory_InHexNL;

    ClearMemory(V(address, rax), K(size, 8*9));  # 

    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  08__ ____ ____ ____  07__ ____ ____ ____  06__ ____ ____ ____  05__ ____ ____ ____  04__ ____ ____ ____  03__ ____ ____ ____  02__ ____ ____ ____  01__ ____ ____ ____  ____ ____ ____ ____
  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  END

    my $N = K size => 4096;                                                     # Size of the initial allocation which should be one or more pages

    my $A = AllocateMemory $N;


    ClearMemory($A, $N);  # 


    $A->setReg(rax);
    Mov rdi, 128;
    PrintOutMemory_InHexNL;

    FreeMemory $A, $N;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  END


=head3 CopyMemory($source, $target, $size)

Copy memory.

     Parameter  Description
  1  $source    Source address variable
  2  $target    Target address variable
  3  $size      Length variable

B<Example:>


    my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;
    my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;

    Vmovdqu8 xmm0, "[$s]";
    Vmovdqu8 xmm1, "[$t]";
    PrintOutRegisterInHex xmm0;
    PrintOutRegisterInHex xmm1;
    Sub rsp, 16;

    Mov rax, rsp;                                                               # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
    Mov rdi, 16;
    Mov rsi, $s;

    CopyMemory(V(source, rsi), V(target, rax), V(size, rdi));  # 

    PrintOutMemory_InHexNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
    xmm0: 0000 0000 0000 0004   0000 0003 0002 0100
    xmm1: 0000 0000 0000 0004   0000 0003 0002 0100
  __01 02__ 03__ ____  04__ ____ ____ ____
  END

    my $N = 256;
    my $s = Rb 0..$N-1;
    my $a = AllocateMemory K size => $N;

    CopyMemory(V(source => $s), $a, K(size => $N));  # 


    my $b = AllocateMemory K size => $N;

    CopyMemory($a, $b, K size => $N);  # 


    $b->setReg(rax);
    Mov rdi, $N;
    PrintOutMemory_InHexNL;

    ok Assemble(debug=>0, eq => <<END, avx512=>0);
  __01 0203 0405 0607  0809 0A0B 0C0D 0E0F  1011 1213 1415 1617  1819 1A1B 1C1D 1E1F  2021 2223 2425 2627  2829 2A2B 2C2D 2E2F  3031 3233 3435 3637  3839 3A3B 3C3D 3E3F  4041 4243 4445 4647  4849 4A4B 4C4D 4E4F  5051 5253 5455 5657  5859 5A5B 5C5D 5E5F  6061 6263 6465 6667  6869 6A6B 6C6D 6E6F  7071 7273 7475 7677  7879 7A7B 7C7D 7E7F  8081 8283 8485 8687  8889 8A8B 8C8D 8E8F  9091 9293 9495 9697  9899 9A9B 9C9D 9E9F  A0A1 A2A3 A4A5 A6A7  A8A9 AAAB ACAD AEAF  B0B1 B2B3 B4B5 B6B7  B8B9 BABB BCBD BEBF  C0C1 C2C3 C4C5 C6C7  C8C9 CACB CCCD CECF  D0D1 D2D3 D4D5 D6D7  D8D9 DADB DCDD DEDF  E0E1 E2E3 E4E5 E6E7  E8E9 EAEB ECED EEEF  F0F1 F2F3 F4F5 F6F7  F8F9 FAFB FCFD FEFF
  END


=head2 Files

Interact with the operating system via files.

=head3 OpenRead()

Open a file, whose name is addressed by rax, for read and return the file descriptor in rax.


B<Example:>


    Mov rax, Rs($0);                                                            # File to read

    OpenRead;                                                                   # Open file  # 

    PrintOutRegisterInHex rax;
    CloseFile;                                                                  # Close file
    PrintOutRegisterInHex rax;

    Mov rax, Rs(my $f = "zzzTemporaryFile.txt");                                # File to write
    OpenWrite;                                                                  # Open file
    CloseFile;                                                                  # Close file

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rax: 0000 0000 0000 0000
  END
    ok -e $f;                                                                   # Created file
    unlink $f;


=head3 OpenWrite()

Create the file named by the terminated string addressed by rax for write.


B<Example:>


    Mov rax, Rs($0);                                                            # File to read
    OpenRead;                                                                   # Open file
    PrintOutRegisterInHex rax;
    CloseFile;                                                                  # Close file
    PrintOutRegisterInHex rax;

    Mov rax, Rs(my $f = "zzzTemporaryFile.txt");                                # File to write

    OpenWrite;                                                                  # Open file  # 

    CloseFile;                                                                  # Close file

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rax: 0000 0000 0000 0000
  END
    ok -e $f;                                                                   # Created file
    unlink $f;


=head3 CloseFile()

Close the file whose descriptor is in rax.


B<Example:>


    Mov rax, Rs($0);                                                            # File to read
    OpenRead;                                                                   # Open file
    PrintOutRegisterInHex rax;

    CloseFile;                                                                  # Close file  # 

    PrintOutRegisterInHex rax;

    Mov rax, Rs(my $f = "zzzTemporaryFile.txt");                                # File to write
    OpenWrite;                                                                  # Open file

    CloseFile;                                                                  # Close file  # 


    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 0000 0003
     rax: 0000 0000 0000 0000
  END
    ok -e $f;                                                                   # Created file
    unlink $f;


=head3 StatSize()

Stat a file whose name is addressed by rax to get its size in rax.


B<Example:>


    Mov rax, Rs($0);                                                            # File to stat

    StatSize;                                                                   # Stat the file  # 

    PrintOutRegisterInHex rax;

    my $r = Assemble =~ s( ) ()gsr;
    if ($r =~ m(rax:([0-9a-f]{16}))is)                                          # Compare file size obtained with that from fileSize()
     {is_deeply $1, sprintf("%016X", fileSize($0));
     }


=head3 ReadChar()

Read a character from stdin and return it in rax else return -1 in rax if no character was read.


=head3 ReadLine()

Reads up to 8 characters followed by a terminating return and place them into rax.


B<Example:>


    my $e = q(readLine);
    my $f = writeTempFile("hello
world
");


    ReadLine;  # 

    PrintOutRaxAsTextNL;

    ReadLine;  # 

    PrintOutRaxAsTextNL;

    Assemble keep => $e;

    is_deeply scalar(qx(./$e < $f)), <<END;
  hello
  world
  END
    unlink $f;
  }

  #latest:
  if (1) {
    my $e = q(readInteger);
    my $f = writeTempFile("11
22
");

    ReadInteger;
    Shl rax, 1;
    PrintOutRaxInDecNL;
    ReadInteger;
    Shl rax, 1;
    PrintOutRaxInDecNL;

    Assemble keep => $e;

    is_deeply scalar(qx(./$e < $f)), <<END;
  22
  44
  END

    unlink $e, $f;


=head3 ReadInteger()

Reads an integer in decimal and returns it in rax.


B<Example:>


    my $e = q(readInteger);
    my $f = writeTempFile("11
22
");


    ReadInteger;  # 

    Shl rax, 1;
    PrintOutRaxInDecNL;

    ReadInteger;  # 

    Shl rax, 1;
    PrintOutRaxInDecNL;

    Assemble keep => $e;

    is_deeply scalar(qx(./$e < $f)), <<END;
  22
  44
  END

    unlink $e, $f;


=head3 ReadFile($File)

Read a file into memory.

     Parameter  Description
  1  $File      Variable addressing a zero terminated string naming the file

B<Example:>


    my $file = V(file => Rs $0);

    my ($address, $size) = ReadFile $file;                                      # Read file into memory  # 

    $address->setReg(rax);                                                      # Address of file in memory
    $size   ->setReg(rdi);                                                      # Length  of file in memory
    PrintOutMemory;                                                             # Print contents of memory to stdout

    my $r = Assemble;                                                           # Assemble and execute
    ok stringMd5Sum($r) eq fileMd5Sum($0);                                      # Output contains this file


=head3 executeFileViaBash($file)

Execute the file named in a variable

     Parameter  Description
  1  $file      File variable

B<Example:>


    my $s = CreateArea;                                                         # Create a string
    $s->ql(<<END);                                                              # Write code to execute
  #!/usr/bin/bash
  whoami
  ls -la
  pwd
  END
    $s->write         (my $f = V('file', Rs("zzz.sh")));                        # Write code to a file

    executeFileViaBash($f);                                                     # Execute the file  # 

    unlinkFile        ($f);                                                     # Delete the file

    my $u = qx(whoami); chomp($u);
    ok Assemble(emulator => 0) =~ m($u);                                        # The Intel Software Development Emulator is way too slow on these operations.


=head3 unlinkFile($file)

Unlink the named file.

     Parameter  Description
  1  $file      File variable

B<Example:>


    my $s = CreateArea;                                                         # Create a string
    $s->ql(<<END);                                                              # Write code to execute
  #!/usr/bin/bash
  whoami
  ls -la
  pwd
  END
    $s->write         (my $f = V('file', Rs("zzz.sh")));                        # Write code to a file
    executeFileViaBash($f);                                                     # Execute the file

    unlinkFile        ($f);                                                     # Delete the file  # 


    my $u = qx(whoami); chomp($u);
    ok Assemble(emulator => 0) =~ m($u);                                        # The Intel Software Development Emulator is way too slow on these operations.


=head1 Hash functions

Hash functions

=head2 Hash()

Hash a string addressed by rax with length held in rdi and return the hash code in r15.


B<Example:>


  # Make hash accept parameters at:

    Mov rax, "[rbp+24]";                                                        # Address of string as parameter
    StringLength(V string => rax)->setReg(rdi);                                 # Length of string to hash

    Hash();                                                                     # Hash string  # 


    PrintOutRegisterInHex r15;

    my $e = Assemble keep => 'hash';                                            # Assemble to the specified file name
    say STDERR qx($e "");
    say STDERR qx($e "a");
    ok qx($e "")  =~ m(r15: 0000 3F80 0000 3F80);                               # Test well known hashes
    ok qx($e "a") =~ m(r15: 0000 3F80 C000 45B2);


    if (0)                                                                      # Hash various strings  # 

     {my %r; my %f; my $count = 0;
      my $N = RegisterSize zmm0;

      if (1)                                                                    # Fixed blocks
       {for my $l(qw(a ab abc abcd), 'a a', 'a  a')
         {for my $i(1..$N)
           {my $t = $l x $i;
            last if $N < length $t;
            my $s = substr($t.(' ' x $N), 0, $N);
            next if $f{$s}++;
            my $r = qx($e "$s");
            say STDERR "$count  $r";
            if ($r =~ m(^.*r15:\s*(.*)$)m)
             {push $r{$1}->@*, $s;
              ++$count;
             }
           }
         }
       }

      if (1)                                                                    # Variable blocks
       {for my $l(qw(a ab abc abcd), '', 'a a', 'a  a')
         {for my $i(1..$N)
           {my $t = $l x $i;
            next if $f{$t}++;
            my $r = qx($e "$t");
            say STDERR "$count  $r";
            if ($r =~ m(^.*r15:\s*(.*)$)m)
             {push $r{$1}->@*, $t;
              ++$count;
             }
           }
         }
       }
      for my $r(keys %r)
       {delete $r{$r} if $r{$r}->@* < 2;
       }

      say STDERR dump(\%r);
      say STDERR "Keys hashed: ", $count;
      confess "Duplicates : ",  scalar keys(%r);
     }

    unlink 'hash';


=head1 Unicode

Convert between utf8 and utf32

=head2 convert_rax_from_utf32_to_utf8()

Convert a utf32 character held in rax to a utf8 character held in rax


B<Example:>



  # $ 	U+0024                 010 0100                00100100                     24
  #  	U+00A3 	          000 1010 0011                11000010 10100011            C2 A3
  #  	  U+0939    	0000 1001 0011 1001                11100000 10100100 10111001   E0 A4 B9
  #  	U+20AC    	0010 0000 1010 1100                11100010 10000010 10101100   E2 82 AC
  #  	U+D55C     	1101 0101 0101 1100                11101101 10010101 10011100   ED 95 9C
  #    	U+10348 	0 0001 0000 0011 0100 1000 	11110000 10010000 10001101 10001000   F0 90 8D 88

    Mov rax, 0x40;                                                              # 0x40

    convert_rax_from_utf32_to_utf8;  # 

    PrintOutRegisterInHex rax;

    Mov rax, 0x03b1;                                                            # 0xCE 0xB1

    convert_rax_from_utf32_to_utf8;  # 

    PrintOutRegisterInHex rax;

    Mov rax, 0x20ac;                                                            # 0xE2 0x82 0xAC;

    convert_rax_from_utf32_to_utf8;  # 

    PrintOutRegisterInHex rax;

    Mov rax, 0x10348;                                                           # 0xf0 0x90 0x8d 0x88

    convert_rax_from_utf32_to_utf8;  # 

    PrintOutRegisterInHex rax;

    ok Assemble eq => <<END;
     rax: 0000 0000 0000 0040
     rax: 0000 0000 0000 B1CE
     rax: 0000 0000 00AC 82E2
     rax: 0000 0000 888D 90F0
  END


=head2 GetNextUtf8CharAsUtf32($in, $out, $size, $fail)

Get the next UTF-8 encoded character from the addressed memory and return it as a UTF-32 char.

     Parameter  Description
  1  $in        Address of character variable
  2  $out       Output character variable
  3  $size      Output size of input
  4  $fail      Output error  if any

=head2 ConvertUtf8ToUtf32($u8, $size8, $u32, $size32, $count)

Convert a string of utf8 to an allocated block of utf32 and return its address and length.

     Parameter  Description
  1  $u8        Utf8 string address variable
  2  $size8     Utf8 length variable
  3  $u32       Utf32 string address variable
  4  $size32    Utf32 length variable
  5  $count     Number of utf8 characters converteed

B<Example:>


    my ($out, $size, $fail) = (V(out), V(size), V('fail'));

    my $Chars = Rb(0x24, 0xc2, 0xa2, 0xc9, 0x91, 0xE2, 0x82, 0xAC, 0xF0, 0x90, 0x8D, 0x88);
    my $chars = V(chars, $Chars);

    GetNextUtf8CharAsUtf32 $chars+0, $out, $size, $fail;                        # Dollar               UTF-8 Encoding: 0x24                UTF-32 Encoding: 0x00000024
    $out->out('out1 : ');     $size->outNL(' size : ');

    GetNextUtf8CharAsUtf32 $chars+1, $out, $size, $fail;                        # Cents                UTF-8 Encoding: 0xC2 0xA2           UTF-32 Encoding: 0x000000a2
    $out->out('out2 : ');     $size->outNL(' size : ');

    GetNextUtf8CharAsUtf32 $chars+3, $out, $size, $fail;                        # Alpha                UTF-8 Encoding: 0xC9 0x91           UTF-32 Encoding: 0x00000251
    $out->out('out3 : ');     $size->outNL(' size : ');

    GetNextUtf8CharAsUtf32 $chars+5, $out, $size, $fail;                        # Euro                 UTF-8 Encoding: 0xE2 0x82 0xAC      UTF-32 Encoding: 0x000020AC
    $out->out('out4 : ');     $size->outNL(' size : ');

    GetNextUtf8CharAsUtf32 $chars+8, $out, $size, $fail;                        # Gothic Letter Hwair  UTF-8 Encoding  0xF0 0x90 0x8D 0x88 UTF-32 Encoding: 0x00010348
    $out->out('out5 : ');     $size->outNL(' size : ');

    my $statement = qq(
    
AAAAAAAA);                        # A sample sentence to parse

    my $s = K(statement, Rutf8($statement));
    my $l = StringLength $s;

    my $address = AllocateMemory $l;                                            # Allocate enough memory for a copy of the string
    CopyMemory($s, $address, $l);

    GetNextUtf8CharAsUtf32 $address, $out, $size, $fail;
    $out->out('outA : ');     $size->outNL(' size : ');

    GetNextUtf8CharAsUtf32 $address+4, $out, $size, $fail;
    $out->out('outB : ');     $size->outNL(' size : ');

    GetNextUtf8CharAsUtf32 $address+5, $out, $size, $fail;
    $out->out('outC : ');     $size->outNL(' size : ');

    GetNextUtf8CharAsUtf32 $address+30, $out, $size, $fail;
    $out->out('outD : ');     $size->outNL(' size : ');

    GetNextUtf8CharAsUtf32 $address+35, $out, $size, $fail;
    $out->out('outE : ');     $size->outNL(' size : ');

    $address->printOutMemoryInHexNL($l);

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  out1 : 0000 0000 0000 0024 size : 0000 0000 0000 0001
  out2 : 0000 0000 0000 00A2 size : 0000 0000 0000 0002
  out3 : 0000 0000 0000 0251 size : 0000 0000 0000 0002
  out4 : 0000 0000 0000 20AC size : 0000 0000 0000 0003
  out5 : 0000 0000 0001 0348 size : 0000 0000 0000 0004
  outA : 0000 0000 0001 D5BA size : 0000 0000 0000 0004
  outB : 0000 0000 0000 000A size : 0000 0000 0000 0001
  outC : 0000 0000 0000 0020 size : 0000 0000 0000 0001
  outD : 0000 0000 0000 0020 size : 0000 0000 0000 0001
  outE : 0000 0000 0000 0010 size : 0000 0000 0000 0002
  F09D 96BA 0A20 F09D  918E F09D 91A0 F09D  91A0 F09D 9196 F09D  9194 F09D 919B 20E3  8090 E380 90F0 9D96  BB20 F09D 90A9 F09D  90A5 F09D 90AE F09D  90AC 20F0 9D96 BCE3  8091 E380 910A 4141  4141 4141 4141 0000
  END


=head2 ClassifyInRange($address, $size)

Character classification: classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1 formatted in double words with each double word in zmm0 having the classification in the highest 8 bits and with zmm0 and zmm1 having the utf32 character at the start (zmm0) and end (zmm1) of each range in the lowest 18 bits.  The classification bits from the first matching range are copied into the high (unused) byte of each utf32 character in the block of memory.  The effect is to replace the high order byte of each utf32 character with a classification code saying what type of character we are working.

     Parameter  Description
  1  $address   Variable address of utf32 string to classify
  2  $size      Variable length of utf32 string to classify

=head2 ClassifyWithInRange($address, $size)

Bracket classification: Classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1 formatted in double words with the classification range in the high byte of each dword in zmm0 and the utf32 character at the start (zmm0) and end (zmm1) of each range in the lower 18 bits of each dword.  The classification bits from the position within the first matching range are copied into the high (unused) byte of each utf32 character in the block of memory.  With bracket matching this gives us a normalized bracket number.

     Parameter  Description
  1  $address   Variable address of utf32 string to classify
  2  $size      Variable length of utf32 string to classify

=head2 ClassifyWithInRangeAndSaveOffset($address, $size)

Alphabetic classification: classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1 formatted in double words with the classification code in the highest byte of each double word in zmm0 and the offset of the first element in the range in the highest byte of each dword in zmm1.  The lowest 18 bits of each double word in zmm0 and zmm1  contain the utf32 characters marking the start and end of each range. The classification bits from zmm1 for the first matching range are copied into the high byte of each utf32 character in the block of memory.  The offset in the range is copied into the lowest byte of each utf32 character in the block of memory.  The middle two bytes are cleared.  The classification byte is placed in the lowest byte of the utf32 character.

     Parameter  Description
  1  $address   Variable address of utf32 string to classify
  2  $size      Variable length of utf32 string to classify

=head2 ClassifyWithInRangeAndSaveWordOffset($address, $size, $classification)

Alphabetic classification: classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1, zmm2 formatted in double words. Zmm0 contains the low end of the range, zmm1 the high end and zmm2 contains the range offset in the high word of each Dword and the lexical classification on the lowest byte of each dword. Each utf32 character recognized is replaced by a dword whose upper byte is the lexical classification and whose lowest word is the range offset.

     Parameter        Description
  1  $address         Variable address of string of utf32 characters
  2  $size            Variable size of string in utf32 characters
  3  $classification  Variable one byte classification code for this range

=head1 C Strings

C strings are a series of bytes terminated by a zero byte.

=head2 StringLength($string)

Length of a zero terminated string.

     Parameter  Description
  1  $string    String

B<Example:>


    my $s = Rs("Hello World

Hello Skye");

    my $l = StringLength(my $t = V string => $s);  # 

    $t->setReg(rax);
    $l->setReg(rdi);
    PrintOutMemoryNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  Hello World

  Hello Skye
  END


    StringLength(V(string, Rs("abcd")))->outNL;  # 

    Assemble(debug => 0, eq => <<END, avx512=>0);
  size: 0000 0000 0000 0004
  END


=head1 Areas

An area is single extensible block of memory which contains other data structures such as strings, arrays, trees within it.

=head2 DescribeArea(%options)

Describe a relocatable area.

     Parameter  Description
  1  %options   Optional variable addressing the start of the area

=head2 CreateArea(%options)

Create an relocatable area and returns its address in rax. We add a chain header so that 64 byte blocks of memory can be freed and reused within the area.

     Parameter  Description
  1  %options   Free=>1 adds a free chain.

=head2 Nasm::X86::Area::free($area)

Free an area

     Parameter  Description
  1  $area      Area descriptor

B<Example:>


    my $a = CreateArea;

    $a->q("a" x 256);
    $a->used->outNL;
    $a->size->outNL;
    $a->clear;
    $a->used->outNL;
    $a->size->outNL;

    $a->q("a" x 5000);
    $a->used->outNL;
    $a->size->outNL;
    $a->clear;
    $a->used->outNL;
    $a->size->outNL;

    $a->free;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  area used up: 0000 0000 0000 0100
  size of area: 0000 0000 0000 1000
  area used up: 0000 0000 0000 0000
  size of area: 0000 0000 0000 1000
  area used up: 0000 0000 0000 1388
  size of area: 0000 0000 0000 2000
  area used up: 0000 0000 0000 0000
  size of area: 0000 0000 0000 2000
  END


=head2 Nasm::X86::Area::used($area)

Return the currently used size of an area as a variable.

     Parameter  Description
  1  $area      Area descriptor

B<Example:>


    my $a = CreateArea;

    $a->q("a" x 256);
    $a->used->outNL;
    $a->size->outNL;
    $a->clear;
    $a->used->outNL;
    $a->size->outNL;

    $a->q("a" x 5000);
    $a->used->outNL;
    $a->size->outNL;
    $a->clear;
    $a->used->outNL;
    $a->size->outNL;

    $a->free;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  area used up: 0000 0000 0000 0100
  size of area: 0000 0000 0000 1000
  area used up: 0000 0000 0000 0000
  size of area: 0000 0000 0000 1000
  area used up: 0000 0000 0000 1388
  size of area: 0000 0000 0000 2000
  area used up: 0000 0000 0000 0000
  size of area: 0000 0000 0000 2000
  END


=head2 Nasm::X86::Area::size($area)

Get the size of an area as a variab;e.

     Parameter  Description
  1  $area      Area descriptor

B<Example:>


    my $a = CreateArea;

    $a->q("a" x 256);
    $a->used->outNL;
    $a->size->outNL;
    $a->clear;
    $a->used->outNL;
    $a->size->outNL;

    $a->q("a" x 5000);
    $a->used->outNL;
    $a->size->outNL;
    $a->clear;
    $a->used->outNL;
    $a->size->outNL;

    $a->free;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  area used up: 0000 0000 0000 0100
  size of area: 0000 0000 0000 1000
  area used up: 0000 0000 0000 0000
  size of area: 0000 0000 0000 1000
  area used up: 0000 0000 0000 1388
  size of area: 0000 0000 0000 2000
  area used up: 0000 0000 0000 0000
  size of area: 0000 0000 0000 2000
  END


=head2 Nasm::X86::Area::makeReadOnly($area)

Make an area read only.

     Parameter  Description
  1  $area      Area descriptor

=head2 Nasm::X86::Area::makeWriteable($area)

Make an area writable.

     Parameter  Description
  1  $area      Area descriptor

=head2 Alloc/Free

Allocate and free memory in an area, either once only but in variable size blocks or reusably in zmm sized blocks via the free block chain.

=head3 Nasm::X86::Area::allocate($area, $size)

Allocate the variable amount of space in the variable addressed area and return the offset of the allocation in the area as a variable.

     Parameter  Description
  1  $area      Area descriptor
  2  $size      Variable amount of allocation

=head3 Nasm::X86::Area::allocZmmBlock($area)

Allocate a block to hold a zmm register in the specified area and return the offset of the block as a variable.

     Parameter  Description
  1  $area      Area

B<Example:>


    my $a = CreateArea;

    my $m = $a->allocZmmBlock;
    K(K => Rd(1..16))->loadZmm(31);

    $a->putZmmBlock  ($m, 31);
    $a->dump("A");

    $a->getZmmBlock  ($m, 30);
    $a->clearZmmBlock($m);
    $a->getZmmBlock  ($m, 29);

    $a->clearZmmBlock($m);
    PrintOutRegisterInHex 31, 30, 29;

    ok Assemble eq => <<END;
  A
  Area     Size:     4096    Used:      128
  0000 0000 0000 0000 | __10 ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END

    my $a = CreateArea;

    K(loop => 3)->for(sub
     {my ($i, $start, $next, $end) = @_;
      $i->outNL;
      my $m1 = $a->allocZmmBlock;
      my $m2 = $a->allocZmmBlock;

      K(K => Rd(1..16))->loadZmm(31);
      K(K => Rd(17..32))->loadZmm(30);
      PrintOutRegisterInHex 31, 30;

      $a->putZmmBlock($m1, 31);
      $a->putZmmBlock($m2, 30);
      $a->dump("A");

      $a->getZmmBlock($m1, 30);
      $a->getZmmBlock($m2, 31);
      PrintOutRegisterInHex 31, 30;

      $a->clearZmmBlock($m1);
      $a->freeZmmBlock($m1);
      $a->dump("B");

      $a->freeZmmBlock($m2);
      $a->dump("C");
     });

    ok Assemble eq => <<END;
  index: 0000 0000 0000 0000
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0001
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0002
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  END


=head3 Nasm::X86::Area::freeChainSpace($area)

Count the number of blocks available on the free chain

     Parameter  Description
  1  $area      Area descriptor

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;
    $t->clear;
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;
    $t->clear;
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->free;
    $a->used->out("Clear tree:            u: ");
    $a->freeChainSpace->out(" f: ", " ");
    $a->size->outNL;

    $a->clear;
    $a->used->out("Clear area:           u: ");
    $a->freeChainSpace->out(" f: ", " ");
    $a->size->outNL;

    ok Assemble eq => <<END;
  t: 0000 0000 0000 0010 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0000 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0010 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0000 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  Clear tree:            u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  Clear area:           u: 0000 0000 0000 0000 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  END


=head2 Yggdrasil

The world tree from which we can address so many other things

=head2 Areas as Strings

Use the memory supplied by the area as a string - however, in general, this is too slow unless coupled with another slow operation such as executing a command, mapping a file or writing to a file.

=head3 Nasm::X86::Area::m($area, $address, $size)

Append the variable addressed content of variable size to the specified area.

     Parameter  Description
  1  $area      Area descriptor
  2  $address   Variable address of content
  3  $size      Variable length of content

=head3 Nasm::X86::Area::q($area, $string)

Append a constant string to the area.

     Parameter  Description
  1  $area      Area descriptor
  2  $string    String

=head3 Nasm::X86::Area::ql($area, $const)

Append a quoted string containing new line characters to the specified area.

     Parameter  Description
  1  $area      Area
  2  $const     Constant

=head3 Nasm::X86::Area::char($area, $char)

Append a character expressed as a decimal number to the specified area.

     Parameter  Description
  1  $area      Area descriptor
  2  $char      Number of character to be appended

=head3 Nasm::X86::Area::nl($area)

Append a new line to the area addressed by rax.

     Parameter  Description
  1  $area      Area descriptor

=head3 Nasm::X86::Area::z($area)

Append a trailing zero to the area addressed by rax.

     Parameter  Description
  1  $area      Area descriptor

=head3 Nasm::X86::Area::append($target, $source)

Append one area to another.

     Parameter  Description
  1  $target    Target area descriptor
  2  $source    Source area descriptor

=head3 Nasm::X86::Area::clear($area)

Clear an area

     Parameter  Description
  1  $area      Area descriptor

B<Example:>


    my $a = CreateArea;

    $a->q("a" x 256);
    $a->used->outNL;
    $a->size->outNL;
    $a->clear;
    $a->used->outNL;
    $a->size->outNL;

    $a->q("a" x 5000);
    $a->used->outNL;
    $a->size->outNL;
    $a->clear;
    $a->used->outNL;
    $a->size->outNL;

    $a->free;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  area used up: 0000 0000 0000 0100
  size of area: 0000 0000 0000 1000
  area used up: 0000 0000 0000 0000
  size of area: 0000 0000 0000 1000
  area used up: 0000 0000 0000 1388
  size of area: 0000 0000 0000 2000
  area used up: 0000 0000 0000 0000
  size of area: 0000 0000 0000 2000
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;
    $t->clear;
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;
    $t->clear;
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->free;
    $a->used->out("Clear tree:            u: ");
    $a->freeChainSpace->out(" f: ", " ");
    $a->size->outNL;

    $a->clear;
    $a->used->out("Clear area:           u: ");
    $a->freeChainSpace->out(" f: ", " ");
    $a->size->outNL;

    ok Assemble eq => <<END;
  t: 0000 0000 0000 0010 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0000 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0010 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0000 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  Clear tree:            u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  Clear area:           u: 0000 0000 0000 0000 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  END


=head3 Nasm::X86::Area::write($area, $file)

Write the content of the specified area to a file specified by a zero terminated string.

     Parameter  Description
  1  $area      Area descriptor
  2  $file      Variable addressing file name

=head3 Nasm::X86::Area::read($area, $file)

Read a file specified by a variable addressed zero terminated string and place the contents of the file into the named area.

     Parameter  Description
  1  $area      Area descriptor
  2  $file      Variable addressing file name

=head3 Nasm::X86::Area::out($area)

Print the specified area on sysout.

     Parameter  Description
  1  $area      Area descriptor

=head3 Nasm::X86::Area::outNL($area)

Print the specified area on sysout followed by a new line.

     Parameter  Description
  1  $area      Area descriptor

=head3 Nasm::X86::Area::dump($area, $title, $depth)

Dump details of an area.

     Parameter  Description
  1  $area      Area descriptor
  2  $title     Title string
  3  $depth     Optional variable number of 64 byte blocks to dump

B<Example:>


    my $a = CreateArea;

    my $m = $a->allocZmmBlock;
    K(K => Rd(1..16))->loadZmm(31);

    $a->putZmmBlock  ($m, 31);
    $a->dump("A");

    $a->getZmmBlock  ($m, 30);
    $a->clearZmmBlock($m);
    $a->getZmmBlock  ($m, 29);

    $a->clearZmmBlock($m);
    PrintOutRegisterInHex 31, 30, 29;

    ok Assemble eq => <<END;
  A
  Area     Size:     4096    Used:      128
  0000 0000 0000 0000 | __10 ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END

    my $a = CreateArea;

    K(loop => 3)->for(sub
     {my ($i, $start, $next, $end) = @_;
      $i->outNL;
      my $m1 = $a->allocZmmBlock;
      my $m2 = $a->allocZmmBlock;

      K(K => Rd(1..16))->loadZmm(31);
      K(K => Rd(17..32))->loadZmm(30);
      PrintOutRegisterInHex 31, 30;

      $a->putZmmBlock($m1, 31);
      $a->putZmmBlock($m2, 30);
      $a->dump("A");

      $a->getZmmBlock($m1, 30);
      $a->getZmmBlock($m2, 31);
      PrintOutRegisterInHex 31, 30;

      $a->clearZmmBlock($m1);
      $a->freeZmmBlock($m1);
      $a->dump("B");

      $a->freeZmmBlock($m2);
      $a->dump("C");
     });

    ok Assemble eq => <<END;
  index: 0000 0000 0000 0000
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0001
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0002
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  END


=head1 Tree

Tree constructed as sets of blocks in an area.

=head2 Nasm::X86::Area::CreateTree($area, %options)

Create a tree in an area.

     Parameter  Description
  1  $area      Area description
  2  %options   Tree options

=head2 Nasm::X86::Tree::size($tree)

Return in a variable the number of elements currently in the tree.

     Parameter  Description
  1  $tree      Tree descriptor

=head2 Insert

Insert a key into the tree.

=head3 Nasm::X86::Tree::put($tree, $key, $data)

Put a variable key and data into a tree. The data could be a tree descriptor to place a sub tree into a tree at the indicated key.

     Parameter  Description
  1  $tree      Tree definition
  2  $key       Key as a variable
  3  $data      Data as a variable or a tree descriptor

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    $t->put(K(key=>1), K(data=>0x11));
    $t->put(K(key=>2), K(data=>0x22));
    $t->put(K(key=>3), K(data=>0x33));
    $t->put(K(key=>4), K(data=>0x44));
    $a->dump("4444", K depth => 11);
    $t->dump("4444");

    ok Assemble eq => <<END;
  4444
  Area     Size:     4096    Used:      704
  0000 0000 0000 0000 | __10 ____ ____ ____  C002 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | __02 ____ ____ ____  04__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ C0__ ____
  0000 0000 0000 00C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ __01 ____
  0000 0000 0000 0100 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0140 | 03__ ____ 04__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  02__ ____ 8001 ____
  0000 0000 0000 0180 | 33__ ____ 44__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ C001 ____
  0000 0000 0000 01C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0200 | 02__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ 4002 ____
  0000 0000 0000 0240 | 22__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 8002 ____
  0000 0000 0000 0280 | 80__ ____ 4001 ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  4444
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :   34
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :   17
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    3    4
        Data :   51   68
      end
  end
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    $t->put(K(key=>1), K(data=>0x11));
    $t->put(K(key=>2), K(data=>0x22));
    $t->put(K(key=>3), K(data=>0x33));
    $t->put(K(key=>4), K(data=>0x44));
    $t->put(K(key=>5), K(data=>0x55));
    $a->dump("5555",   K depth => 11);

    ok Assemble eq => <<END;
  5555
  Area     Size:     4096    Used:      704
  0000 0000 0000 0000 | __10 ____ ____ ____  C002 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | __02 ____ ____ ____  05__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ C0__ ____
  0000 0000 0000 00C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ __01 ____
  0000 0000 0000 0100 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0140 | 03__ ____ 04__ ____  05__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  03__ ____ 8001 ____
  0000 0000 0000 0180 | 33__ ____ 44__ ____  55__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ C001 ____
  0000 0000 0000 01C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0200 | 02__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ 4002 ____
  0000 0000 0000 0240 | 22__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 8002 ____
  0000 0000 0000 0280 | 80__ ____ 4001 ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    $t->put(K(key=>1), K(data=>0x11));
    $t->put(K(key=>2), K(data=>0x22));
    $t->put(K(key=>3), K(data=>0x33));
    $t->put(K(key=>4), K(data=>0x44));
    $t->put(K(key=>5), K(data=>0x55));
    $t->splitNode(K split => 0x140);
    $a->dump("6666",   K depth => 14);

    ok Assemble eq => <<END;
  6666
  Area     Size:     4096    Used:      896
  0000 0000 0000 0000 | __10 ____ ____ ____  8003 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | __02 ____ ____ ____  05__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ C0__ ____
  0000 0000 0000 00C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ __01 ____
  0000 0000 0000 0100 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0140 | 03__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ 8001 ____
  0000 0000 0000 0180 | 33__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ C001 ____
  0000 0000 0000 01C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0200 | 02__ ____ 04__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  02__ ____ 4002 ____
  0000 0000 0000 0240 | 22__ ____ 44__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 8002 ____
  0000 0000 0000 0280 | 80__ ____ 4001 ____  C002 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 02C0 | 05__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ __03 ____
  0000 0000 0000 0300 | 55__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ 4003 ____
  0000 0000 0000 0340 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    $t->put(K(key=>1), K(data=>0x11));
    $t->put(K(key=>2), K(data=>0x22));
    $t->put(K(key=>3), K(data=>0x33));
    $t->put(K(key=>4), K(data=>0x44));
    $t->put(K(key=>5), K(data=>0x55));
    $t->put(K(key=>6), K(data=>0x66));
    $a->dump("6666",   K depth => 14);

    ok Assemble eq => <<END;
  6666
  Area     Size:     4096    Used:      896
  0000 0000 0000 0000 | __10 ____ ____ ____  8003 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | __02 ____ ____ ____  06__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ C0__ ____
  0000 0000 0000 00C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ __01 ____
  0000 0000 0000 0100 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0140 | 03__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ 8001 ____
  0000 0000 0000 0180 | 33__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ C001 ____
  0000 0000 0000 01C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0200 | 02__ ____ 04__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  02__ ____ 4002 ____
  0000 0000 0000 0240 | 22__ ____ 44__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 8002 ____
  0000 0000 0000 0280 | 80__ ____ 4001 ____  C002 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 02C0 | 05__ ____ 06__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  02__ ____ __03 ____
  0000 0000 0000 0300 | 55__ ____ 66__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ 4003 ____
  0000 0000 0000 0340 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    $t->put(K(key=>1), K(data=>0x11));
    $t->put(K(key=>2), K(data=>0x22));
    $t->put(K(key=>3), K(data=>0x33));
    $t->put(K(key=>4), K(data=>0x44));
    $t->put(K(key=>5), K(data=>0x55));
    $t->put(K(key=>6), K(data=>0x66));
    $t->put(K(key=>7), K(data=>0x77));
    $a->dump("7777",   K depth => 14);

    ok Assemble eq => <<END;
  7777
  Area     Size:     4096    Used:      896
  0000 0000 0000 0000 | __10 ____ ____ ____  8003 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | __02 ____ ____ ____  07__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ C0__ ____
  0000 0000 0000 00C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ __01 ____
  0000 0000 0000 0100 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0140 | 03__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ 8001 ____
  0000 0000 0000 0180 | 33__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ C001 ____
  0000 0000 0000 01C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0200 | 02__ ____ 04__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  02__ ____ 4002 ____
  0000 0000 0000 0240 | 22__ ____ 44__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 8002 ____
  0000 0000 0000 0280 | 80__ ____ 4001 ____  C002 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 02C0 | 05__ ____ 06__ ____  07__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  03__ ____ __03 ____
  0000 0000 0000 0300 | 55__ ____ 66__ ____  77__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ 4003 ____
  0000 0000 0000 0340 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    $t->put(K(key=>1), K(data=>0x11));
    $t->put(K(key=>2), K(data=>0x22));
    $t->put(K(key=>3), K(data=>0x33));
    $t->put(K(key=>4), K(data=>0x44));
    $t->put(K(key=>5), K(data=>0x55));
    $t->put(K(key=>6), K(data=>0x66));
    $t->put(K(key=>7), K(data=>0x77));
    $t->put(K(key=>8), K(data=>0x88));
    $t->dump("8888");

    ok Assemble eq => <<END;
  8888
  At:  500                    length:    1,  data:  540,  nodes:  580,  first:   40, root, parent
    Index:    0
    Keys :    4
    Data :   68
    Nodes:  200  440
      At:  200                length:    1,  data:  240,  nodes:  280,  first:   40,  up:  500, parent
        Index:    0
        Keys :    2
        Data :   34
        Nodes:   80  140
          At:   80            length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
            Index:    0
            Keys :    1
            Data :   17
          end
          At:  140            length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
            Index:    0
            Keys :    3
            Data :   51
          end
      end
      At:  440                length:    1,  data:  480,  nodes:  4C0,  first:   40,  up:  500, parent
        Index:    0
        Keys :    6
        Data :  102
        Nodes:  2C0  380
          At:  2C0            length:    1,  data:  300,  nodes:  340,  first:   40,  up:  440, leaf
            Index:    0
            Keys :    5
            Data :   85
          end
          At:  380            length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  440, leaf
            Index:    0    1
            Keys :    7    8
            Data :  119  136
          end
      end
  end
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K count => 128;

    $N->for(sub
     {my ($index, $start, $next, $end) = @_;
      my $l = $N-$index;
      $t->put($l, $l * 2);
      my $h = $N+$index;
      $t->put($h, $h * 2);
     });
    $t->put(K(zero=>0), K(zero=>0));
    $t->printInOrder("AAAA");

    PrintOutStringNL 'Indx   Found  Offset  Double   Found  Offset    Quad   Found  Offset    Octo   Found  Offset     *16   Found  Offset     *32   Found  Offset     *64   Found  Offset    *128   Found  Offset    *256   Found  Offset    *512';
    $N->for(sub
     {my ($index, $start, $next, $end) = @_;
      my $i = $index;
      my $j = $i * 2;
      my $k = $j * 2;
      my $l = $k * 2;
      my $m = $l * 2;
      my $n = $m * 2;
      my $o = $n * 2;
      my $p = $o * 2;
      my $q = $p * 2;
      $t->find($i); $i->outRightInDec(K width => 4); $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($j);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($k);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($l);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($m);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($n);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($o);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($p);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($q);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDecNL(K width => 8);
     });

    ok Assemble eq => <<END;
  AAAA 256:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F  40  41  42  43  44  45  46  47  48  49  4A  4B  4C  4D  4E  4F  50  51  52  53  54  55  56  57  58  59  5A  5B  5C  5D  5E  5F  60  61  62  63  64  65  66  67  68  69  6A  6B  6C  6D  6E  6F  70  71  72  73  74  75  76  77  78  79  7A  7B  7C  7D  7E  7F  80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF
  Indx   Found  Offset  Double   Found  Offset    Quad   Found  Offset    Octo   Found  Offset     *16   Found  Offset     *32   Found  Offset     *64   Found  Offset    *128   Found  Offset    *256   Found  Offset    *512
     0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0
     1      10      80       2       1     200       4       1     500       8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0
     2       1     200       4       1     500       8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0
     3       1    B540       6       1    B600      12       1    B6C0      24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0
     4       1     500       8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0
     5       1    B3C0      10       1    B180      20       1    AC40      40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0
     6       1    B600      12       1    B6C0      24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0
     7       1    B0C0      14       1    AB80      28       1    A040      56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0
     8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0
     9       1    AF40      18       1    A700      36       1    95C0      72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0
    10       1    B180      20       1    AC40      40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0
    11       1    AAC0      22       1    9F80      44       1    8840      88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0
    12       1    B6C0      24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0
    13       1    A940      26       1    9B00      52       1    7DC0     104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0
    14       1    AB80      28       1    A040      56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0
    15       1    A640      30       1    9500      60       1    71C0     120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0
    16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0               0       0
    17       1    A4C0      34       1    9080      68       1    6740     136       1    1640     272               0       0               0       0               0       0               0       0               0       0
    18       1    A700      36       1    95C0      72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0               0       0
    19       1    9EC0      38       1    8780      76       1    5840     152       1    2D80     304               0       0               0       0               0       0               0       0               0       0
    20       1    AC40      40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0               0       0
    21       1    9D40      42       1    8300      84       1    4DC0     168       1    4580     336               0       0               0       0               0       0               0       0               0       0
    22       1    9F80      44       1    8840      88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0               0       0
    23       1    9A40      46       1    7D00      92       1    41C0     184       1    5CC0     368               0       0               0       0               0       0               0       0               0       0
    24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0               0       0
    25       1    98C0      50       1    7880     100       1    3740     200       1    7580     400               0       0               0       0               0       0               0       0               0       0
    26       1    9B00      52       1    7DC0     104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0               0       0
    27       1    9440      54       1    7100     108       1    29C0     216       1    8CC0     432               0       0               0       0               0       0               0       0               0       0
    28       1    A040      56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0               0       0
    29       1    92C0      58       1    6C80     116       1    1F40     232       1    A400     464               0       0               0       0               0       0               0       0               0       0
    30       1    9500      60       1    71C0     120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0               0       0
    31       1    8FC0      62       1    6680     124       1    1340     248      10    AE80     496               0       0               0       0               0       0               0       0               0       0
    32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0               0       0               0       0
    33       1    8E40      66       1    6200     132       1     A40     264               0       0               0       0               0       0               0       0               0       0               0       0
    34       1    9080      68       1    6740     136       1    1640     272               0       0               0       0               0       0               0       0               0       0               0       0
    35       1    86C0      70       1    5780     140       1    1580     280               0       0               0       0               0       0               0       0               0       0               0       0
    36       1    95C0      72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0               0       0               0       0
    37       1    8540      74       1    5300     148       1    2180     296               0       0               0       0               0       0               0       0               0       0               0       0
    38       1    8780      76       1    5840     152       1    2D80     304               0       0               0       0               0       0               0       0               0       0               0       0
    39       1    8240      78       1    4D00     156       1    2CC0     312               0       0               0       0               0       0               0       0               0       0               0       0
    40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0               0       0               0       0
    41       1    80C0      82       1    4880     164       1    3980     328               0       0               0       0               0       0               0       0               0       0               0       0
    42       1    8300      84       1    4DC0     168       1    4580     336               0       0               0       0               0       0               0       0               0       0               0       0
    43       1    7C40      86       1    4100     172       1    44C0     344               0       0               0       0               0       0               0       0               0       0               0       0
    44       1    8840      88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0               0       0               0       0
    45       1    7AC0      90       1    3C80     180       1    5000     360               0       0               0       0               0       0               0       0               0       0               0       0
    46       1    7D00      92       1    41C0     184       1    5CC0     368               0       0               0       0               0       0               0       0               0       0               0       0
    47       1    77C0      94       1    3680     188       1    5C00     376               0       0               0       0               0       0               0       0               0       0               0       0
    48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0               0       0               0       0
    49       1    7640      98       1    3200     196       1    6980     392               0       0               0       0               0       0               0       0               0       0               0       0
    50       1    7880     100       1    3740     200       1    7580     400               0       0               0       0               0       0               0       0               0       0               0       0
    51       1    7040     102       1    2900     204       1    74C0     408               0       0               0       0               0       0               0       0               0       0               0       0
    52       1    7DC0     104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0               0       0               0       0
    53       1    6EC0     106       1    2480     212       1    8000     424               0       0               0       0               0       0               0       0               0       0               0       0
    54       1    7100     108       1    29C0     216       1    8CC0     432               0       0               0       0               0       0               0       0               0       0               0       0
    55       1    6BC0     110       1    1E80     220       1    8C00     440               0       0               0       0               0       0               0       0               0       0               0       0
    56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0               0       0               0       0
    57       1    6A40     114       1    1A00     228       1    9800     456               0       0               0       0               0       0               0       0               0       0               0       0
    58       1    6C80     116       1    1F40     232       1    A400     464               0       0               0       0               0       0               0       0               0       0               0       0
    59       1    65C0     118       1    1280     236       1    A340     472               0       0               0       0               0       0               0       0               0       0               0       0
    60       1    71C0     120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0               0       0               0       0
    61       1    6440     122       1     E00     244       1    AE80     488               0       0               0       0               0       0               0       0               0       0               0       0
    62       1    6680     124       1    1340     248      10    AE80     496               0       0               0       0               0       0               0       0               0       0               0       0
    63       1    6140     126       1     800     252      10    B300     504               0       0               0       0               0       0               0       0               0       0               0       0
    64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    65       1    5FC0     130       1     440     260               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    66       1    6200     132       1     A40     264               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    67       1    56C0     134       1     980     268               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    68       1    6740     136       1    1640     272               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    69       1    5540     138       1     F80     276               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    70       1    5780     140       1    1580     280               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    71       1    5240     142       1    14C0     284               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    73       1    50C0     146       1    1B80     292               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    74       1    5300     148       1    2180     296               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    75       1    4C40     150       1    20C0     300               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    76       1    5840     152       1    2D80     304               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    77       1    4AC0     154       1    2600     308               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    78       1    4D00     156       1    2CC0     312               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    79       1    47C0     158       1    2C00     316               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    81       1    4640     162       1    3380     324               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    82       1    4880     164       1    3980     328               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    83       1    4040     166       1    38C0     332               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    84       1    4DC0     168       1    4580     336               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    85       1    3EC0     170       1    3E00     340               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    86       1    4100     172       1    44C0     344               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    87       1    3BC0     174       1    4400     348               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    89       1    3A40     178       1    4A00     356               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    90       1    3C80     180       1    5000     360               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    91       1    35C0     182       1    4F40     364               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    92       1    41C0     184       1    5CC0     368               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    93       1    3440     186       1    5480     372               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    94       1    3680     188       1    5C00     376               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    95       1    3140     190       1    5B40     380               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    97       1    2FC0     194       1    6380     388               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    98       1    3200     196       1    6980     392               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    99       1    2840     198       1    68C0     396               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   100       1    3740     200       1    7580     400               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   101       1    26C0     202       1    6E00     404               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   102       1    2900     204       1    74C0     408               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   103       1    23C0     206       1    7400     412               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   105       1    2240     210       1    7A00     420               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   106       1    2480     212       1    8000     424               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   107       1    1DC0     214       1    7F40     428               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   108       1    29C0     216       1    8CC0     432               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   109       1    1C40     218       1    8480     436               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   110       1    1E80     220       1    8C00     440               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   111       1    1940     222       1    8B40     444               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   113       1    17C0     226       1    9200     452               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   114       1    1A00     228       1    9800     456               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   115       1    11C0     230       1    9740     460               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   116       1    1F40     232       1    A400     464               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   117       1    1040     234       1    9C80     468               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   118       1    1280     236       1    A340     472               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   119       1     D40     238       1    A280     476               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   121       1     BC0     242       1    A880     484               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   122       1     E00     244       1    AE80     488               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   123       1     740     246       1    ADC0     492               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   124       1    1340     248      10    AE80     496               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   125       1     5C0     250       1    B300     500               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   126       1     800     252      10    B300     504               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   127       1     2C0     254      10    B480     508               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  END


=head2 Find

Find a key in the tree. Trees have dword integer keys and so can act as arrays as well.

=head3 Nasm::X86::Tree::find($tree, $key)

Find a key in a tree and tests whether the found data is a sub tree.  The results are held in the variables "found", "data", "subTree" addressed by the tree descriptor. The key just searched for is held in the key field of the tree descriptor. The point at which it was found is held in B<found> which will be zero if the key was not found.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $key       Key field to search for

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K count => 128;

    $N->for(sub
     {my ($index, $start, $next, $end) = @_;
      my $l = $N-$index;
      $t->put($l, $l * 2);
      my $h = $N+$index;
      $t->put($h, $h * 2);
     });
    $t->put(K(zero=>0), K(zero=>0));
    $t->printInOrder("AAAA");

    PrintOutStringNL 'Indx   Found  Offset  Double   Found  Offset    Quad   Found  Offset    Octo   Found  Offset     *16   Found  Offset     *32   Found  Offset     *64   Found  Offset    *128   Found  Offset    *256   Found  Offset    *512';
    $N->for(sub
     {my ($index, $start, $next, $end) = @_;
      my $i = $index;
      my $j = $i * 2;
      my $k = $j * 2;
      my $l = $k * 2;
      my $m = $l * 2;
      my $n = $m * 2;
      my $o = $n * 2;
      my $p = $o * 2;
      my $q = $p * 2;
      $t->find($i); $i->outRightInDec(K width => 4); $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($j);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($k);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($l);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($m);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($n);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($o);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($p);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
      $t->find($q);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDecNL(K width => 8);
     });

    ok Assemble eq => <<END;
  AAAA 256:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F  40  41  42  43  44  45  46  47  48  49  4A  4B  4C  4D  4E  4F  50  51  52  53  54  55  56  57  58  59  5A  5B  5C  5D  5E  5F  60  61  62  63  64  65  66  67  68  69  6A  6B  6C  6D  6E  6F  70  71  72  73  74  75  76  77  78  79  7A  7B  7C  7D  7E  7F  80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF
  Indx   Found  Offset  Double   Found  Offset    Quad   Found  Offset    Octo   Found  Offset     *16   Found  Offset     *32   Found  Offset     *64   Found  Offset    *128   Found  Offset    *256   Found  Offset    *512
     0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0
     1      10      80       2       1     200       4       1     500       8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0
     2       1     200       4       1     500       8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0
     3       1    B540       6       1    B600      12       1    B6C0      24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0
     4       1     500       8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0
     5       1    B3C0      10       1    B180      20       1    AC40      40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0
     6       1    B600      12       1    B6C0      24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0
     7       1    B0C0      14       1    AB80      28       1    A040      56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0
     8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0
     9       1    AF40      18       1    A700      36       1    95C0      72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0
    10       1    B180      20       1    AC40      40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0
    11       1    AAC0      22       1    9F80      44       1    8840      88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0
    12       1    B6C0      24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0
    13       1    A940      26       1    9B00      52       1    7DC0     104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0
    14       1    AB80      28       1    A040      56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0
    15       1    A640      30       1    9500      60       1    71C0     120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0
    16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0               0       0
    17       1    A4C0      34       1    9080      68       1    6740     136       1    1640     272               0       0               0       0               0       0               0       0               0       0
    18       1    A700      36       1    95C0      72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0               0       0
    19       1    9EC0      38       1    8780      76       1    5840     152       1    2D80     304               0       0               0       0               0       0               0       0               0       0
    20       1    AC40      40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0               0       0
    21       1    9D40      42       1    8300      84       1    4DC0     168       1    4580     336               0       0               0       0               0       0               0       0               0       0
    22       1    9F80      44       1    8840      88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0               0       0
    23       1    9A40      46       1    7D00      92       1    41C0     184       1    5CC0     368               0       0               0       0               0       0               0       0               0       0
    24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0               0       0
    25       1    98C0      50       1    7880     100       1    3740     200       1    7580     400               0       0               0       0               0       0               0       0               0       0
    26       1    9B00      52       1    7DC0     104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0               0       0
    27       1    9440      54       1    7100     108       1    29C0     216       1    8CC0     432               0       0               0       0               0       0               0       0               0       0
    28       1    A040      56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0               0       0
    29       1    92C0      58       1    6C80     116       1    1F40     232       1    A400     464               0       0               0       0               0       0               0       0               0       0
    30       1    9500      60       1    71C0     120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0               0       0
    31       1    8FC0      62       1    6680     124       1    1340     248      10    AE80     496               0       0               0       0               0       0               0       0               0       0
    32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0               0       0               0       0
    33       1    8E40      66       1    6200     132       1     A40     264               0       0               0       0               0       0               0       0               0       0               0       0
    34       1    9080      68       1    6740     136       1    1640     272               0       0               0       0               0       0               0       0               0       0               0       0
    35       1    86C0      70       1    5780     140       1    1580     280               0       0               0       0               0       0               0       0               0       0               0       0
    36       1    95C0      72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0               0       0               0       0
    37       1    8540      74       1    5300     148       1    2180     296               0       0               0       0               0       0               0       0               0       0               0       0
    38       1    8780      76       1    5840     152       1    2D80     304               0       0               0       0               0       0               0       0               0       0               0       0
    39       1    8240      78       1    4D00     156       1    2CC0     312               0       0               0       0               0       0               0       0               0       0               0       0
    40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0               0       0               0       0
    41       1    80C0      82       1    4880     164       1    3980     328               0       0               0       0               0       0               0       0               0       0               0       0
    42       1    8300      84       1    4DC0     168       1    4580     336               0       0               0       0               0       0               0       0               0       0               0       0
    43       1    7C40      86       1    4100     172       1    44C0     344               0       0               0       0               0       0               0       0               0       0               0       0
    44       1    8840      88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0               0       0               0       0
    45       1    7AC0      90       1    3C80     180       1    5000     360               0       0               0       0               0       0               0       0               0       0               0       0
    46       1    7D00      92       1    41C0     184       1    5CC0     368               0       0               0       0               0       0               0       0               0       0               0       0
    47       1    77C0      94       1    3680     188       1    5C00     376               0       0               0       0               0       0               0       0               0       0               0       0
    48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0               0       0               0       0
    49       1    7640      98       1    3200     196       1    6980     392               0       0               0       0               0       0               0       0               0       0               0       0
    50       1    7880     100       1    3740     200       1    7580     400               0       0               0       0               0       0               0       0               0       0               0       0
    51       1    7040     102       1    2900     204       1    74C0     408               0       0               0       0               0       0               0       0               0       0               0       0
    52       1    7DC0     104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0               0       0               0       0
    53       1    6EC0     106       1    2480     212       1    8000     424               0       0               0       0               0       0               0       0               0       0               0       0
    54       1    7100     108       1    29C0     216       1    8CC0     432               0       0               0       0               0       0               0       0               0       0               0       0
    55       1    6BC0     110       1    1E80     220       1    8C00     440               0       0               0       0               0       0               0       0               0       0               0       0
    56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0               0       0               0       0
    57       1    6A40     114       1    1A00     228       1    9800     456               0       0               0       0               0       0               0       0               0       0               0       0
    58       1    6C80     116       1    1F40     232       1    A400     464               0       0               0       0               0       0               0       0               0       0               0       0
    59       1    65C0     118       1    1280     236       1    A340     472               0       0               0       0               0       0               0       0               0       0               0       0
    60       1    71C0     120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0               0       0               0       0
    61       1    6440     122       1     E00     244       1    AE80     488               0       0               0       0               0       0               0       0               0       0               0       0
    62       1    6680     124       1    1340     248      10    AE80     496               0       0               0       0               0       0               0       0               0       0               0       0
    63       1    6140     126       1     800     252      10    B300     504               0       0               0       0               0       0               0       0               0       0               0       0
    64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    65       1    5FC0     130       1     440     260               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    66       1    6200     132       1     A40     264               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    67       1    56C0     134       1     980     268               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    68       1    6740     136       1    1640     272               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    69       1    5540     138       1     F80     276               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    70       1    5780     140       1    1580     280               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    71       1    5240     142       1    14C0     284               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    73       1    50C0     146       1    1B80     292               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    74       1    5300     148       1    2180     296               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    75       1    4C40     150       1    20C0     300               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    76       1    5840     152       1    2D80     304               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    77       1    4AC0     154       1    2600     308               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    78       1    4D00     156       1    2CC0     312               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    79       1    47C0     158       1    2C00     316               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    81       1    4640     162       1    3380     324               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    82       1    4880     164       1    3980     328               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    83       1    4040     166       1    38C0     332               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    84       1    4DC0     168       1    4580     336               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    85       1    3EC0     170       1    3E00     340               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    86       1    4100     172       1    44C0     344               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    87       1    3BC0     174       1    4400     348               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    89       1    3A40     178       1    4A00     356               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    90       1    3C80     180       1    5000     360               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    91       1    35C0     182       1    4F40     364               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    92       1    41C0     184       1    5CC0     368               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    93       1    3440     186       1    5480     372               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    94       1    3680     188       1    5C00     376               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    95       1    3140     190       1    5B40     380               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    97       1    2FC0     194       1    6380     388               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    98       1    3200     196       1    6980     392               0       0               0       0               0       0               0       0               0       0               0       0               0       0
    99       1    2840     198       1    68C0     396               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   100       1    3740     200       1    7580     400               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   101       1    26C0     202       1    6E00     404               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   102       1    2900     204       1    74C0     408               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   103       1    23C0     206       1    7400     412               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   105       1    2240     210       1    7A00     420               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   106       1    2480     212       1    8000     424               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   107       1    1DC0     214       1    7F40     428               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   108       1    29C0     216       1    8CC0     432               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   109       1    1C40     218       1    8480     436               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   110       1    1E80     220       1    8C00     440               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   111       1    1940     222       1    8B40     444               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   113       1    17C0     226       1    9200     452               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   114       1    1A00     228       1    9800     456               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   115       1    11C0     230       1    9740     460               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   116       1    1F40     232       1    A400     464               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   117       1    1040     234       1    9C80     468               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   118       1    1280     236       1    A340     472               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   119       1     D40     238       1    A280     476               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   121       1     BC0     242       1    A880     484               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   122       1     E00     244       1    AE80     488               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   123       1     740     246       1    ADC0     492               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   124       1    1340     248      10    AE80     496               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   125       1     5C0     250       1    B300     500               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   126       1     800     252      10    B300     504               0       0               0       0               0       0               0       0               0       0               0       0               0       0
   127       1     2C0     254      10    B480     508               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  END


=head3 Nasm::X86::Tree::findFirst($tree)

Find the first element in a tree

     Parameter  Description
  1  $tree      Tree descriptor

B<Example:>


    my $N = K(key => 32);
    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    $N->for(sub
     {my ($i, $start, $next, $end) = @_;
      $t->put($i, $i);
     });

    $N->for(sub
     {my ($i, $start, $next, $end) = @_;
      $t->put($N + $i, $N + $i);
      $t->findFirst;

      If $t->key != $i,
      Then
       {PrintOutTraceBack "Reverse queue first failed at: "; $i->outNL;
       };
      $t->delete($i);
      If $t->size != $N,
      Then
       {PrintOutTraceBack "Reverse queue size failed at: "; $i->outNL;
       };
      $t->printInOrder("A");
     });

    ok Assemble eq => <<END;
  A  32:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20
  A  32:    2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21
  A  32:    3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22
  A  32:    4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
  A  32:    5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24
  A  32:    6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25
  A  32:    7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26
  A  32:    8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27
  A  32:    9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28
  A  32:    A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29
  A  32:    B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A
  A  32:    C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B
  A  32:    D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C
  A  32:    E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D
  A  32:    F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E
  A  32:   10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F
  A  32:   11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30
  A  32:   12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31
  A  32:   13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32
  A  32:   14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33
  A  32:   15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34
  A  32:   16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35
  A  32:   17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36
  A  32:   18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37
  A  32:   19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38
  A  32:   1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39
  A  32:   1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A
  A  32:   1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B
  A  32:   1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C
  A  32:   1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D
  A  32:   1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E
  A  32:   20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F
  END


=head3 Nasm::X86::Tree::findLast($tree)

Find the last key in a tree

     Parameter  Description
  1  $tree      Tree descriptor

B<Example:>


    my $N = K(key => 32);
    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    $N->for(sub
     {my ($i, $start, $next, $end) = @_;
      $t->put($N + $i, $N + $i);
     });

    $N->for(sub
     {my ($i, $start, $next, $end) = @_;
      $t->put($N - $i, $N - $i);
      $t->findLast;

      $t->delete($t->key);
       If $t->size != $N - 1,
       Then
        {PrintOutTraceBack "Queued size failed at: "; $i->outNL;
        };
      $t->printInOrder("A");
     });

    ok Assemble eq => <<END;
  A  31:   20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E
  A  31:   1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D
  A  31:   1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C
  A  31:   1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B
  A  31:   1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A
  A  31:   1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39
  A  31:   1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38
  A  31:   19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37
  A  31:   18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36
  A  31:   17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35
  A  31:   16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34
  A  31:   15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33
  A  31:   14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32
  A  31:   13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31
  A  31:   12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30
  A  31:   11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F
  A  31:   10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E
  A  31:    F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D
  A  31:    E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C
  A  31:    D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B
  A  31:    C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A
  A  31:    B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29
  A  31:    A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28
  A  31:    9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27
  A  31:    8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26
  A  31:    7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25
  A  31:    6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24
  A  31:    5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
  A  31:    4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22
  A  31:    3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21
  A  31:    2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20
  A  31:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F
  END


=head3 Nasm::X86::Tree::findNext($tree, $key)

Find the next key greater than the one specified.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $key       Key

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 8;
    $N->for(sub
     {my ($i) = @_;
      $t->put(2*$i, 2*$i);
     });

    (2*$N)->for(sub
     {my ($i) = @_;
      $i->outRightInDec(K(key => 4)); PrintOutString " -> ";
      $t->findNext($i);
      $t->found->out("f: ", " ");
      If $t->found > 0, Then {$t->key->out};
      PrintOutStringNL '.';
     });

    ok Assemble eq => <<END;
     0 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0002.
     1 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0002.
     2 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0004.
     3 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0004.
     4 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0006.
     5 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0006.
     6 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0008.
     7 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0008.
     8 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 000A.
     9 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 000A.
    10 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 000C.
    11 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 000C.
    12 -> f: 0000 0000 0000 0002 key: 0000 0000 0000 000E.
    13 -> f: 0000 0000 0000 0002 key: 0000 0000 0000 000E.
    14 -> f: 0000 0000 0000 0000 .
    15 -> f: 0000 0000 0000 0000 .
  END


=head3 Nasm::X86::Tree::findPrev($tree, $key)

Find the previous key less than the one specified.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $key       Key

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 8;
    $N->for(sub
     {my ($i) = @_;
      $t->put(2*$i, 2*$i);
     });

    (2*$N)->for(sub
     {my ($i) = @_;
      $i->outRightInDec(K(key => 4)); PrintOutString " -> ";
      $t->findPrev($i);
      $t->found->out("f: ", " ");
      If $t->found > 0, Then {$t->key->out};
      PrintOutStringNL '.';
     });

    ok Assemble eq => <<END;
     0 -> f: 0000 0000 0000 0000 .
     1 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0000.
     2 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0000.
     3 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0002.
     4 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0002.
     5 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0004.
     6 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0004.
     7 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0006.
     8 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0006.
     9 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0008.
    10 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 0008.
    11 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 000A.
    12 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 000A.
    13 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 000C.
    14 -> f: 0000 0000 0000 0001 key: 0000 0000 0000 000C.
    15 -> f: 0000 0000 0000 0002 key: 0000 0000 0000 000E.
  END


=head3 Nasm::X86::Tree::depth($tree, $node)

Return the depth of a node within a tree.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $node      Node

=head2 Sub trees

Construct trees of trees.

=head2 Delete

Delete a key from the tree

=head3 Nasm::X86::Tree::delete($tree, $key)

Find a key in a tree and delete it

     Parameter  Description
  1  $tree      Tree descriptor
  2  $key       Key field to delete

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $i2 = V  k => 2; $t->put($i2, $i2);
    my $i3 = V  k => 3; $t->put($i3, $i3);
    my $i4 = V  k => 4; $t->put($i4, $i4);
    my $i1 = V  k => 1; $t->put($i1, $i1);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("4"); $t->delete($i4);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

    ok Assemble eq => <<END;
     4
  4
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    3
    Data :    3
    Nodes:   80  140
      At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    1    2
        Data :    1    2
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    4
        Data :    4
      end
  end
     3
  X
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :    2
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    3
        Data :    3
      end
  end
  X   3:    1   2   3
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $i20 = V  k => 20; $t->put($i20, $i20);
    my $i30 = V  k => 30; $t->put($i30, $i30);
    my $i40 = V  k => 40; $t->put($i40, $i40);
    my $i10 = V  k => 10; $t->put($i10, $i10);
    my $i31 = V  k => 31; $t->put($i31, $i31);
    my $i32 = V  k => 32; $t->put($i32, $i32);
    my $i33 = V  k => 33; $t->put($i33, $i33);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("33"); $t->delete($i33);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("40"); $t->delete($i40);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

    ok Assemble eq => <<END;
     7
  33
  At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0    1
    Keys :   1E   20
    Data :   30   32
    Nodes:   80  140  2C0
      At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    A   14
        Data :   10   20
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :   1F
        Data :   31
      end
      At:  2C0                length:    2,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :   21   28
        Data :   33   40
      end
  end
     6
  40
  At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0    1
    Keys :   1E   20
    Data :   30   32
    Nodes:   80  140  2C0
      At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    A   14
        Data :   10   20
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :   1F
        Data :   31
      end
      At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
        Index:    0
        Keys :   28
        Data :   40
      end
  end
     5
  X
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :   1E
    Data :   30
    Nodes:   80  140
      At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    A   14
        Data :   10   20
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :   1F   20
        Data :   31   32
      end
  end
  X   5:    A  14  1E  1F  20
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $i1 = V  k =>  0; $t->put($i1, $i1);
    my $i2 = V  k => 11; $t->put($i2, $i2);
    my $i3 = V  k => 13; $t->put($i3, $i3);
    my $i4 = V  k => 15; $t->put($i4, $i4);
    $t->size->outRightInDecNL(K width => 4);
    $t->dump("1");
    $a->dump("AAA", K blocks => 12);
    $t->delete($i2);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

    ok Assemble eq => <<END;
     4
  1
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    B
    Data :   11
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    0
        Data :    0
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    D    F
        Data :   13   15
      end
  end
  AAA
  Area     Size:     4096    Used:      704
  0000 0000 0000 0000 | __10 ____ ____ ____  C002 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | __02 ____ ____ ____  04__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ C0__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ __01 ____
  0000 0000 0000 0100 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0140 | 0D__ ____ 0F__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  02__ ____ 8001 ____
  0000 0000 0000 0180 | 0D__ ____ 0F__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ C001 ____
  0000 0000 0000 01C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0200 | 0B__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ 4002 ____
  0000 0000 0000 0240 | 0B__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 8002 ____
  0000 0000 0000 0280 | 80__ ____ 4001 ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 02C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
     3
  X
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    D
    Data :   13
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    0
        Data :    0
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    F
        Data :   15
      end
  end
  X   3:    0   D   F
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $i1 = V  k => 1; $t->put($i1, $i1);
    my $i2 = V  k => 2; $t->put($i2, $i2);
    my $i3 = V  k => 3; $t->put($i3, $i3);
    my $i4 = V  k => 4; $t->put($i4, $i4);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("1"); $a->dump("AAA", K blocks => 12); $t->delete($i1);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

    ok Assemble eq => <<END;
     4
  1
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :    2
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    3    4
        Data :    3    4
      end
  end
  AAA
  Area     Size:     4096    Used:      704
  0000 0000 0000 0000 | __10 ____ ____ ____  C002 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | __02 ____ ____ ____  04__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ C0__ ____
  0000 0000 0000 00C0 | 01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ __01 ____
  0000 0000 0000 0100 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0140 | 03__ ____ 04__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  02__ ____ 8001 ____
  0000 0000 0000 0180 | 03__ ____ 04__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __02 ____ C001 ____
  0000 0000 0000 01C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 0200 | 02__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  01__ ____ 4002 ____
  0000 0000 0000 0240 | 02__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 8002 ____
  0000 0000 0000 0280 | 80__ ____ 4001 ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
  0000 0000 0000 02C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
     3
  X
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    3
    Data :    3
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    2
        Data :    2
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    4
        Data :    4
      end
  end
  X   3:    2   3   4
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $i1 = V  k => 1; $t->put($i1, $i1);
    my $i2 = V  k => 2; $t->put($i2, $i2);
    my $i3 = V  k => 3; $t->put($i3, $i3);
    my $i4 = V  k => 4; $t->put($i4, $i4);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("2"); $t->delete($i2);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

    ok Assemble eq => <<END;
     4
  2
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :    2
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    3    4
        Data :    3    4
      end
  end
     3
  X
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    3
    Data :    3
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    4
        Data :    4
      end
  end
  X   3:    1   3   4
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $i1 = V  k => 1; $t->put($i1, $i1);
    my $i2 = V  k => 2; $t->put($i2, $i2);
    my $i3 = V  k => 3; $t->put($i3, $i3);
    my $i4 = V  k => 4; $t->put($i4, $i4);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("3"); $t->delete($i3);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

    ok Assemble eq => <<END;
     4
  3
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :    2
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    3    4
        Data :    3    4
      end
  end
     3
  X
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :    2
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    4
        Data :    4
      end
  end
  X   3:    1   2   4
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $i1 = V  k => 1; $t->put($i1, $i1);
    my $i2 = V  k => 2; $t->put($i2, $i2);
    my $i3 = V  k => 3; $t->put($i3, $i3);
    my $i4 = V  k => 4; $t->put($i4, $i4);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("4"); $t->delete($i4);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

    ok Assemble eq => <<END;
     4
  4
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :    2
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    3    4
        Data :    3    4
      end
  end
     3
  X
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :    2
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    3
        Data :    3
      end
  end
  X   3:    1   2   3
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $i2 = V  k => 2; $t->put($i2, $i2);
    my $i1 = V  k => 1; $t->put($i1, $i1);
    my $i3 = V  k => 3; $t->put($i3, $i3);
    my $i4 = V  k => 4; $t->put($i4, $i4);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("0"); $t->delete($i2);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("2"); $t->delete($i3);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("3"); $t->delete($i4);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("4"); $t->delete($i1);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("1");

    ok Assemble eq => <<END;
     4
  0
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :    2
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    3    4
        Data :    3    4
      end
  end
     3
  2
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    3
    Data :    3
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :    1
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    4
        Data :    4
      end
  end
     2
  3
  At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0    1
    Keys :    1    4
    Data :    1    4
  end
     1
  4
  At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0
    Keys :    1
    Data :    1
  end
     0
  1
  - empty
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    $t->put(   K(k=>1), K(d=>11));
    $t->put(   K(k=>2), K(d=>22));
    $t->put(   K(k=>3), K(d=>33));
    $t->delete(K k=>1);  $t->dump("1");
    $t->delete(K k=>3);  $t->dump("3");
    $t->delete(K k=>2);  $t->dump("2");
    ok Assemble eq => <<END;
  1
  At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0    1
    Keys :    2    3
    Data :   22   33
  end
  3
  At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0
    Keys :    2
    Data :   22
  end
  2
  - empty
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    $t->put(   K(k=>1), K(d=>11));
    $t->put(   K(k=>2), K(d=>22));
    $t->put(   K(k=>3), K(d=>33));
    $t->put(   K(k=>4), K(d=>44));
    $t->dump("0");
    $t->delete(K k=>1);
    $t->dump("1");
    $t->delete(K k=>2);
    $t->dump("2");
    $t->delete(K k=>3);
    $t->dump("3");
    $t->delete(K k=>4);
    $t->dump("4");
    ok Assemble eq => <<END;
  0
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :   22
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :   11
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    3    4
        Data :   33   44
      end
  end
  1
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    3
    Data :   33
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    2
        Data :   22
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    4
        Data :   44
      end
  end
  2
  At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0    1
    Keys :    3    4
    Data :   33   44
  end
  3
  At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0
    Keys :    4
    Data :   44
  end
  4
  - empty
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    $t->put(   K(k=>1), K(d=>11));
    $t->put(   K(k=>2), K(d=>22));
    $t->put(   K(k=>3), K(d=>33));
    $t->put(   K(k=>4), K(d=>44));
    $t->dump("0");
    $t->delete(K k=>3);
    $t->dump("3");
    $t->delete(K k=>4);
    $t->dump("4");
    $t->delete(K k=>2);
    $t->dump("2");
    $t->delete(K k=>1);
    $t->dump("1");
    ok Assemble eq => <<END;
  0
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :   22
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :   11
      end
      At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    3    4
        Data :   33   44
      end
  end
  3
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :   22
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :   11
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    4
        Data :   44
      end
  end
  4
  At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0    1
    Keys :    1    2
    Data :   11   22
  end
  2
  At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0
    Keys :    1
    Data :   11
  end
  1
  - empty
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $i1 = V  k => 1; $t->put($i1, $i1);
    my $i2 = V  k => 2; $t->put($i2, $i2);
    my $i3 = V  k => 3; $t->put($i3, $i3);
    my $i4 = V  k => 4; $t->put($i4, $i4);
    my $i5 = V  k => 5; $t->put($i5, $i5);
    my $i6 = V  k => 6; $t->put($i6, $i6);
    my $i7 = V  k => 7; $t->put($i7, $i7);
    my $i8 = V  k => 8; $t->put($i8, $i8);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("1"); $t->delete($i1);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("2"); $t->delete($i2);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("3"); $t->delete($i3);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("4"); $t->delete($i4);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("5"); $t->delete($i5);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("6"); $t->delete($i6);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("7"); $t->delete($i7);
    $t->size->outRightInDecNL(K width => 4);  $t->dump("8"); $t->delete($i8);
    $t->size->outRightInDecNL(K width => 4);
    $t->dump("X");

    ok Assemble eq => <<END;
     8
  1
  At:  500                    length:    1,  data:  540,  nodes:  580,  first:   40, root, parent
    Index:    0
    Keys :    4
    Data :    4
    Nodes:  200  440
      At:  200                length:    1,  data:  240,  nodes:  280,  first:   40,  up:  500, parent
        Index:    0
        Keys :    2
        Data :    2
        Nodes:   80  140
          At:   80            length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
            Index:    0
            Keys :    1
            Data :    1
          end
          At:  140            length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
            Index:    0
            Keys :    3
            Data :    3
          end
      end
      At:  440                length:    1,  data:  480,  nodes:  4C0,  first:   40,  up:  500, parent
        Index:    0
        Keys :    6
        Data :    6
        Nodes:  2C0  380
          At:  2C0            length:    1,  data:  300,  nodes:  340,  first:   40,  up:  440, leaf
            Index:    0
            Keys :    5
            Data :    5
          end
          At:  380            length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  440, leaf
            Index:    0    1
            Keys :    7    8
            Data :    7    8
          end
      end
  end
     7
  2
  At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0    1
    Keys :    4    6
    Data :    4    6
    Nodes:   80  2C0  380
      At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    2    3
        Data :    2    3
      end
      At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    5
        Data :    5
      end
      At:  380                length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    7    8
        Data :    7    8
      end
  end
     6
  3
  At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0    1
    Keys :    4    6
    Data :    4    6
    Nodes:   80  2C0  380
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    3
        Data :    3
      end
      At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    5
        Data :    5
      end
      At:  380                length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    7    8
        Data :    7    8
      end
  end
     5
  4
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    6
    Data :    6
    Nodes:   80  380
      At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    4    5
        Data :    4    5
      end
      At:  380                length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    7    8
        Data :    7    8
      end
  end
     4
  5
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    6
    Data :    6
    Nodes:   80  380
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    5
        Data :    5
      end
      At:  380                length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
        Index:    0    1
        Keys :    7    8
        Data :    7    8
      end
  end
     3
  6
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    7
    Data :    7
    Nodes:   80  380
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    6
        Data :    6
      end
      At:  380                length:    1,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    8
        Data :    8
      end
  end
     2
  7
  At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0    1
    Keys :    7    8
    Data :    7    8
  end
     1
  8
  At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0
    Keys :    8
    Data :    8
  end
     0
  X
  - empty
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 20;
    $N->for(sub                                                                 # Load tree
     {my ($i) = @_;
      $t->put($i, $i);
     });
    $t->size->outNL;        $t->printInOrder("AA");
    $t->delete(K k =>  0);  $t->printInOrder(" 0");
    $t->delete(K k =>  9);  $t->printInOrder(" 9");
    $t->delete(K k =>  1);  $t->printInOrder(" 1");
    $t->delete(K k =>  8);  $t->printInOrder(" 8");
    $t->delete(K k =>  2);  $t->printInOrder(" 2");
    $t->delete(K k =>  7);  $t->printInOrder(" 7");
    $t->delete(K k =>  3);  $t->printInOrder(" 3");
    $t->delete(K k =>  6);  $t->printInOrder(" 6");
    $t->delete(K k =>  4);  $t->printInOrder(" 4");
    $t->delete(K k =>  5);  $t->printInOrder(" 5");
    $t->delete(K k => 10);  $t->printInOrder("10");
    $t->delete(K k => 19);  $t->printInOrder("19");
    $t->delete(K k => 11);  $t->printInOrder("11");
    $t->delete(K k => 18);  $t->printInOrder("18");
    $t->delete(K k => 12);  $t->printInOrder("12");
    $t->delete(K k => 17);  $t->printInOrder("17");
    $t->delete(K k => 13);  $t->printInOrder("13");
    $t->delete(K k => 16);  $t->printInOrder("16");
    $t->delete(K k => 14);  $t->printInOrder("14");
    $t->delete(K k => 15);  $t->printInOrder("15");

    ok Assemble eq => <<END;
  size of tree: 0000 0000 0000 0014
  AA  20:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13
   0  19:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13
   9  18:    1   2   3   4   5   6   7   8   A   B   C   D   E   F  10  11  12  13
   1  17:    2   3   4   5   6   7   8   A   B   C   D   E   F  10  11  12  13
   8  16:    2   3   4   5   6   7   A   B   C   D   E   F  10  11  12  13
   2  15:    3   4   5   6   7   A   B   C   D   E   F  10  11  12  13
   7  14:    3   4   5   6   A   B   C   D   E   F  10  11  12  13
   3  13:    4   5   6   A   B   C   D   E   F  10  11  12  13
   6  12:    4   5   A   B   C   D   E   F  10  11  12  13
   4  11:    5   A   B   C   D   E   F  10  11  12  13
   5  10:    A   B   C   D   E   F  10  11  12  13
  10   9:    B   C   D   E   F  10  11  12  13
  19   8:    B   C   D   E   F  10  11  12
  11   7:    C   D   E   F  10  11  12
  18   6:    C   D   E   F  10  11
  12   5:    D   E   F  10  11
  17   4:    D   E   F  10
  13   3:    E   F  10
  16   2:    E   F
  14   1:    F
  15- empty
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;
    $N->for(sub
     {my ($i) = @_;
      $t->put($i, $i);
     });
    $t->printInOrder(" 0"); $t->delete(K k =>  0);
    $t->printInOrder(" 2"); $t->delete(K k =>  2);
    $t->printInOrder(" 4"); $t->delete(K k =>  4);
    $t->printInOrder(" 6"); $t->delete(K k =>  6);
    $t->printInOrder(" 8"); $t->delete(K k =>  8);
    $t->printInOrder("10"); $t->delete(K k => 10);
    $t->printInOrder("12"); $t->delete(K k => 12);
    $t->printInOrder("14"); $t->delete(K k => 14);
    $t->printInOrder(" 1"); $t->delete(K k =>  1);
    $t->printInOrder(" 3"); $t->delete(K k =>  3);
    $t->printInOrder(" 5"); $t->delete(K k =>  5);
    $t->printInOrder(" 7"); $t->delete(K k =>  7);
    $t->printInOrder(" 9"); $t->delete(K k =>  9);
    $t->printInOrder("11"); $t->delete(K k => 11);
    $t->printInOrder("13"); $t->delete(K k => 13);
    $t->printInOrder("15"); $t->delete(K k => 15);
    $t->printInOrder("XX");

    ok Assemble eq => <<END;
   0  16:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   2  15:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   4  14:    1   3   4   5   6   7   8   9   A   B   C   D   E   F
   6  13:    1   3   5   6   7   8   9   A   B   C   D   E   F
   8  12:    1   3   5   7   8   9   A   B   C   D   E   F
  10  11:    1   3   5   7   9   A   B   C   D   E   F
  12  10:    1   3   5   7   9   B   C   D   E   F
  14   9:    1   3   5   7   9   B   D   E   F
   1   8:    1   3   5   7   9   B   D   F
   3   7:    3   5   7   9   B   D   F
   5   6:    5   7   9   B   D   F
   7   5:    7   9   B   D   F
   9   4:    9   B   D   F
  11   3:    B   D   F
  13   2:    D   F
  15   1:    F
  XX- empty
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K max => 8;

    $N->for(sub                                                                 # Load tree
     {my ($i) = @_;
      $t->put(         $i,     2 *        $i);
      $t->put(2 * $N - $i - 1, 2 * ($N -  $i));
     });
  #  $t->printInOrder("Full");

    ($N-1)->for(sub                                                             # Delete elements
     {my ($i) = @_;
      my $n1 = ($N + $i)->clone("1111"); my $n2 = ($N - $i - 1)->clone("2222");

      $n1->outNL;
      $t->delete($n1);
      $t->printInOrder("1111");

      $n2->outNL;
      $t->delete($n2);
      $t->printInOrder("2222");
     });
    $t->dump("Two:");
    $t->size->outRightInDecNL(K width => 4);

    ok Assemble eq => <<END;
  1111: 0000 0000 0000 0008
  1111  15:    0   1   2   3   4   5   6   7   9   A   B   C   D   E   F
  2222: 0000 0000 0000 0007
  2222  14:    0   1   2   3   4   5   6   9   A   B   C   D   E   F
  1111: 0000 0000 0000 0009
  1111  13:    0   1   2   3   4   5   6   A   B   C   D   E   F
  2222: 0000 0000 0000 0006
  2222  12:    0   1   2   3   4   5   A   B   C   D   E   F
  1111: 0000 0000 0000 000A
  1111  11:    0   1   2   3   4   5   B   C   D   E   F
  2222: 0000 0000 0000 0005
  2222  10:    0   1   2   3   4   B   C   D   E   F
  1111: 0000 0000 0000 000B
  1111   9:    0   1   2   3   4   C   D   E   F
  2222: 0000 0000 0000 0004
  2222   8:    0   1   2   3   C   D   E   F
  1111: 0000 0000 0000 000C
  1111   7:    0   1   2   3   D   E   F
  2222: 0000 0000 0000 0003
  2222   6:    0   1   2   D   E   F
  1111: 0000 0000 0000 000D
  1111   5:    0   1   2   E   F
  2222: 0000 0000 0000 0002
  2222   4:    0   1   E   F
  1111: 0000 0000 0000 000E
  1111   3:    0   1   F
  2222: 0000 0000 0000 0001
  2222   2:    0   F
  Two:
  At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
    Index:    0    1
    Keys :    0    F
    Data :    0   16
  end
     2
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K max => 100;

    $N->for(sub                                                                 # Load tree
     {my ($index, $start, $next, $end) = @_;
      $t->put($index, 2 * $index);
      If $t->size != $index + 1,
      Then
       {PrintOutStringNL "SSSS"; $index->outNL; Exit(0);
       };
     });

    $N->for(sub                                                                 # Check elements
     {my ($i) = @_;
      $t->find($i);
      If $t->found == 0,
      Then
       {PrintOutStringNL "AAAA"; $i->outNL; Exit(0);
       };
     });

    $N->for(sub                                                                 # Delete elements
     {my ($i) = @_;
      $t->delete($i);

      If $t->size != $N - $i - 1,
      Then
       {PrintOutStringNL "TTTT"; $i->outNL; Exit(0);
       };

      $N->for(sub                                                               # Check elements
       {my ($j) = @_;
        $t->find($j);
        If $t->found == 0,
        Then
         {If $j > $i,
          Then
           {PrintOutStringNL "BBBBB"; $j->outNL; Exit(0);                       # Not deleted yet so it should be findable
           };
         },
        Else
         {If $j <= $i,
          Then
           {PrintOutStringNL "CCCCC"; $j->outNL; Exit(0);                       # Deleted so should not be findable
           };
         };
       });
     });

    ok Assemble eq => <<END;
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;
    $N->for(sub
     {my ($i) = @_;
      $t->put($i, $i);
     });
    ($N/2)->for(sub
     {my ($i) = @_;
      $t->printInOrder("AAAA");
      $t->delete($i * 2);
     });
    ($N/2)->for(sub
     {my ($i) = @_;
      $t->printInOrder("BBBB");
      $t->delete($i * 2 + 1);
     });
    $t->printInOrder("CCCC");

    ok Assemble eq => <<END;
  AAAA  16:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
  AAAA  15:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
  AAAA  14:    1   3   4   5   6   7   8   9   A   B   C   D   E   F
  AAAA  13:    1   3   5   6   7   8   9   A   B   C   D   E   F
  AAAA  12:    1   3   5   7   8   9   A   B   C   D   E   F
  AAAA  11:    1   3   5   7   9   A   B   C   D   E   F
  AAAA  10:    1   3   5   7   9   B   C   D   E   F
  AAAA   9:    1   3   5   7   9   B   D   E   F
  BBBB   8:    1   3   5   7   9   B   D   F
  BBBB   7:    3   5   7   9   B   D   F
  BBBB   6:    5   7   9   B   D   F
  BBBB   5:    7   9   B   D   F
  BBBB   4:    9   B   D   F
  BBBB   3:    B   D   F
  BBBB   2:    D   F
  BBBB   1:    F
  CCCC- empty
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 36;
    $N->for(sub
     {my ($i) = @_;
      $t->put($i, $i);
     });
    $t->delete(K 1 =>  0); $t->printInOrder(" 0");
    $t->delete(K 1 =>  5); $t->printInOrder(" 5");
    $t->delete(K 1 => 10); $t->printInOrder("10");
    $t->delete(K 1 => 15); $t->printInOrder("15");
    $t->delete(K 1 => 20); $t->printInOrder("20");
    $t->delete(K 1 => 25); $t->printInOrder("25");
    $t->delete(K 1 => 30); $t->printInOrder("30");
    $t->delete(K 1 => 35); $t->printInOrder("35");

    $t->delete(K 1 =>  1); $t->printInOrder(" 1");
    $t->delete(K 1 =>  6); $t->printInOrder(" 6");
    $t->delete(K 1 => 11); $t->printInOrder("11");
    $t->delete(K 1 => 16); $t->printInOrder("16");
    $t->delete(K 1 => 21); $t->printInOrder("21");
    $t->delete(K 1 => 26); $t->printInOrder("26");
    $t->delete(K 1 => 31); $t->printInOrder("31");

    $t->delete(K 1 =>  2); $t->printInOrder(" 2");
    $t->delete(K 1 =>  7); $t->printInOrder(" 7");
    $t->delete(K 1 => 12); $t->printInOrder("12");
    $t->delete(K 1 => 17); $t->printInOrder("17");
    $t->delete(K 1 => 22); $t->printInOrder("22");
    $t->delete(K 1 => 27); $t->printInOrder("27");
    $t->delete(K 1 => 32); $t->printInOrder("32");

    $t->delete(K 1 =>  3); $t->printInOrder(" 3");
    $t->delete(K 1 =>  8); $t->printInOrder(" 8");
    $t->delete(K 1 => 13); $t->printInOrder("13");
    $t->delete(K 1 => 18); $t->printInOrder("18");
    $t->delete(K 1 => 23); $t->printInOrder("23");
    $t->delete(K 1 => 28); $t->printInOrder("28");
    $t->delete(K 1 => 33); $t->printInOrder("33");

    $t->delete(K 1 =>  4); $t->printInOrder(" 4");
    $t->delete(K 1 =>  9); $t->printInOrder(" 9");
    $t->delete(K 1 => 14); $t->printInOrder("14");
    $t->delete(K 1 => 19); $t->printInOrder("19");
    $t->delete(K 1 => 24); $t->printInOrder("24");
    $t->delete(K 1 => 29); $t->printInOrder("29");
    $t->delete(K 1 => 34); $t->printInOrder("34");

    ok Assemble eq => <<END;
   0  35:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
   5  34:    1   2   3   4   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
  10  33:    1   2   3   4   6   7   8   9   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
  15  32:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
  20  31:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
  25  30:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1E  1F  20  21  22  23
  30  29:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22  23
  35  28:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
   1  27:    2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
   6  26:    2   3   4   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
  11  25:    2   3   4   7   8   9   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
  16  24:    2   3   4   7   8   9   C   D   E  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
  21  23:    2   3   4   7   8   9   C   D   E  11  12  13  16  17  18  1A  1B  1C  1D  1F  20  21  22
  26  22:    2   3   4   7   8   9   C   D   E  11  12  13  16  17  18  1B  1C  1D  1F  20  21  22
  31  21:    2   3   4   7   8   9   C   D   E  11  12  13  16  17  18  1B  1C  1D  20  21  22
   2  20:    3   4   7   8   9   C   D   E  11  12  13  16  17  18  1B  1C  1D  20  21  22
   7  19:    3   4   8   9   C   D   E  11  12  13  16  17  18  1B  1C  1D  20  21  22
  12  18:    3   4   8   9   D   E  11  12  13  16  17  18  1B  1C  1D  20  21  22
  17  17:    3   4   8   9   D   E  12  13  16  17  18  1B  1C  1D  20  21  22
  22  16:    3   4   8   9   D   E  12  13  17  18  1B  1C  1D  20  21  22
  27  15:    3   4   8   9   D   E  12  13  17  18  1C  1D  20  21  22
  32  14:    3   4   8   9   D   E  12  13  17  18  1C  1D  21  22
   3  13:    4   8   9   D   E  12  13  17  18  1C  1D  21  22
   8  12:    4   9   D   E  12  13  17  18  1C  1D  21  22
  13  11:    4   9   E  12  13  17  18  1C  1D  21  22
  18  10:    4   9   E  13  17  18  1C  1D  21  22
  23   9:    4   9   E  13  18  1C  1D  21  22
  28   8:    4   9   E  13  18  1D  21  22
  33   7:    4   9   E  13  18  1D  22
   4   6:    9   E  13  18  1D  22
   9   5:    E  13  18  1D  22
  14   4:   13  18  1D  22
  19   3:   18  1D  22
  24   2:   1D  22
  29   1:   22
  34- empty
  END


=head2 Print

Print a tree

=head3 Nasm::X86::Tree::dump($tree, $title)

Dump a tree and all its sub trees.

     Parameter  Description
  1  $tree      Tree
  2  $title     Title

=head3 Nasm::X86::Tree::printInOrder($tree, $title)

Print a tree in order

     Parameter  Description
  1  $tree      Tree
  2  $title     Title

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K count => 128;

    $N->for(sub
     {my ($index, $start, $next, $end) = @_;
      my $l0 = ($N-$index) / 2;
      my $l1 = ($N+$index) / 2;
      my $h0 =  $N-$index;
      my $h1 =  $N+$index;
      $t->put($l0, $l0 * 2);
      $t->put($h1, $h1 * 2);
      $t->put($l1, $l1 * 2);
      $t->put($h0, $h0 * 2);
     });
    $t->printInOrder("AAAA");

    ok Assemble eq => <<END;
  AAAA 256:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F  40  41  42  43  44  45  46  47  48  49  4A  4B  4C  4D  4E  4F  50  51  52  53  54  55  56  57  58  59  5A  5B  5C  5D  5E  5F  60  61  62  63  64  65  66  67  68  69  6A  6B  6C  6D  6E  6F  70  71  72  73  74  75  76  77  78  79  7A  7B  7C  7D  7E  7F  80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF
  END


=head3 Nasm::X86::Tree::clear($tree)

Delete everything in the tree recording the memory so liberated to the free chain for reuse by other trees.

     Parameter  Description
  1  $tree      Tree

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;
    $t->clear;
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;
    $t->clear;
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->free;
    $a->used->out("Clear tree:            u: ");
    $a->freeChainSpace->out(" f: ", " ");
    $a->size->outNL;

    $a->clear;
    $a->used->out("Clear area:           u: ");
    $a->freeChainSpace->out(" f: ", " ");
    $a->size->outNL;

    ok Assemble eq => <<END;
  t: 0000 0000 0000 0010 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0000 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0010 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0000 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  Clear tree:            u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  Clear area:           u: 0000 0000 0000 0000 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  END


=head3 Nasm::X86::Tree::free($tree)

Free all the memory used by a tree

     Parameter  Description
  1  $tree      Tree

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;
    $t->clear;
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;
    $t->clear;
    $t->size->out("t: ", " ");
    $a->used->out("u: ", " ");
    $a->freeChainSpace->out("f: ", " ");
    $a->size->outNL;

    $N->for(sub {my ($i) = @_; $t->push($i+1)});
    $t->free;
    $a->used->out("Clear tree:            u: ");
    $a->freeChainSpace->out(" f: ", " ");
    $a->size->outNL;

    $a->clear;
    $a->used->out("Clear area:           u: ");
    $a->freeChainSpace->out(" f: ", " ");
    $a->size->outNL;

    ok Assemble eq => <<END;
  t: 0000 0000 0000 0010 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0000 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0010 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  t: 0000 0000 0000 0000 u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  Clear tree:            u: 0000 0000 0000 0B80 f: 0000 0000 0000 0B40 size of area: 0000 0000 0000 1000
  Clear area:           u: 0000 0000 0000 0000 f: 0000 0000 0000 0000 size of area: 0000 0000 0000 1000
  END


=head2 Iteration

Iterate through a tree non recursively

=head3 Nasm::X86::Tree::by($tree, $block)

Call the specified block with each element of the specified tree in ascending order.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $block     Block to execute

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;
    $N->for(sub
     {my ($i) = @_;
      $t->put($i, 2 * $i);
     });

    $t->by(sub
     {my ($tree, $start, $next, $end) = @_;
      $tree->key->out("");  $tree->data->outNL(" ");
     });

    ok Assemble eq => <<END;
  0000 0000 0000 0000 0000 0000 0000 0000
  0000 0000 0000 0001 0000 0000 0000 0002
  0000 0000 0000 0002 0000 0000 0000 0004
  0000 0000 0000 0003 0000 0000 0000 0006
  0000 0000 0000 0004 0000 0000 0000 0008
  0000 0000 0000 0005 0000 0000 0000 000A
  0000 0000 0000 0006 0000 0000 0000 000C
  0000 0000 0000 0007 0000 0000 0000 000E
  0000 0000 0000 0008 0000 0000 0000 0010
  0000 0000 0000 0009 0000 0000 0000 0012
  0000 0000 0000 000A 0000 0000 0000 0014
  0000 0000 0000 000B 0000 0000 0000 0016
  0000 0000 0000 000C 0000 0000 0000 0018
  0000 0000 0000 000D 0000 0000 0000 001A
  0000 0000 0000 000E 0000 0000 0000 001C
  0000 0000 0000 000F 0000 0000 0000 001E
  END


=head3 Nasm::X86::Tree::yb($tree, $block)

Call the specified block with each element of the specified tree in descending order.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $block     Block to execute

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;
    $N->for(sub
     {my ($i) = @_;
      $t->put($i, 2* $i);
     });

    $t->yb(sub
     {my ($tree, $start, $prev, $end) = @_;
      $tree->key->out("");  $tree->data->outNL(" ");
     });

    ok Assemble eq => <<END;
  0000 0000 0000 000F 0000 0000 0000 001E
  0000 0000 0000 000E 0000 0000 0000 001C
  0000 0000 0000 000D 0000 0000 0000 001A
  0000 0000 0000 000C 0000 0000 0000 0018
  0000 0000 0000 000B 0000 0000 0000 0016
  0000 0000 0000 000A 0000 0000 0000 0014
  0000 0000 0000 0009 0000 0000 0000 0012
  0000 0000 0000 0008 0000 0000 0000 0010
  0000 0000 0000 0007 0000 0000 0000 000E
  0000 0000 0000 0006 0000 0000 0000 000C
  0000 0000 0000 0005 0000 0000 0000 000A
  0000 0000 0000 0004 0000 0000 0000 0008
  0000 0000 0000 0003 0000 0000 0000 0006
  0000 0000 0000 0002 0000 0000 0000 0004
  0000 0000 0000 0001 0000 0000 0000 0002
  0000 0000 0000 0000 0000 0000 0000 0000
  END


=head2 Push and Pop

Use a tree as a stack: Push elements on to a tree with the next available key; Pop the last element in a tree.

=head3 Nasm::X86::Tree::pop($tree)

Pop the last value out of a tree and return the key/data/subTree in the tree descriptor.

     Parameter  Description
  1  $tree      Tree descriptor

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;
    $N->for(sub
     {my ($i) = @_;
      $t->push($i);
     });

    $t->size->outNL;
    $t->get(K(key => 8)); $t->found->out("f: ", " ");  $t->key->out("i: ", " "); $t->data->outNL;

    $N->for(sub
     {my ($i) = @_;
      $t->pop; $t->found->out("f: ", " ");  $t->key->out("i: ", " "); $t->data->outNL;
     });
    $t->pop; $t->found->outNL("f: ");

    ok Assemble eq => <<END;
  size of tree: 0000 0000 0000 0010
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0008 data: 0000 0000 0000 0008
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000F data: 0000 0000 0000 000F
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000E data: 0000 0000 0000 000E
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000D data: 0000 0000 0000 000D
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000C data: 0000 0000 0000 000C
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000B data: 0000 0000 0000 000B
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000A data: 0000 0000 0000 000A
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0009 data: 0000 0000 0000 0009
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0008 data: 0000 0000 0000 0008
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0007 data: 0000 0000 0000 0007
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0006 data: 0000 0000 0000 0006
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0005 data: 0000 0000 0000 0005
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0004 data: 0000 0000 0000 0004
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0003 data: 0000 0000 0000 0003
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0002 data: 0000 0000 0000 0002
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0001 data: 0000 0000 0000 0001
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0000 data: 0000 0000 0000 0000
  f: 0000 0000 0000 0000
  END


=head3 Nasm::X86::Tree::get($tree, $key)

Retrieves the element at the specified zero based index in the stack.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $key       Zero based index

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;
    $N->for(sub
     {my ($i) = @_;
      $t->push($i);
     });

    $t->size->outNL;
    $t->get(K(key => 8)); $t->found->out("f: ", " ");  $t->key->out("i: ", " "); $t->data->outNL;

    $N->for(sub
     {my ($i) = @_;
      $t->pop; $t->found->out("f: ", " ");  $t->key->out("i: ", " "); $t->data->outNL;
     });
    $t->pop; $t->found->outNL("f: ");

    ok Assemble eq => <<END;
  size of tree: 0000 0000 0000 0010
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0008 data: 0000 0000 0000 0008
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000F data: 0000 0000 0000 000F
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000E data: 0000 0000 0000 000E
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000D data: 0000 0000 0000 000D
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000C data: 0000 0000 0000 000C
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000B data: 0000 0000 0000 000B
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000A data: 0000 0000 0000 000A
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0009 data: 0000 0000 0000 0009
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0008 data: 0000 0000 0000 0008
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0007 data: 0000 0000 0000 0007
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0006 data: 0000 0000 0000 0006
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0005 data: 0000 0000 0000 0005
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0004 data: 0000 0000 0000 0004
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0003 data: 0000 0000 0000 0003
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0002 data: 0000 0000 0000 0002
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0001 data: 0000 0000 0000 0001
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0000 data: 0000 0000 0000 0000
  f: 0000 0000 0000 0000
  END


=head2 Trees as Strings

Use trees as a strings. The characters of the string are stored as an array of characters.  The indices of the array run from 1 to the length of the string.

=head3 Nasm::X86::Tree::append($string, $append)

Append the second source string to the first target string renumbering the keys of the source string to follow on from those of the target string.  A string can safely be appended to itself.

     Parameter  Description
  1  $string    Tree descriptor of string to append to
  2  $append    Tree descriptor of string to append from

=head3 Nasm::X86::Tree::clone($string)

Clone a string.

     Parameter  Description
  1  $string    Tree descriptor

=head3 Nasm::X86::Tree::substring($string, $start, $finish)

Create the substring of the specified string between the specified start and end keys.

     Parameter  Description
  1  $string    Tree descriptor of string to extract from
  2  $start     Start key
  3  $finish    End key

=head3 Nasm::X86::Tree::reverse($string)

Create a clone of the sstring in reverse order

     Parameter  Description
  1  $string    Tree descriptor of string

=head3 Nasm::X86::Tree::outAsUtf8($string)

Print the data values of the specified string on stdout assuming each data value is a utf32 character and that the output device supports utf8

     Parameter  Description
  1  $string    Tree descriptor of string

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    $t->push(K alpha => 0x03b1);
    $t->push(K beta  => 0x03b2);
    $t->push(K gamma => 0x03b3);
    $t->push(K delta => 0x03b4);

    $t->outAsUtf8NL;

    $t->append($t);
    $t->outAsUtf8NL;

    $t->append($t);
    $t->outAsUtf8NL;

    my $T = $t->substring(K(key => 4), K(key => 8));
    $T->outAsUtf8NL;

    my $r = $T->reverse;
    $r->outAsUtf8NL;

    ok Assemble eq => <<END;
  
  
  
  
  
  END


=head3 Nasm::X86::Tree::outAsUtf8NL($string)

Print the data values of the specified string on stdout assuming each data value is a utf32 character and that the output device supports utf8. Follow the print with a new line character.

     Parameter  Description
  1  $string    Tree descriptor of string

=head1 Assemble

Assemble generated code

=head2 CallC($sub, @parameters)

Call a C subroutine.

     Parameter    Description
  1  $sub         Name of the sub to call
  2  @parameters  Parameters

B<Example:>


    my $format = Rs "Hello %s
";
    my $data   = Rs "World";

    Extern qw(printf exit malloc strcpy); Link 'c';


    CallC 'malloc', length($format)+1;  # 

    Mov r15, rax;

    CallC 'strcpy', r15, $format;  # 


    CallC 'printf', r15, $data;  # 


    CallC 'exit', 0;  # 


    ok Assemble eq => <<END;
  Hello World
  END


=head2 Extern(@externalReferences)

Name external references.

     Parameter            Description
  1  @externalReferences  External references

B<Example:>


    my $format = Rs "Hello %s
";
    my $data   = Rs "World";


    Extern qw(printf exit malloc strcpy); Link 'c';  # 


    CallC 'malloc', length($format)+1;
    Mov r15, rax;
    CallC 'strcpy', r15, $format;
    CallC 'printf', r15, $data;
    CallC 'exit', 0;

    ok Assemble eq => <<END;
  Hello World
  END


=head2 Link(@libraries)

Libraries to link with.

     Parameter   Description
  1  @libraries  External references

B<Example:>


    my $format = Rs "Hello %s
";
    my $data   = Rs "World";


    Extern qw(printf exit malloc strcpy); Link 'c';  # 


    CallC 'malloc', length($format)+1;
    Mov r15, rax;
    CallC 'strcpy', r15, $format;
    CallC 'printf', r15, $data;
    CallC 'exit', 0;

    ok Assemble eq => <<END;
  Hello World
  END


=head2 Start()

Initialize the assembler.


=head2 Exit($c)

Exit with the specified return code or zero if no return code supplied.  Assemble() automatically adds a call to Exit(0) if the last operation in the program is not a call to Exit.

     Parameter  Description
  1  $c         Return code

B<Example:>


    Comment "Print a string from memory";
    my $s = "Hello World";
    Mov rax, Rs($s);
    Mov rdi, length $s;
    PrintOutMemory;

    Exit(0);  # 


    ok Assemble =~ m(Hello World);


=head2 Assemble(%options)

Assemble the generated code.

     Parameter  Description
  1  %options   Options

B<Example:>


    PrintOutStringNL "Hello World";
    PrintOutStringNL "Hello
World";
    PrintErrStringNL "Hello World";


    ok Assemble(debug => 0, eq => <<END, avx512=>0);  # 

  Hello World
  Hello
  World
  END


=head2 CreateLibrary(%library)

Create a library.

     Parameter  Description
  1  %library   Library definition

=head2 NasmX86::Library::load($library)

Load a library and return the addresses of its subroutines as variables.

     Parameter  Description
  1  $library   Description of library to load


=head1 Hash Definitions




=head2 Nasm::X86 Definition


Tree




=head3 Output fields


=head4 N

Initial allocation

=head4 address

Variable that addresses the memory containing the area

=head4 area

Area definition.

=head4 compare

Last comparison result -1, 0, +1

=head4 constant

Constant if true

=head4 data

Variable containing the current data

=head4 dataOffset

The start of the data

=head4 debug

Write debug trace if true

=head4 end

End label for this subroutine

=head4 expr

Expression that initializes the variable

=head4 first

Variable addressing offset to first block of the tree which is the header block

=head4 found

Variable indicating whether the last find was successful or not

=head4 freeOffset

Free chain offset

=head4 global

Global if true

=head4 index

Index of key in last node found

=head4 key

Variable containing the current key

=head4 keyDataMask

Key data mask

=head4 label

Address in memory

=head4 length

Number of keys in a maximal block

=head4 lengthLeft

Left minimal number of keys

=head4 lengthMiddle

Number of splitting key counting from 1

=head4 lengthMin

The smallest number of keys we are allowed in any node other than a root node.

=head4 lengthOffset

Offset of length in keys block.  The length field is a word - see: "MultiWayTree.svg"

=head4 lengthRight

Right minimal number of keys

=head4 level

Lexical level

=head4 loop

Offset of keys, data, node loop.

=head4 maxKeys

Maximum number of keys allowed in this tree which might well ne less than the maximum we can store in a zmm.

=head4 maxKeysZ

The maximum possible number of keys in a zmm register

=head4 maxNodesZ

The maximum possible number of nodes in a zmm register

=head4 middleOffset

Offset of the middle slot in bytes

=head4 name

Name of the variable

=head4 nameString

Name of the sub as a string constant in read only storage

=head4 nextOffset

Position of next offset on free chain

=head4 nodeMask

Node mask

=head4 offset

Variable containing the offset of the block containing the current key

=head4 options

Options used by the author of the subroutine

=head4 parameters

Parameters definitions supplied by the author of the subroutine which get mapped in to parameter variables.

=head4 reference

Reference to another variable

=head4 rightOffset

Offset of the first right slot in bytes

=head4 rootOffset

Offset of the root field in the first block - the root field contains the offset of the block containing the keys of the root of the tree

=head4 sizeOffset

Offset of the size field which tells us the number of  keys in the tree

=head4 splittingKey

Offset at which to split a full block

=head4 start

Start label for this subroutine which includes the enter instruction used to create a new stack frame

=head4 structureCopies

Copies of the structures passed to this subroutine with their variables replaced with references

=head4 structureVariables

Map structure variables to references at known positions in the sub

=head4 subTree

Variable indicating whether the last find found a sub tree

=head4 treeBits

Offset of tree bits in keys block.  The tree bits field is a word, each bit of which tells us whether the corresponding data element is the offset (or not) to a sub tree of this tree .

=head4 treeBitsMask

Total of 14 tree bits

=head4 treeOffset

Yggdrasil - a tree of global variables in this area

=head4 up

Offset of up in data block.

=head4 upOffset

Offset of the up field which points to any containing tree

=head4 usedOffset

Used field offset

=head4 variables

Map parameters to references at known positions in the sub

=head4 vars

Number of variables in subroutine

=head4 width

Width of a key or data slot.

=head4 zWidth

Width of a zmm register

=head4 zWidthD

Width of a zmm in double words being the element size

=head4 zmmBlock

Size of a zmm block - 64 bytes



=head1 Attributes


The following is a list of all the attributes in this package.  A method coded
with the same name in your package will over ride the method of the same name
in this package and thus provide your value for the attribute in place of the
default value supplied for this attribute by this package.

=head2 Replaceable Attribute List


Pi32 Pi64


=head2 Pi32

Pi as a 32 bit float.


=head2 Pi64

Pi as a 64 bit float.




=head1 Private Methods

=head2 Label({return "l".++$Labels unless @_;)

Create a unique label or reuse the one supplied.

     Parameter                         Description
  1  {return "l".++$Labels unless @_;  Generate a label

=head2 Dbwdq($s, @d)

Layout data.

     Parameter  Description
  1  $s         Element size
  2  @d         Data to be laid out

=head2 Rbwdq($s, @d)

Layout data.

     Parameter  Description
  1  $s         Element size
  2  @d         Data to be laid out

=head2 PushRR(@r)

Push registers onto the stack without tracking.

     Parameter  Description
  1  @r         Register

=head2 PushR(@r)

Push registers onto the stack.

     Parameter  Description
  1  @r         Registers

B<Example:>


    Mov rax, 0x11111111;
    Mov rbx, 0x22222222;

    PushR my @save = (rax, rbx);  # 

    Mov rax, 0x33333333;
    PopR;
    PrintOutRegisterInHex rax;
    PrintOutRegisterInHex rbx;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
     rax: 0000 0000 1111 1111
     rbx: 0000 0000 2222 2222
  END


=head2 PopRR(@r)

Pop registers from the stack without tracking.

     Parameter  Description
  1  @r         Register

=head2 Nasm::X86::Sub::callTo($sub, $mode, $label, @parameters)

Call a sub passing it some parameters.

     Parameter    Description
  1  $sub         Subroutine descriptor
  2  $mode        Mode 0 - direct call or 1 - indirect call
  3  $label       Label of sub
  4  @parameters  Parameter variables

=head2 Nasm::X86::Subroutine::uploadToNewStackFrame($sub, $source, $target)

Map a variable in the current stack into a reference in the next stack frame being the one that will be used by this sub

     Parameter  Description
  1  $sub       Subroutine descriptor
  2  $source    Source variable in the current stack frame
  3  $target    The reference in the new stack frame

=head2 Nasm::X86::Subroutine::call($sub, %options)

Call a sub optionally passing it parameters.

     Parameter  Description
  1  $sub       Subroutine descriptor
  2  %options   Options

=head2 hexTranslateTable()

Create/address a hex translate table and return its label.


=head2 PrintOutRipInHex()

Print the instruction pointer in hex.


=head2 PrintOutRflagsInHex()

Print the flags register in hex.


=head2 Nasm::X86::Variable::dump($left, $channel, $newLine, $title1, $title2)

Dump the value of a variable to the specified channel adding an optional title and new line if requested.

     Parameter  Description
  1  $left      Left variable
  2  $channel   Channel
  3  $newLine   New line required
  4  $title1    Optional leading title
  5  $title2    Optional trailing title

B<Example:>


    my $a = V(a, 3);  $a->outNL;
    my $b = K(b, 2);  $b->outNL;
    my $c = $a +  $b; $c->outNL;
    my $d = $c -  $a; $d->outNL;
    my $g = $a *  $b; $g->outNL;
    my $h = $g /  $b; $h->outNL;
    my $i = $a %  $b; $i->outNL;

    If ($a == 3,
    Then
     {PrintOutStringNL "a == 3"
     },
    Else
     {PrintOutStringNL "a != 3"
     });

    ++$a; $a->outNL;
    --$a; $a->outNL;

    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  a: 0000 0000 0000 0003
  b: 0000 0000 0000 0002
  (a add b): 0000 0000 0000 0005
  ((a add b) sub a): 0000 0000 0000 0002
  (a times b): 0000 0000 0000 0006
  ((a times b) / b): 0000 0000 0000 0003
  (a % b): 0000 0000 0000 0001
  a == 3
  a: 0000 0000 0000 0004
  a: 0000 0000 0000 0003
  END


=head2 ClassifyRange($recordOffsetInRange, $address, $size)

Implementation of ClassifyInRange and ClassifyWithinRange.

     Parameter             Description
  1  $recordOffsetInRange  Record offset in classification in high byte if 1 else in classification if 2
  2  $address              Variable address of utf32 string to classify
  3  $size                 Variable length of utf32 string to classify

=head2 Cstrlen()

Length of the C style string addressed by rax returning the length in r15.


=head2 Nasm::X86::Area::updateSpace($area, $size)

Make sure that the variable addressed area has enough space to accommodate content of the variable size.

     Parameter  Description
  1  $area      Area descriptor
  2  $size      Variable size needed

=head2 Nasm::X86::Area::freeZmmBlock($area, $offset)

Free a block in an area by placing it on the free chain.

     Parameter  Description
  1  $area      Area descriptor
  2  $offset    Offset of zmm block to be freed

B<Example:>


    my $a = CreateArea;

    my $m = $a->allocZmmBlock;
    K(K => Rd(1..16))->loadZmm(31);

    $a->putZmmBlock  ($m, 31);
    $a->dump("A");

    $a->getZmmBlock  ($m, 30);
    $a->clearZmmBlock($m);
    $a->getZmmBlock  ($m, 29);

    $a->clearZmmBlock($m);
    PrintOutRegisterInHex 31, 30, 29;

    ok Assemble eq => <<END;
  A
  Area     Size:     4096    Used:      128
  0000 0000 0000 0000 | __10 ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END

    my $a = CreateArea;

    K(loop => 3)->for(sub
     {my ($i, $start, $next, $end) = @_;
      $i->outNL;
      my $m1 = $a->allocZmmBlock;
      my $m2 = $a->allocZmmBlock;

      K(K => Rd(1..16))->loadZmm(31);
      K(K => Rd(17..32))->loadZmm(30);
      PrintOutRegisterInHex 31, 30;

      $a->putZmmBlock($m1, 31);
      $a->putZmmBlock($m2, 30);
      $a->dump("A");

      $a->getZmmBlock($m1, 30);
      $a->getZmmBlock($m2, 31);
      PrintOutRegisterInHex 31, 30;

      $a->clearZmmBlock($m1);
      $a->freeZmmBlock($m1);
      $a->dump("B");

      $a->freeZmmBlock($m2);
      $a->dump("C");
     });

    ok Assemble eq => <<END;
  index: 0000 0000 0000 0000
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0001
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0002
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  END


=head2 Nasm::X86::Area::getZmmBlock($area, $block, $zmm)

Get the block with the specified offset in the specified string and return it in the numbered zmm.

     Parameter  Description
  1  $area      Area descriptor
  2  $block     Offset of the block as a variable
  3  $zmm       Number of zmm register to contain block

B<Example:>


    my $a = CreateArea;

    my $m = $a->allocZmmBlock;
    K(K => Rd(1..16))->loadZmm(31);

    $a->putZmmBlock  ($m, 31);
    $a->dump("A");

    $a->getZmmBlock  ($m, 30);
    $a->clearZmmBlock($m);
    $a->getZmmBlock  ($m, 29);

    $a->clearZmmBlock($m);
    PrintOutRegisterInHex 31, 30, 29;

    ok Assemble eq => <<END;
  A
  Area     Size:     4096    Used:      128
  0000 0000 0000 0000 | __10 ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END

    my $a = CreateArea;

    K(loop => 3)->for(sub
     {my ($i, $start, $next, $end) = @_;
      $i->outNL;
      my $m1 = $a->allocZmmBlock;
      my $m2 = $a->allocZmmBlock;

      K(K => Rd(1..16))->loadZmm(31);
      K(K => Rd(17..32))->loadZmm(30);
      PrintOutRegisterInHex 31, 30;

      $a->putZmmBlock($m1, 31);
      $a->putZmmBlock($m2, 30);
      $a->dump("A");

      $a->getZmmBlock($m1, 30);
      $a->getZmmBlock($m2, 31);
      PrintOutRegisterInHex 31, 30;

      $a->clearZmmBlock($m1);
      $a->freeZmmBlock($m1);
      $a->dump("B");

      $a->freeZmmBlock($m2);
      $a->dump("C");
     });

    ok Assemble eq => <<END;
  index: 0000 0000 0000 0000
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0001
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0002
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  END


=head2 Nasm::X86::Area::putZmmBlock($area, $block, $zmm)

Write the numbered zmm to the block at the specified offset in the specified area.

     Parameter  Description
  1  $area      Area descriptor
  2  $block     Offset of the block as a variable
  3  $zmm       Number of zmm register to contain block

B<Example:>


    my $a = CreateArea;

    my $m = $a->allocZmmBlock;
    K(K => Rd(1..16))->loadZmm(31);

    $a->putZmmBlock  ($m, 31);
    $a->dump("A");

    $a->getZmmBlock  ($m, 30);
    $a->clearZmmBlock($m);
    $a->getZmmBlock  ($m, 29);

    $a->clearZmmBlock($m);
    PrintOutRegisterInHex 31, 30, 29;

    ok Assemble eq => <<END;
  A
  Area     Size:     4096    Used:      128
  0000 0000 0000 0000 | __10 ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END

    my $a = CreateArea;

    K(loop => 3)->for(sub
     {my ($i, $start, $next, $end) = @_;
      $i->outNL;
      my $m1 = $a->allocZmmBlock;
      my $m2 = $a->allocZmmBlock;

      K(K => Rd(1..16))->loadZmm(31);
      K(K => Rd(17..32))->loadZmm(30);
      PrintOutRegisterInHex 31, 30;

      $a->putZmmBlock($m1, 31);
      $a->putZmmBlock($m2, 30);
      $a->dump("A");

      $a->getZmmBlock($m1, 30);
      $a->getZmmBlock($m2, 31);
      PrintOutRegisterInHex 31, 30;

      $a->clearZmmBlock($m1);
      $a->freeZmmBlock($m1);
      $a->dump("B");

      $a->freeZmmBlock($m2);
      $a->dump("C");
     });

    ok Assemble eq => <<END;
  index: 0000 0000 0000 0000
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0001
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  index: 0000 0000 0000 0002
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
  A
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0020 0000 001F   0000 001E 0000 001D   0000 001C 0000 001B   0000 001A 0000 0019   0000 0018 0000 0017   0000 0016 0000 0015   0000 0014 0000 0013   0000 0012 0000 0011
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  B
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  C
  Area     Size:     4096    Used:      192
  0000 0000 0000 0000 | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  END


=head2 Nasm::X86::Area::clearZmmBlock($area, $offset)

Clear the zmm block at the specified offset in the area

     Parameter  Description
  1  $area      Area descriptor
  2  $offset    Offset of the block as a variable

B<Example:>


    my $a = CreateArea;

    my $m = $a->allocZmmBlock;
    K(K => Rd(1..16))->loadZmm(31);

    $a->putZmmBlock  ($m, 31);
    $a->dump("A");

    $a->getZmmBlock  ($m, 30);
    $a->clearZmmBlock($m);
    $a->getZmmBlock  ($m, 29);

    $a->clearZmmBlock($m);
    PrintOutRegisterInHex 31, 30, 29;

    ok Assemble eq => <<END;
  A
  Area     Size:     4096    Used:      128
  0000 0000 0000 0000 | __10 ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 01__ ____ 02__ ____  03__ ____ 04__ ____  05__ ____ 06__ ____  07__ ____ 08__ ____  09__ ____ 0A__ ____  0B__ ____ 0C__ ____  0D__ ____ 0E__ ____  0F__ ____ 10__ ____
  0000 0000 0000 0080 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   zmm31: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END


=head2 Nasm::X86::Area::checkYggdrasilCreated($area)

Return a tree descriptor to the Yggdrasil world tree for an area.  If Yggdrasil has not been created the B<found> variable will be zero else one.

     Parameter  Description
  1  $area      Area descriptor

B<Example:>


    my $A = CreateArea;
    my $t = $A->checkYggdrasilCreated;
       $t->found->outNL;
    my $y = $A->establishYggdrasil;
    my $T = $A->checkYggdrasilCreated;
       $T->found->outNL;
    ok Assemble(debug => 0, eq => <<END, avx512=>0);
  found: 0000 0000 0000 0000
  found: 0000 0000 0000 0001
  END


=head2 Nasm::X86::Area::establishYggdrasil($area)

Return a tree descriptor to the Yggdrasil world tree for an area creating the world tree Yggdrasil if it has not already been created.

     Parameter  Description
  1  $area      Area descriptor

B<Example:>


    my $A = CreateArea;
    my $t = $A->checkYggdrasilCreated;
       $t->found->outNL;
    my $y = $A->establishYggdrasil;
    my $T = $A->checkYggdrasilCreated;
       $T->found->outNL;
    ok Assemble(debug => 0, eq => <<END);
  found: 0000 0000 0000 0000
  found: 0000 0000 0000 0001
  END


=head2 DescribeTree(%options)

Return a descriptor for a tree with the specified options.

     Parameter  Description
  1  %options   Tree description options

=head2 Nasm::X86::Area::DescribeTree($area, %options)

Return a descriptor for a tree in the specified area with the specified options.

     Parameter  Description
  1  $area      Area descriptor
  2  %options   Options for tree

=head2 Nasm::X86::Tree::describeTree($tree, %options)

Create a a description of a tree

     Parameter  Description
  1  $tree      Tree descriptor
  2  %options   {first=>first node of tree if not the existing first node; area=>area used by tree if not the existing area}

=head2 Nasm::X86::Tree::copyDescription($tree)

Make a copy of a tree descriptor

     Parameter  Description
  1  $tree      Tree descriptor

=head2 Nasm::X86::Tree::firstFromMemory($tree, $zmm)

Load the first block for a tree into the numbered zmm.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm to contain first block

=head2 Nasm::X86::Tree::firstIntoMemory($tree, $zmm)

Save the first block of a tree in the numbered zmm back into memory.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm containing first block

=head2 Nasm::X86::Tree::rootIntoFirst($tree, $zmm, $value)

Put the contents of a variable into the root field of the first block of a tree when held in a zmm register.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm containing first block
  3  $value     Variable containing value to put

=head2 Nasm::X86::Tree::rootFromFirst($tree, $zmm)

Return a variable containing the offset of the root block of a tree from the first block when held in a zmm register.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm containing first block

=head2 Nasm::X86::Tree::root($t, $F, $offset)

Check whether the specified offset refers to the root of a tree when the first block is held in a zmm register. The result is returned by setting the zero flag to one if the offset is the root, else to zero.

     Parameter  Description
  1  $t         Tree descriptor
  2  $F         Zmm register holding first block
  3  $offset    Offset of block as a variable

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree;
    my $b = $t->allocBlock(31, 30, 29);
    K(data => 0x33)->dIntoZ(31, 4);
    $t->lengthIntoKeys(31, K length =>0x9);
    $t->putBlock($b, 31, 30, 29);
    $t->getBlock($b, 25, 24, 23);
    PrintOutRegisterInHex 25;
    $t->lengthFromKeys(25)->outNL;


    $t->firstFromMemory(28);
    $t->incSizeInFirst (28);
    $t->rootIntoFirst  (28, K value => 0x2222);
    $t->root           (28, K value => 0x2222);  PrintOutZF;
    $t->root           (28, K value => 0x2221);  PrintOutZF;
    $t->root           (28, K value => 0x2222);  PrintOutZF;
    $t->firstIntoMemory(28);

    $t->first->outNL;
    $b->outNL;
    $a->dump("1111");
    PrintOutRegisterInHex 31, 30, 29, 28;


    my $l = $t->leafFromNodes(29); If $l > 0, Then {PrintOutStringNL "29 Leaf"}, Else {PrintOutStringNL "29 Branch"};
    my $r = $t->leafFromNodes(28); If $r > 0, Then {PrintOutStringNL "28 Leaf"}, Else {PrintOutStringNL "28 Branch"};


    ok Assemble eq => <<END;
   zmm25: 0000 00C0 0000 0009   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0033 0000 0000
  b at offset 56 in zmm25: 0000 0000 0000 0009
  ZF=1
  ZF=0
  ZF=1
  first: 0000 0000 0000 0040
  address: 0000 0000 0000 0080
  1111
  Area     Size:     4096    Used:      320
  0000 0000 0000 0000 | __10 ____ ____ ____  4001 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 2222 ____ ____ ____  01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ 33__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  09__ ____ C0__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ __01 ____
   zmm31: 0000 00C0 0000 0009   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0033 0000 0000
   zmm30: 0000 0100 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm29: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm28: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0001   0000 0000 0000 2222
  29 Leaf
  28 Branch
  END


=head2 Nasm::X86::Tree::sizeFromFirst($tree, $zmm)

Return a variable containing the number of keys in the specified tree when the first block is held in a zmm register..

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm containing first block

=head2 Nasm::X86::Tree::sizeIntoFirst($tree, $zmm, $value)

Put the contents of a variable into the size field of the first block of a tree  when the first block is held in a zmm register.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm containing first block
  3  $value     Variable containing value to put

=head2 Nasm::X86::Tree::incSizeInFirst($tree, $zmm)

Increment the size field in the first block of a tree when the first block is held in a zmm register.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm containing first block

=head2 Nasm::X86::Tree::incSize($tree)

Increment the size of a tree

     Parameter  Description
  1  $tree      Tree descriptor

=head2 Nasm::X86::Tree::decSizeInFirst($tree, $zmm)

Decrement the size field in the first block of a tree when the first block is held in a zmm register.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm containing first block

=head2 Nasm::X86::Tree::decSize($tree)

Decrement the size of a tree

     Parameter  Description
  1  $tree      Tree descriptor

=head2 Nasm::X86::Tree::allocBlock($tree, $K, $D, $N)

Allocate a keys/data/node block and place it in the numbered zmm registers.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $K         Numbered zmm for keys
  3  $D         Numbered zmm for data
  4  $N         Numbered zmm for children

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree;
    my $b = $t->allocBlock(31, 30, 29);
    K(data => 0x33)->dIntoZ(31, 4);
    $t->lengthIntoKeys(31, K length =>0x9);
    $t->putBlock($b, 31, 30, 29);
    $t->getBlock($b, 25, 24, 23);
    PrintOutRegisterInHex 25;
    $t->lengthFromKeys(25)->outNL;


    $t->firstFromMemory(28);
    $t->incSizeInFirst (28);
    $t->rootIntoFirst  (28, K value => 0x2222);
    $t->root           (28, K value => 0x2222);  PrintOutZF;
    $t->root           (28, K value => 0x2221);  PrintOutZF;
    $t->root           (28, K value => 0x2222);  PrintOutZF;
    $t->firstIntoMemory(28);

    $t->first->outNL;
    $b->outNL;
    $a->dump("1111");
    PrintOutRegisterInHex 31, 30, 29, 28;


    my $l = $t->leafFromNodes(29); If $l > 0, Then {PrintOutStringNL "29 Leaf"}, Else {PrintOutStringNL "29 Branch"};
    my $r = $t->leafFromNodes(28); If $r > 0, Then {PrintOutStringNL "28 Leaf"}, Else {PrintOutStringNL "28 Branch"};


    ok Assemble eq => <<END;
   zmm25: 0000 00C0 0000 0009   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0033 0000 0000
  b at offset 56 in zmm25: 0000 0000 0000 0009
  ZF=1
  ZF=0
  ZF=1
  first: 0000 0000 0000 0040
  address: 0000 0000 0000 0080
  1111
  Area     Size:     4096    Used:      320
  0000 0000 0000 0000 | __10 ____ ____ ____  4001 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 2222 ____ ____ ____  01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ 33__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  09__ ____ C0__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ __01 ____
   zmm31: 0000 00C0 0000 0009   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0033 0000 0000
   zmm30: 0000 0100 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm29: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm28: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0001   0000 0000 0000 2222
  29 Leaf
  28 Branch
  END


=head2 Nasm::X86::Tree::freeBlock($tree, $k, $K, $D, $N)

Free a keys/data/node block whise keys  block entry is located at the specified offset.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $k         Offset of keys block
  3  $K         Numbered zmm for keys
  4  $D         Numbered zmm for data
  5  $N         Numbered zmm for children

=head2 Nasm::X86::Tree::upFromData($tree, $zmm)

Up from the data zmm in a block in a tree

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm containing data block

=head2 Nasm::X86::Tree::upIntoData($tree, $value, $zmm)

Up into the data zmm in a block in a tree

     Parameter  Description
  1  $tree      Tree descriptor
  2  $value     Variable containing value to put
  3  $zmm       Number of zmm containing first block

=head2 Nasm::X86::Tree::lengthFromKeys($t, $zmm)

Get the length of the keys block in the numbered zmm and return it as a variable.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Zmm number

=head2 Nasm::X86::Tree::lengthIntoKeys($t, $zmm, $length)

Get the length of the block in the numbered zmm from the specified variable.

     Parameter  Description
  1  $t         Tree
  2  $zmm       Zmm number
  3  $length    Length variable

=head2 Nasm::X86::Tree::incLengthInKeys($t, $K)

Increment the number of keys in a keys block or complain if such is not possible

     Parameter  Description
  1  $t         Tree
  2  $K         Zmm number

=head2 Nasm::X86::Tree::decLengthInKeys($t, $K)

Decrement the number of keys in a keys block or complain if such is not possible

     Parameter  Description
  1  $t         Tree
  2  $K         Zmm number

=head2 Nasm::X86::Tree::leafFromNodes($tree, $zmm)

Return a variable containing true if we are on a leaf.  We determine whether we are on a leaf by checking the offset of the first sub node.  If it is zero we are on a leaf otherwise not.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $zmm       Number of zmm containing node block

=head2 Nasm::X86::Tree::getLoop($t, $zmm)

Return the value of the loop field as a variable.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm

=head2 Nasm::X86::Tree::putLoop($t, $value, $zmm)

Set the value of the loop field from a variable.

     Parameter  Description
  1  $t         Tree descriptor
  2  $value     Variable containing offset of next loop entry
  3  $zmm       Numbered zmm

=head2 Nasm::X86::Tree::maskForFullKeyArea()

Place a mask for the full key area in the numbered mask register


=head2 Nasm::X86::Tree::maskForFullNodesArea()

Place a mask for the full nodes area in the numbered mask register


=head2 Nasm::X86::Tree::getBlock($t, $offset, $K, $D, $N)

Get the keys, data and child nodes for a tree node from the specified offset in the area for the tree.

     Parameter  Description
  1  $t         Tree descriptor
  2  $offset    Offset of block as a variable
  3  $K         Numbered zmm for keys
  4  $D         Numbered data for keys
  5  $N         Numbered zmm for nodes

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree;
    my $b = $t->allocBlock(31, 30, 29);
    K(data => 0x33)->dIntoZ(31, 4);
    $t->lengthIntoKeys(31, K length =>0x9);
    $t->putBlock($b, 31, 30, 29);
    $t->getBlock($b, 25, 24, 23);
    PrintOutRegisterInHex 25;
    $t->lengthFromKeys(25)->outNL;


    $t->firstFromMemory(28);
    $t->incSizeInFirst (28);
    $t->rootIntoFirst  (28, K value => 0x2222);
    $t->root           (28, K value => 0x2222);  PrintOutZF;
    $t->root           (28, K value => 0x2221);  PrintOutZF;
    $t->root           (28, K value => 0x2222);  PrintOutZF;
    $t->firstIntoMemory(28);

    $t->first->outNL;
    $b->outNL;
    $a->dump("1111");
    PrintOutRegisterInHex 31, 30, 29, 28;


    my $l = $t->leafFromNodes(29); If $l > 0, Then {PrintOutStringNL "29 Leaf"}, Else {PrintOutStringNL "29 Branch"};
    my $r = $t->leafFromNodes(28); If $r > 0, Then {PrintOutStringNL "28 Leaf"}, Else {PrintOutStringNL "28 Branch"};


    ok Assemble eq => <<END;
   zmm25: 0000 00C0 0000 0009   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0033 0000 0000
  b at offset 56 in zmm25: 0000 0000 0000 0009
  ZF=1
  ZF=0
  ZF=1
  first: 0000 0000 0000 0040
  address: 0000 0000 0000 0080
  1111
  Area     Size:     4096    Used:      320
  0000 0000 0000 0000 | __10 ____ ____ ____  4001 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 2222 ____ ____ ____  01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ 33__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  09__ ____ C0__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ __01 ____
   zmm31: 0000 00C0 0000 0009   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0033 0000 0000
   zmm30: 0000 0100 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm29: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm28: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0001   0000 0000 0000 2222
  29 Leaf
  28 Branch
  END


=head2 Nasm::X86::Tree::putBlock($t, $offset, $K, $D, $N)

Put a tree block held in three zmm registers back into the area holding the tree at the specified offset.

     Parameter  Description
  1  $t         Tree descriptor
  2  $offset    Offset of block as a variable
  3  $K         Numbered zmm for keys
  4  $D         Numbered data for keys
  5  $N         Numbered zmm for nodes

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree;
    my $b = $t->allocBlock(31, 30, 29);
    K(data => 0x33)->dIntoZ(31, 4);
    $t->lengthIntoKeys(31, K length =>0x9);
    $t->putBlock($b, 31, 30, 29);
    $t->getBlock($b, 25, 24, 23);
    PrintOutRegisterInHex 25;
    $t->lengthFromKeys(25)->outNL;


    $t->firstFromMemory(28);
    $t->incSizeInFirst (28);
    $t->rootIntoFirst  (28, K value => 0x2222);
    $t->root           (28, K value => 0x2222);  PrintOutZF;
    $t->root           (28, K value => 0x2221);  PrintOutZF;
    $t->root           (28, K value => 0x2222);  PrintOutZF;
    $t->firstIntoMemory(28);

    $t->first->outNL;
    $b->outNL;
    $a->dump("1111");
    PrintOutRegisterInHex 31, 30, 29, 28;


    my $l = $t->leafFromNodes(29); If $l > 0, Then {PrintOutStringNL "29 Leaf"}, Else {PrintOutStringNL "29 Branch"};
    my $r = $t->leafFromNodes(28); If $r > 0, Then {PrintOutStringNL "28 Leaf"}, Else {PrintOutStringNL "28 Branch"};


    ok Assemble eq => <<END;
   zmm25: 0000 00C0 0000 0009   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0033 0000 0000
  b at offset 56 in zmm25: 0000 0000 0000 0009
  ZF=1
  ZF=0
  ZF=1
  first: 0000 0000 0000 0040
  address: 0000 0000 0000 0080
  1111
  Area     Size:     4096    Used:      320
  0000 0000 0000 0000 | __10 ____ ____ ____  4001 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0040 | 2222 ____ ____ ____  01__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
  0000 0000 0000 0080 | ____ ____ 33__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  09__ ____ C0__ ____
  0000 0000 0000 00C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ __01 ____
   zmm31: 0000 00C0 0000 0009   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0033 0000 0000
   zmm30: 0000 0100 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm29: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm28: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0001   0000 0000 0000 2222
  29 Leaf
  28 Branch
  END


=head2 Nasm::X86::Tree::firstNode($tree, $K, $D, $N)

Return as a variable the last node block in the specified tree node held in a zmm

     Parameter  Description
  1  $tree      Tree definition
  2  $K         Key zmm
  3  $D         Data zmm
  4  $N         Node zmm for a node block

B<Example:>


    my $L = 13;
    my $a = CreateArea;
    my $t = $a->CreateTree(length => $L);

    my ($K, $D, $N) = (31, 30, 29);

    K(K => Rd( 1..16))->loadZmm($K);
    K(K => Rd( 1..16))->loadZmm($N);

    $t->lengthIntoKeys($K, K length => $t->length);

    PrintOutRegisterInHex 31, 29;
    my $f = $t->firstNode($K, $D, $N);
    my $l = $t-> lastNode($K, $D, $N);
    $f->outNL;
    $l->outNL;

    ok Assemble eq => <<END;
   zmm31: 0000 0010 0000 000D   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  d at offset 0 in zmm29: 0000 0000 0000 0001
  d at offset (b at offset 56 in zmm31 times 4) in zmm29: 0000 0000 0000 000E
  END

    my $L = 13;
    my $a = CreateArea;
    my $t = $a->CreateTree(length => $L);

    my ($K, $D, $N) = (31, 30, 29);

    K(K => Rd( 1..16))->loadZmm($K);
    K(K => Rd( 1..16))->loadZmm($N);

    $t->lengthIntoKeys($K, K length => $t->length);

    PrintOutRegisterInHex 31, 29;
    my $f = $t->firstNode($K, $D, $N);
    my $l = $t-> lastNode($K, $D, $N);
    $f->outNL;
    $l->outNL;

    ok Assemble eq => <<END;
   zmm31: 0000 0010 0000 000D   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  d at offset 0 in zmm29: 0000 0000 0000 0001
  d at offset (b at offset 56 in zmm31 times 4) in zmm29: 0000 0000 0000 000E
  END


=head2 Nasm::X86::Tree::lastNode($tree, $K, $D, $N)

Return as a variable the last node block in the specified tree node held in a zmm

     Parameter  Description
  1  $tree      Tree definition
  2  $K         Key zmm
  3  $D         Data zmm
  4  $N         Node zmm for a node block

B<Example:>


    my $L = 13;
    my $a = CreateArea;
    my $t = $a->CreateTree(length => $L);

    my ($K, $D, $N) = (31, 30, 29);

    K(K => Rd( 1..16))->loadZmm($K);
    K(K => Rd( 1..16))->loadZmm($N);

    $t->lengthIntoKeys($K, K length => $t->length);

    PrintOutRegisterInHex 31, 29;
    my $f = $t->firstNode($K, $D, $N);
    my $l = $t-> lastNode($K, $D, $N);
    $f->outNL;
    $l->outNL;

    ok Assemble eq => <<END;
   zmm31: 0000 0010 0000 000D   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  d at offset 0 in zmm29: 0000 0000 0000 0001
  d at offset (b at offset 56 in zmm31 times 4) in zmm29: 0000 0000 0000 000E
  END

    my $L = 13;
    my $a = CreateArea;
    my $t = $a->CreateTree(length => $L);

    my ($K, $D, $N) = (31, 30, 29);

    K(K => Rd( 1..16))->loadZmm($K);
    K(K => Rd( 1..16))->loadZmm($N);

    $t->lengthIntoKeys($K, K length => $t->length);

    PrintOutRegisterInHex 31, 29;
    my $f = $t->firstNode($K, $D, $N);
    my $l = $t-> lastNode($K, $D, $N);
    $f->outNL;
    $l->outNL;

    ok Assemble eq => <<END;
   zmm31: 0000 0010 0000 000D   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
  d at offset 0 in zmm29: 0000 0000 0000 0001
  d at offset (b at offset 56 in zmm31 times 4) in zmm29: 0000 0000 0000 000E
  END


=head2 Nasm::X86::Tree::relativeNode($tree, $offset, $relative, $K, $N)

Return as a variable a node offset relative (specified as ac constant) to another offset in the same node in the specified zmm

     Parameter  Description
  1  $tree      Tree definition
  2  $offset    Offset
  3  $relative  Relative location
  4  $K         Key zmm
  5  $N         Node zmm

=head2 Nasm::X86::Tree::nextNode($tree, $offset, $K, $N)

Return as a variable the next node block offset after the specified one in the specified zmm

     Parameter  Description
  1  $tree      Tree definition
  2  $offset    Offset
  3  $K         Key zmm
  4  $N         Node zmm

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 13);

    K(loop => 66)->for(sub
     {my ($index, $start, $next, $end) = @_;
      $t->put($index, 2 * $index);
     });
    $t->getBlock(K(offset=>0x200), 31, 30, 29);
    $t->nextNode(K(offset=>0x440), 31, 29)->outRightInHexNL(K width => 3);
    $t->prevNode(K(offset=>0x440), 31, 29)->outRightInHexNL(K width => 3);

    ok Assemble eq => <<END;
  500
  380
  END


=head2 Nasm::X86::Tree::prevNode($tree, $offset, $K, $N)

Return as a variable the previous node block offset after the specified one in the specified zmm

     Parameter  Description
  1  $tree      Tree definition
  2  $offset    Offset
  3  $K         Key zmm
  4  $N         Node zmm

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 13);

    K(loop => 66)->for(sub
     {my ($index, $start, $next, $end) = @_;
      $t->put($index, 2 * $index);
     });
    $t->getBlock(K(offset=>0x200), 31, 30, 29);
    $t->nextNode(K(offset=>0x440), 31, 29)->outRightInHexNL(K width => 3);
    $t->prevNode(K(offset=>0x440), 31, 29)->outRightInHexNL(K width => 3);

    ok Assemble eq => <<END;
  500
  380
  END


=head2 Nasm::X86::Tree::indexNode($tree, $offset, $K, $N)

Return, as a variable, the point mask obtained by testing the nodes in a block for specified offset. We have to supply the keys as well so that we can find the number of nodes. We need the number of nodes so that we only search the valid area not all possible node positions in the zmm.

     Parameter  Description
  1  $tree      Tree definition
  2  $offset    Key as a variable
  3  $K         Zmm containing keys
  4  $N         Comparison from B<Vpcmp>

=head2 Nasm::X86::Tree::expand($tree, $offset)

Expand the node at the specified offset in the specified tree if it needs to be expanded and is not the root node (which cannot be expanded because it has no siblings to take substance from whereas as all other nodes do).  Set tree.found to the offset of the left sibling if the node at the specified offset was merged into it and freed else set tree.found to zero.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $offset    Offset of node block to expand

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);

    my ($PK, $PD, $PN) = (31, 30, 29);
    my ($LK, $LD, $LN) = (28, 27, 26);
    my ($RK, $RD, $RN) = (25, 24, 23);
    my ($lK, $lD, $lN) = (22, 21, 20);
    my ($rK, $rD, $rN) = (19, 18, 17);
    my $F = 16;

    my $P  = $t->allocBlock($PK, $PD, $PN);
    my $L  = $t->allocBlock($LK, $LD, $LN);
    my $R  = $t->allocBlock($RK, $RD, $RN);
    my $l  = $t->allocBlock($lK, $lD, $lN);
    my $r  = $t->allocBlock($rK, $rD, $rN);

    $t->lengthIntoKeys($PK, K length => 1);
    $t->lengthIntoKeys($LK, K length => 1);
    $t->lengthIntoKeys($RK, K length => 1);

    K(key=>1)->dIntoZ($LK, 0);  K(key=>1)->dIntoZ($LD, 0);
    K(key=>2)->dIntoZ($PK, 0);  K(key=>2)->dIntoZ($PD, 0);
    K(key=>3)->dIntoZ($RK, 0);  K(key=>3)->dIntoZ($RD, 0);

    $L->dIntoZ($PN, 0);
    $R->dIntoZ($PN, 4);
    $l->dIntoZ($LN, 0); $l->dIntoZ($LN, 4);
    $r->dIntoZ($RN, 0); $r->dIntoZ($RN, 4);

    $t->upIntoData($P, $LD);
    $t->upIntoData($P, $RD);
    $t->upIntoData($L, $lD);
    $t->upIntoData($R, $rD);

    $t->firstFromMemory($F);
    $t->rootIntoFirst($F, $P);
    $t->sizeIntoFirst($F, K size => 3);

    $t->firstIntoMemory($F);
    $t->putBlock($P, $PK, $PD, $PN);
    $t->putBlock($L, $LK, $LD, $LN);
    $t->putBlock($R, $RK, $RD, $RN);
    $t->putBlock($l, $lK, $lD, $lN);
    $t->putBlock($r, $rK, $rD, $rN);

    PrintOutStringNL "Start";
    PrintOutRegisterInHex reverse $F..$PK;

    $t->expand($L);

    $t->firstFromMemory($F);
    $t->getBlock($P, $PK, $PD, $PN);
    $t->getBlock($L, $LK, $LD, $LN);
    $t->getBlock($R, $RK, $RD, $RN);

    PrintOutStringNL "Finish";
    PrintOutRegisterInHex reverse $LN..$LK;

    PrintOutStringNL "Children";
    PrintOutRegisterInHex reverse $LN..$LK;

    ok Assemble eq => <<END;
  Start
   zmm31: 0000 00C0 0000 0001   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0002
   zmm30: 0000 0100 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0002
   zmm29: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0200 0000 0140
   zmm28: 0000 0180 0000 0001   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0001
   zmm27: 0000 01C0 0000 0080   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0001
   zmm26: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 02C0 0000 02C0
   zmm25: 0000 0240 0000 0001   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0003
   zmm24: 0000 0280 0000 0080   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0003
   zmm23: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0380 0000 0380
   zmm22: 0000 0300 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm21: 0000 0340 0000 0140   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm20: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm19: 0000 03C0 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm18: 0000 0400 0000 0200   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm17: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm16: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0003   0000 0000 0000 0080
  Finish
   zmm28: 0000 0180 0000 0003   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0003   0000 0002 0000 0001
   zmm27: 0000 01C0 0000 0080   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0003   0000 0002 0000 0001
   zmm26: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0380 0000 0380   0000 02C0 0000 02C0
  Children
   zmm28: 0000 0180 0000 0003   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0003   0000 0002 0000 0001
   zmm27: 0000 01C0 0000 0080   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0003   0000 0002 0000 0001
   zmm26: 0000 0040 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0380 0000 0380   0000 02C0 0000 02C0
  END


=head2 Nasm::X86::Tree::replace($tree, $point, $K, $D)

Replace the key/data/subTree at the specified point in the specified zmm with the values found in the tree key/data/sub tree fields.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $point     Point at which to extract
  3  $K         Keys zmm
  4  $D         Data zmm

B<Example:>


    my ($K, $D) = (31, 30);

    K(K => Rd(reverse 1..16))->loadZmm($K);
    K(K => Rd(reverse 1..16))->loadZmm($D);
    PrintOutStringNL "Start";
    PrintOutRegisterInHex $K, $D;

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 13);

    K(loop => 14)->for(sub
     {my ($index, $start, $next, $end) = @_;

      $t->key    ->copy($index);
      $t->data   ->copy($index * 2);
      $t->subTree->copy($index % 2);

      $t->replace(K(one=>1)<<$index, $K, $D);

      $index->outNL;
      PrintOutRegisterInHex $K, $D;
     });

    ok Assemble eq => <<END;
  Start
   zmm31: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 000D 0000 000E   0000 000F 0000 0010
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 000D 0000 000E   0000 000F 0000 0010
  index: 0000 0000 0000 0000
   zmm31: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 000D 0000 000E   0000 000F 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 000D 0000 000E   0000 000F 0000 0000
  index: 0000 0000 0000 0001
   zmm31: 0000 0001 0002 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 000D 0000 000E   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 000D 0000 000E   0000 0002 0000 0000
  index: 0000 0000 0000 0002
   zmm31: 0000 0001 0002 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 000D 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 000D 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 0003
   zmm31: 0000 0001 000A 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 000C   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 0004
   zmm31: 0000 0001 000A 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000B 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 0005
   zmm31: 0000 0001 002A 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000A   0000 000A 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 0006
   zmm31: 0000 0001 002A 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0009 0000 000C   0000 000A 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 0007
   zmm31: 0000 0001 00AA 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 000E 0000 000C   0000 000A 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 0008
   zmm31: 0000 0001 00AA 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0007 0000 0010   0000 000E 0000 000C   0000 000A 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 0009
   zmm31: 0000 0001 02AA 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0006   0000 0012 0000 0010   0000 000E 0000 000C   0000 000A 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 000A
   zmm31: 0000 0001 02AA 0002   0000 0003 0000 0004   0000 0005 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0005 0000 0014   0000 0012 0000 0010   0000 000E 0000 000C   0000 000A 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 000B
   zmm31: 0000 0001 0AAA 0002   0000 0003 0000 0004   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0004   0000 0016 0000 0014   0000 0012 0000 0010   0000 000E 0000 000C   0000 000A 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 000C
   zmm31: 0000 0001 0AAA 0002   0000 0003 0000 000C   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 0003 0000 0018   0000 0016 0000 0014   0000 0012 0000 0010   0000 000E 0000 000C   0000 000A 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  index: 0000 0000 0000 000D
   zmm31: 0000 0001 2AAA 0002   0000 000D 0000 000C   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002   0000 0001 0000 0000
   zmm30: 0000 0001 0000 0002   0000 001A 0000 0018   0000 0016 0000 0014   0000 0012 0000 0010   0000 000E 0000 000C   0000 000A 0000 0008   0000 0006 0000 0004   0000 0002 0000 0000
  END


=head2 Nasm::X86::Tree::overWriteKeyDataTreeInLeaf($tree, $point, $K, $D, $IK, $ID, $subTree)

Over write an existing key/data/sub tree triple in a set of zmm registers and set the tree bit as indicated.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $point     Point at which to overwrite formatted as a one in a sea of zeros
  3  $K         Key
  4  $D         Data
  5  $IK        Insert key
  6  $ID        Insert data
  7  $subTree   Sub tree if tree.

=head2 Nasm::X86::Tree::indexXX($tree, $key, $K, $cmp)

Return, as a variable, the mask obtained by performing a specified comparison on the key area of a node against a specified key.

     Parameter  Description
  1  $tree      Tree definition
  2  $key       Key as a variable
  3  $K         Zmm containing keys
  4  $cmp       Comparison from B<Vpcmp>

=head2 Nasm::X86::Tree::indexEq($tree, $key, $K)

Return the  position of a key in a zmm equal to the specified key as a point in a variable.

     Parameter  Description
  1  $tree      Tree definition
  2  $key       Key as a variable
  3  $K         Zmm containing keys

B<Example:>


    my $tree = DescribeTree(length => 7);

    my $K = 31;

    K(K => Rd(0..15))->loadZmm($K);
    $tree->lengthIntoKeys($K, K length => 13);

    K(loop => 16)->for(sub
     {my ($index, $start, $next, $end) = @_;
      my $f = $tree->indexEq ($index, $K);
      $index->outRightInDec(K width =>  2);
      $f    ->outRightInBin(K width => 14);
      PrintOutStringNL " |"
     });

    ok Assemble eq => <<END;
   0             1 |
   1            10 |
   2           100 |
   3          1000 |
   4         10000 |
   5        100000 |
   6       1000000 |
   7      10000000 |
   8     100000000 |
   9    1000000000 |
  10   10000000000 |
  11  100000000000 |
  12 1000000000000 |
  13               |
  14               |
  15               |
  END

    my $tree = DescribeTree();
    $tree->maskForFullKeyArea(7);                                               # Mask for full key area
    PrintOutRegisterInHex k7;
    $tree->maskForFullNodesArea(7);                                             # Mask for full nodes area
    PrintOutRegisterInHex k7;
    ok Assemble eq => <<END;
      k7: 0000 0000 0000 3FFF
      k7: 0000 0000 0000 7FFF
  END


=head2 Nasm::X86::Tree::insertionPoint($tree, $key, $K)

Return the position at which a key should be inserted into a zmm as a point in a variable.

     Parameter  Description
  1  $tree      Tree definition
  2  $key       Key as a variable
  3  $K         Zmm containing keys

B<Example:>


    my $tree = DescribeTree(length => 7);

    my $K = 31;

    K(K => Rd(map {2*$_} 1..16))->loadZmm($K);
    $tree->lengthIntoKeys($K, K length => 13);

    K(loop => 32)->for(sub
     {my ($index, $start, $next, $end) = @_;
      my $f = $tree->insertionPoint($index, $K);
      $index->outRightInDec(K width =>  2);
      $f    ->outRightInBin(K width => 16);
      PrintOutStringNL " |"
     });

    ok Assemble eq => <<END;
   0               1 |
   1               1 |
   2              10 |
   3              10 |
   4             100 |
   5             100 |
   6            1000 |
   7            1000 |
   8           10000 |
   9           10000 |
  10          100000 |
  11          100000 |
  12         1000000 |
  13         1000000 |
  14        10000000 |
  15        10000000 |
  16       100000000 |
  17       100000000 |
  18      1000000000 |
  19      1000000000 |
  20     10000000000 |
  21     10000000000 |
  22    100000000000 |
  23    100000000000 |
  24   1000000000000 |
  25   1000000000000 |
  26  10000000000000 |
  27  10000000000000 |
  28  10000000000000 |
  29  10000000000000 |
  30  10000000000000 |
  31  10000000000000 |
  END


=head2 Nasm::X86::Tree::insertKeyDataTreeIntoLeaf($tree, $point, $F, $K, $D, $IK, $ID, $subTree)

Insert a new key/data/sub tree triple into a set of zmm registers if there is room, increment the length of the node and set the tree bit as indicated and increment the number of elements in the tree.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $point     Point at which to insert formatted as a one in a sea of zeros
  3  $F         First
  4  $K         Key
  5  $D         Data
  6  $IK        Insert key
  7  $ID        Insert data
  8  $subTree   Sub tree if tree.

=head2 Nasm::X86::Tree::splitNode($tree, $offset)

Split a node if it it is full returning a variable that indicates whether a split occurred or not.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $offset    Offset of block in area of tree as a variable

=head2 Nasm::X86::Tree::splitNotRoot($tree, $newRight, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)

Split a non root left node pushing its excess right and up.

      Parameter  Description
   1  $tree      Tree definition
   2  $newRight  Variable offset in area of right node block
   3  $PK        Parent keys zmm
   4  $PD        Data zmm
   5  $PN        Nodes zmm
   6  $LK        Left keys zmm
   7  $LD        Data zmm
   8  $LN        Nodes zmm
   9  $RK        Right keys
  10  $RD        Data
  11  $RN        Node zmm

=head2 Nasm::X86::Tree::splitRoot($tree, $nLeft, $nRight, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)

Split a non root node into left and right nodes with the left half left in the left node and splitting key/data pushed into the parent node with the remainder pushed into the new right node

      Parameter  Description
   1  $tree      Tree definition
   2  $nLeft     Variable offset in area of new left node block
   3  $nRight    Variable offset in area of new right node block
   4  $PK        Parent keys zmm
   5  $PD        Data zmm
   6  $PN        Nodes zmm
   7  $LK        Left keys zmm
   8  $LD        Data zmm
   9  $LN        Nodes zmm
  10  $RK        Right keys
  11  $RD        Data
  12  $RN        Nodes zmm

=head2 Nasm::X86::Tree::findAndReload($t, $key)

Find a key in the specified tree and clone it is it is a sub tree.

     Parameter  Description
  1  $t         Tree descriptor
  2  $key       Key as a dword

B<Example:>


  if (00) {
    my $L = K(loop, 4);
    my $b = CreateArea;
    my $T = $b->CreateTree;
    my $t = $T->describeTreereload;

    $L->for(sub
     {my ($i, $start, $next, $end) = @_;
      $t->insertTreeAndReload($i);
      $t->first->outNL;
     });

    $t->insert($L, $L*2);

    my $f = $T->reload;
    $L->for(sub
     {my ($i, $start, $next, $end) = @_;
      $f->findAndReload($i);
      $i->out('i: '); $f->found->out('  f: '); $f->data->out('  d: '); $f->subTree->outNL('  s: ');
     });
    $f->find($L);
    $L->out('N: '); $f->found->out('  f: '); $f->data->out('  d: ');   $f->subTree->outNL('  s: ');

    ok Assemble(debug => 0, eq => <<END);
  first: 0000 0000 0000 0098
  first: 0000 0000 0000 0118
  first: 0000 0000 0000 0198
  first: 0000 0000 0000 0218
  i: 0000 0000 0000 0000  f: 0000 0000 0000 0001  d: 0000 0000 0000 0098  s: 0000 0000 0000 0001
  i: 0000 0000 0000 0001  f: 0000 0000 0000 0001  d: 0000 0000 0000 0118  s: 0000 0000 0000 0001
  i: 0000 0000 0000 0002  f: 0000 0000 0000 0001  d: 0000 0000 0000 0198  s: 0000 0000 0000 0001
  i: 0000 0000 0000 0003  f: 0000 0000 0000 0001  d: 0000 0000 0000 0218  s: 0000 0000 0000 0001
  N: 0000 0000 0000 0004  f: 0000 0000 0000 0001  d: 0000 0000 0000 0008  s: 0000 0000 0000 0000
  END
   }


=head2 Nasm::X86::Tree::leftOrRightMost($tree, $dir, $node, $offset)

Return the offset of the left most or right most node.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $dir       Direction: left = 0 or right = 1
  3  $node      Start node
  4  $offset    Offset of located node

=head2 Nasm::X86::Tree::leftMost($t, $node, $offset)

Return the offset of the left most node from the specified node.

     Parameter  Description
  1  $t         Tree descriptor
  2  $node      Start node
  3  $offset    Returned offset

=head2 Nasm::X86::Tree::rightMost($t, $node, $offset)

Return the offset of the left most node from the specified node.

     Parameter  Description
  1  $t         Tree descriptor
  2  $node      Start node
  3  $offset    Returned offset

=head2 Nasm::X86::Tree::isTree($t, $zmm, $point)

Set the Zero Flag to oppose the tree bit in the numbered zmm register holding the keys of a node to indicate whether the data element indicated by the specified register is an offset to a sub tree in the containing area or not.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm register holding the keys for a node in the tree
  3  $point     Register showing point to test

B<Example:>



    my $t = DescribeTree;
    Mov r8, 0b100; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b001; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->clearTreeBit(31, r8);            PrintOutRegisterInHex 31;

                                                       $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertZeroIntoTreeBits(31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertOneIntoTreeBits (31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);

    $t->getTreeBits(31, r8);
    V(TreeBits => r8)->outRightInHexNL(K width => 4);
    PrintOutRegisterInHex 31;

    Mov r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Not r8; $t->setTreeBits(31, r8); PrintOutRegisterInHex 31;

    ok Assemble eq => <<END;
   zmm31: 0000 0000 0004 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0006 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0007 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0005 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
               101
              1001
             10011
    13
   zmm31: 0000 0000 0013 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  ZF=0
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
   zmm31: 0000 0000 3FFF 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END


=head2 Nasm::X86::Tree::getTreeBit($t, $zmm, $point)

Get the tree bit from the numbered zmm at the specified point and return it in a variable as a one or a zero.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Register showing point to test
  3  $point     Numbered zmm register holding the keys for a node in the tree

=head2 Nasm::X86::Tree::setOrClearTreeBit($t, $set, $point, $zmm)

Set or clear the tree bit selected by the specified point in the numbered zmm register holding the keys of a node to indicate that the data element indicated by the specified register is an offset to a sub tree in the containing area.

     Parameter  Description
  1  $t         Tree descriptor
  2  $set       Set if true else clear
  3  $point     Register holding point to set
  4  $zmm       Numbered zmm register holding the keys for a node in the tree

=head2 Nasm::X86::Tree::setTreeBit($t, $zmm, $point)

Set the tree bit in the numbered zmm register holding the keys of a node to indicate that the data element indexed by the specified register is an offset to a sub tree in the containing area.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm register holding the keys for a node in the tree
  3  $point     Register holding the point to clear

=head2 Nasm::X86::Tree::clearTreeBit($t, $zmm, $point)

Clear the tree bit in the numbered zmm register holding the keys of a node to indicate that the data element indexed by the specified register is an offset to a sub tree in the containing area.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm register holding the keys for a node in the tree
  3  $point     Register holding register holding the point to set

=head2 Nasm::X86::Tree::setOrClearTreeBitToMatchContent($t, $zmm, $point, $content)

Set or clear the tree bit pointed to by the specified register depending on the content of the specified variable.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm
  3  $point     Register indicating point
  4  $content   Content indicating zero or one

=head2 Nasm::X86::Tree::getTreeBits($t, $zmm, $register)

Load the tree bits from the numbered zmm into the specified register.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm
  3  $register  Target register

B<Example:>



    my $t = DescribeTree;
    Mov r8, 0b100; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b001; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->clearTreeBit(31, r8);            PrintOutRegisterInHex 31;

                                                       $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertZeroIntoTreeBits(31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertOneIntoTreeBits (31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);

    $t->getTreeBits(31, r8);
    V(TreeBits => r8)->outRightInHexNL(K width => 4);
    PrintOutRegisterInHex 31;

    Mov r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Not r8; $t->setTreeBits(31, r8); PrintOutRegisterInHex 31;

    ok Assemble eq => <<END;
   zmm31: 0000 0000 0004 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0006 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0007 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0005 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
               101
              1001
             10011
    13
   zmm31: 0000 0000 0013 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  ZF=0
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
   zmm31: 0000 0000 3FFF 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END


=head2 Nasm::X86::Tree::setTreeBits($t, $zmm, $register)

Put the tree bits in the specified register into the numbered zmm.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm
  3  $register  Target register

B<Example:>



    my $t = DescribeTree;
    Mov r8, 0b100; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b001; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->clearTreeBit(31, r8);            PrintOutRegisterInHex 31;

                                                       $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertZeroIntoTreeBits(31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertOneIntoTreeBits (31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);

    $t->getTreeBits(31, r8);
    V(TreeBits => r8)->outRightInHexNL(K width => 4);
    PrintOutRegisterInHex 31;

    Mov r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Not r8; $t->setTreeBits(31, r8); PrintOutRegisterInHex 31;

    ok Assemble eq => <<END;
   zmm31: 0000 0000 0004 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0006 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0007 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0005 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
               101
              1001
             10011
    13
   zmm31: 0000 0000 0013 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  ZF=0
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
   zmm31: 0000 0000 3FFF 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END


=head2 Nasm::X86::Tree::insertTreeBit($t, $onz, $zmm, $point)

Insert a zero or one into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.

     Parameter  Description
  1  $t         Tree descriptor
  2  $onz       0 - zero or 1 - one
  3  $zmm       Numbered zmm
  4  $point     Register indicating point

=head2 Nasm::X86::Tree::insertZeroIntoTreeBits($t, $zmm, $point)

Insert a zero into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm
  3  $point     Register indicating point

B<Example:>



    my $t = DescribeTree;
    Mov r8, 0b100; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b001; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->clearTreeBit(31, r8);            PrintOutRegisterInHex 31;

                                                       $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertZeroIntoTreeBits(31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertOneIntoTreeBits (31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);

    $t->getTreeBits(31, r8);
    V(TreeBits => r8)->outRightInHexNL(K width => 4);
    PrintOutRegisterInHex 31;

    Mov r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Not r8; $t->setTreeBits(31, r8); PrintOutRegisterInHex 31;

    ok Assemble eq => <<END;
   zmm31: 0000 0000 0004 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0006 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0007 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0005 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
               101
              1001
             10011
    13
   zmm31: 0000 0000 0013 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  ZF=0
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
   zmm31: 0000 0000 3FFF 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END


=head2 Nasm::X86::Tree::insertOneIntoTreeBits($t, $zmm, $point)

Insert a one into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm
  3  $point     Register indicating point

B<Example:>



    my $t = DescribeTree;
    Mov r8, 0b100; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b001; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
    Mov r8, 0b010; $t->clearTreeBit(31, r8);            PrintOutRegisterInHex 31;

                                                       $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertZeroIntoTreeBits(31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
    Mov r8, 0b010; $t->insertOneIntoTreeBits (31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);

    $t->getTreeBits(31, r8);
    V(TreeBits => r8)->outRightInHexNL(K width => 4);
    PrintOutRegisterInHex 31;

    Mov r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
    Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

    Not r8; $t->setTreeBits(31, r8); PrintOutRegisterInHex 31;

    ok Assemble eq => <<END;
   zmm31: 0000 0000 0004 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0006 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0007 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
   zmm31: 0000 0000 0005 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
               101
              1001
             10011
    13
   zmm31: 0000 0000 0013 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  ZF=0
  ZF=0
  ZF=1
  ZF=1
  ZF=0
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
  ZF=1
   zmm31: 0000 0000 3FFF 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END


=head2 Nasm::X86::Tree::insertIntoTreeBits($t, $zmm, $point, $content)

Insert a one into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.

     Parameter  Description
  1  $t         Tree descriptor
  2  $zmm       Numbered zmm
  3  $point     Register indicating point
  4  $content   Bit to insert

=head2 Nasm::X86::Tree::extract($tree, $point, $K, $D, $N)

Extract the key/data/node and tree bit at the specified point from the block held in the specified zmm registers.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $point     Point at which to extract
  3  $K         Keys zmm
  4  $D         Data zmm
  5  $N         Node zmm

B<Example:>


    my ($K, $D, $N) = (31, 30, 29);

    K(K => Rd( 1..16))->loadZmm($K);
    K(K => Rd( 1..16))->loadZmm($D);
    K(K => Rd(map {0} 1..16))->loadZmm($N);

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 13);

    my $p = K(one => 1) << K three => 3;
    Mov r15, 0xAAAA;
    $t->setTreeBits($K, r15);

    PrintOutStringNL "Start";
    PrintOutRegisterInHex 31, 30, 29;

    $t->extract($p, $K, $D, $N);

    PrintOutStringNL "Finish";
    PrintOutRegisterInHex 31, 30, 29;

    ok Assemble eq => <<END;
  Start
   zmm31: 0000 0010 2AAA 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  Finish
   zmm31: 0000 0010 2AAA 000E   0000 000E 0000 000E   0000 000D 0000 000C   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000E   0000 000D 0000 000C   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  END


=head2 Nasm::X86::Tree::extractFirst($tree, $K, $D, $N)

Extract the first key/data and tree bit at the specified point from the block held in the specified zmm registers and place the extracted data/bit in tree data/subTree.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $K         Keys zmm
  3  $D         Data zmm
  4  $N         Node zmm

B<Example:>


    my ($K, $D, $N) = (31, 30, 29);

    K(K => Rd( 1..16))       ->loadZmm($K);
    K(K => Rd( 1..16))       ->loadZmm($D);
    K(K => Rd(map {0} 1..16))->loadZmm($N);

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 13);

    my $p = K(one => 1) << K three => 3;
    Mov r15, 0xAAAA;
    $t->setTreeBits($K, r15);

    PrintOutStringNL "Start";
    PrintOutRegisterInHex 31, 30, 29;

    K(n=>4)->for(sub
     {my ($index, $start, $next, $end) = @_;

      $t->extractFirst($K, $D, $N);

      PrintOutStringNL "-------------";
      $index->outNL;
      PrintOutRegisterInHex 31, 30, 29;

      $t->data->outNL;
      $t->subTree->outNL;
      $t->lengthFromKeys($K)->outNL;
     });

    ok Assemble eq => <<END;
  Start
   zmm31: 0000 0010 2AAA 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003   0000 0002 0000 0001
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  -------------
  index: 0000 0000 0000 0000
   zmm31: 0000 0010 1555 000E   0000 000E 0000 000E   0000 000D 0000 000C   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000E   0000 000D 0000 000C   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004   0000 0003 0000 0002
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  data: 0000 0000 0000 0001
  subTree: 0000 0000 0000 0000
  b at offset 56 in zmm31: 0000 0000 0000 000E
  -------------
  index: 0000 0000 0000 0001
   zmm31: 0000 0010 0AAA 000D   0000 000E 0000 000E   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000E   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005   0000 0004 0000 0003
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  data: 0000 0000 0000 0002
  subTree: 0000 0000 0000 0001
  b at offset 56 in zmm31: 0000 0000 0000 000D
  -------------
  index: 0000 0000 0000 0002
   zmm31: 0000 0010 0555 000C   0000 000E 0000 000E   0000 000E 0000 000E   0000 000D 0000 000C   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000E   0000 000E 0000 000E   0000 000D 0000 000C   0000 000B 0000 000A   0000 0009 0000 0008   0000 0007 0000 0006   0000 0005 0000 0004
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  data: 0000 0000 0000 0003
  subTree: 0000 0000 0000 0000
  b at offset 56 in zmm31: 0000 0000 0000 000C
  -------------
  index: 0000 0000 0000 0003
   zmm31: 0000 0010 02AA 000B   0000 000E 0000 000E   0000 000E 0000 000E   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005
   zmm30: 0000 0010 0000 000F   0000 000E 0000 000E   0000 000E 0000 000E   0000 000E 0000 000D   0000 000C 0000 000B   0000 000A 0000 0009   0000 0008 0000 0007   0000 0006 0000 0005
   zmm29: 0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000
  data: 0000 0000 0000 0004
  subTree: 0000 0000 0000 0001
  b at offset 56 in zmm31: 0000 0000 0000 000B
  END


=head2 Nasm::X86::Tree::mergeOrSteal($tree, $offset)

Merge the block at the specified offset with its right sibling or steal from it. If there is no  right sibling then do the same thing but with the left sibling.  The supplied block must not be the root. The key we ae looking for must be in the tree key field.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $offset    Offset of non root block that might need to merge or steal

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    $t->put(   K(k=>1), K(d=>11));
    $t->put(   K(k=>2), K(d=>22));
    $t->put(   K(k=>3), K(d=>33));
    $t->put(   K(k=>4), K(d=>44));
    $t->put(   K(k=>5), K(d=>55));
    $t->put(   K(k=>6), K(d=>56));

    $t->getBlock(K(o=>0x2C0), 31, 30, 29);
    $t->lengthIntoKeys(31, K 1 => 1);
    $t->putBlock(K(o=>0x2C0), 31, 30, 29);
    $t->dump("6");

    $t->key->copy(K k => 4);
    $t->mergeOrSteal(K o => 0x140);
    $t->dump("5");

    ok Assemble eq => <<END;
  6
  At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0    1
    Keys :    2    4
    Data :   22   44
    Nodes:   80  140  2C0
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :   11
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    3
        Data :   33
      end
      At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    5
        Data :   55
      end
  end
  5
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :   22
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :   11
      end
      At:  140                length:    3,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1    2
        Keys :    3    4    5
        Data :   33   44   55
      end
  end
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    $t->put(   K(k=>1), K(d=>11));
    $t->put(   K(k=>2), K(d=>22));
    $t->put(   K(k=>3), K(d=>33));
    $t->put(   K(k=>4), K(d=>44));
    $t->put(   K(k=>5), K(d=>55));
    $t->put(   K(k=>6), K(d=>56));

    $t->getBlock(K(o=>0x2C0), 31, 30, 29);
    $t->lengthIntoKeys(31, K 1 => 1);
    $t->putBlock(K(o=>0x2C0), 31, 30, 29);
    $t->dump("6");

    $t->key->copy(K k => 4);
    $t->mergeOrSteal(K o => 0x140);
    $t->dump("5");

    ok Assemble eq => <<END;
  6
  At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0    1
    Keys :    2    4
    Data :   22   44
    Nodes:   80  140  2C0
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :   11
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    3
        Data :   33
      end
      At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    5
        Data :   55
      end
  end
  5
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    2
    Data :   22
    Nodes:   80  140
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :   11
      end
      At:  140                length:    3,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0    1    2
        Keys :    3    4    5
        Data :   33   44   55
      end
  end
  END

    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    $t->put(   K(k=>1), K(d=>11));
    $t->put(   K(k=>2), K(d=>22));
    $t->put(   K(k=>3), K(d=>33));
    $t->put(   K(k=>4), K(d=>44));
    $t->put(   K(k=>5), K(d=>55));
    $t->put(   K(k=>6), K(d=>56));

    $t->getBlock(K(o=>0x2C0), 31, 30, 29);
    $t->lengthIntoKeys(31, K 1 => 1);
    $t->putBlock(K(o=>0x2C0), 31, 30, 29);
    $t->dump("6");

    $t->key->copy(K k => 2);
    $t->mergeOrSteal(K o => 0x80);
    $t->dump("5");

    ok Assemble eq => <<END;
  6
  At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0    1
    Keys :    2    4
    Data :   22   44
    Nodes:   80  140  2C0
      At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    1
        Data :   11
      end
      At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    3
        Data :   33
      end
      At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    5
        Data :   55
      end
  end
  5
  At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
    Index:    0
    Keys :    4
    Data :   44
    Nodes:   80  2C0
      At:   80                length:    3,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
        Index:    0    1    2
        Keys :    1    2    3
        Data :   11   22   33
      end
      At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
        Index:    0
        Keys :    5
        Data :   55
      end
  end
  END


=head2 Nasm::X86::Tree::stealFromRight($tree, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)

Steal one key from the node on the right where the current left node,parent node and right node are held in zmm registers and return one if the steal was performed, else zero.

      Parameter  Description
   1  $tree      Tree definition
   2  $PK        Parent keys zmm
   3  $PD        Data zmm
   4  $PN        Nodes zmm
   5  $LK        Left keys zmm
   6  $LD        Data zmm
   7  $LN        Nodes zmm
   8  $RK        Right keys
   9  $RD        Data
  10  $RN        Nodes zmm.

=head2 Nasm::X86::Tree::stealFromLeft($tree, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)

Steal one key from the node on the left where the current left node,parent node and right node are held in zmm registers and return one if the steal was performed, else  zero.

      Parameter  Description
   1  $tree      Tree definition
   2  $PK        Parent keys zmm
   3  $PD        Data zmm
   4  $PN        Nodes zmm
   5  $LK        Left keys zmm
   6  $LD        Data zmm
   7  $LN        Nodes zmm
   8  $RK        Right keys
   9  $RD        Data
  10  $RN        Nodes zmm.

=head2 Nasm::X86::Tree::merge($tree, $PK, $PD, $PN, $LK, $LD, $LN, $RK, $RD, $RN)

Merge a left and right node if they are at minimum size.

      Parameter  Description
   1  $tree      Tree definition
   2  $PK        Parent keys zmm
   3  $PD        Data zmm
   4  $PN        Nodes zmm
   5  $LK        Left keys zmm
   6  $LD        Data zmm
   7  $LN        Nodes zmm
   8  $RK        Right keys
   9  $RD        Data
  10  $RN        Nodes zmm.

=head2 Nasm::X86::Tree::deleteFirstKeyAndData($tree, $K, $D)

Delete the first element of a leaf mode returning its characteristics in the calling tree descriptor.

     Parameter  Description
  1  $tree      Tree definition
  2  $K         Keys zmm
  3  $D         Data zmm

=head2 Nasm::X86::Tree::push($tree, $data)

Push a data value onto a tree. If the data is a reference to a tree then the offset of the first block of the tree is pushed.

     Parameter  Description
  1  $tree      Tree descriptor
  2  $data      Variable data

B<Example:>


    my $a = CreateArea;
    my $t = $a->CreateTree(length => 3);
    my $N = K loop => 16;
    $N->for(sub
     {my ($i) = @_;
      $t->push($i);
     });

    $t->size->outNL;
    $t->get(K(key => 8)); $t->found->out("f: ", " ");  $t->key->out("i: ", " "); $t->data->outNL;

    $N->for(sub
     {my ($i) = @_;
      $t->pop; $t->found->out("f: ", " ");  $t->key->out("i: ", " "); $t->data->outNL;
     });
    $t->pop; $t->found->outNL("f: ");

    ok Assemble eq => <<END;
  size of tree: 0000 0000 0000 0010
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0008 data: 0000 0000 0000 0008
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000F data: 0000 0000 0000 000F
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000E data: 0000 0000 0000 000E
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000D data: 0000 0000 0000 000D
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000C data: 0000 0000 0000 000C
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000B data: 0000 0000 0000 000B
  f: 0000 0000 0000 0001 i: 0000 0000 0000 000A data: 0000 0000 0000 000A
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0009 data: 0000 0000 0000 0009
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0008 data: 0000 0000 0000 0008
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0007 data: 0000 0000 0000 0007
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0006 data: 0000 0000 0000 0006
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0005 data: 0000 0000 0000 0005
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0004 data: 0000 0000 0000 0004
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0003 data: 0000 0000 0000 0003
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0002 data: 0000 0000 0000 0002
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0001 data: 0000 0000 0000 0001
  f: 0000 0000 0000 0001 i: 0000 0000 0000 0000 data: 0000 0000 0000 0000
  f: 0000 0000 0000 0000
  END


=head2 LocateIntelEmulator()

Locate the Intel Software Development Emulator.


=head2 getInstructionCount()

Get the number of instructions executed from the emulator mix file.


=head2 Optimize(%options)

Perform code optimizations.

     Parameter  Description
  1  %options   Options

=head2 removeNonAsciiChars($string)

Return a copy of the specified string with all the non ascii characters removed.

     Parameter  Description
  1  $string    String

=head2 totalBytesAssembled()

Total size in bytes of all files assembled during testing.



=head1 Index


1 L<AllocateMemory|/AllocateMemory> - Allocate the variable specified amount of memory via mmap and return its address as a variable.

2 L<AndBlock|/AndBlock> - Short circuit B<and>: execute a block of code to test conditions which, if all of them pass, allows the first block to continue successfully else if one of the conditions fails we execute the optional fail block.

3 L<Assemble|/Assemble> - Assemble the generated code.

4 L<bFromX|/bFromX> - Get the byte from the numbered xmm register and return it in a variable.

5 L<bFromZ|/bFromZ> - Get the byte from the numbered zmm register and return it in a variable.

6 L<Block|/Block> - Execute a block of code with labels supplied for the start and end of this code

7 L<bRegFromZmm|/bRegFromZmm> - Load the specified register from the byte at the specified offset located in the numbered zmm.

8 L<bRegIntoZmm|/bRegIntoZmm> - Put the byte content of the specified register into the byte in the numbered zmm at the specified offset in the zmm.

9 L<CallC|/CallC> - Call a C subroutine.

10 L<CheckIfMaskRegisterNumber|/CheckIfMaskRegisterNumber> - Check that a register is in fact a mask register.

11 L<CheckMaskRegister|/CheckMaskRegister> - Check that a register is in fact a numbered mask register

12 L<CheckMaskRegisterNumber|/CheckMaskRegisterNumber> - Check that a register is in fact a mask register and confess if it is not.

13 L<checkZmmRegister|/checkZmmRegister> - Check that a register is a zmm register

14 L<ChooseRegisters|/ChooseRegisters> - Choose the specified numbers of registers excluding those on the specified list.

15 L<ClassifyInRange|/ClassifyInRange> - Character classification: classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1 formatted in double words with each double word in zmm0 having the classification in the highest 8 bits and with zmm0 and zmm1 having the utf32 character at the start (zmm0) and end (zmm1) of each range in the lowest 18 bits.

16 L<ClassifyRange|/ClassifyRange> - Implementation of ClassifyInRange and ClassifyWithinRange.

17 L<ClassifyWithInRange|/ClassifyWithInRange> - Bracket classification: Classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1 formatted in double words with the classification range in the high byte of each dword in zmm0 and the utf32 character at the start (zmm0) and end (zmm1) of each range in the lower 18 bits of each dword.

18 L<ClassifyWithInRangeAndSaveOffset|/ClassifyWithInRangeAndSaveOffset> - Alphabetic classification: classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1 formatted in double words with the classification code in the highest byte of each double word in zmm0 and the offset of the first element in the range in the highest byte of each dword in zmm1.

19 L<ClassifyWithInRangeAndSaveWordOffset|/ClassifyWithInRangeAndSaveWordOffset> - Alphabetic classification: classify the utf32 characters in a block of memory of specified length using a range specification held in zmm0, zmm1, zmm2 formatted in double words.

20 L<ClearMemory|/ClearMemory> - Clear memory wit a variable address and variable length

21 L<ClearRegisters|/ClearRegisters> - Clear registers by setting them to zero.

22 L<ClearZF|/ClearZF> - Clear the zero flag.

23 L<CloseFile|/CloseFile> - Close the file whose descriptor is in rax.

24 L<Comment|/Comment> - Insert a comment into the assembly code.

25 L<CommentWithTraceBack|/CommentWithTraceBack> - Insert a comment into the assembly code with a traceback showing how it was generated.

26 L<convert_rax_from_utf32_to_utf8|/convert_rax_from_utf32_to_utf8> - Convert a utf32 character held in rax to a utf8 character held in rax

27 L<ConvertUtf8ToUtf32|/ConvertUtf8ToUtf32> - Convert a string of utf8 to an allocated block of utf32 and return its address and length.

28 L<CopyMemory|/CopyMemory> - Copy memory.

29 L<copyStructureMinusVariables|/copyStructureMinusVariables> - Copy a non recursive structure ignoring variables

30 L<CreateArea|/CreateArea> - Create an relocatable area and returns its address in rax.

31 L<createBitNumberFromAlternatingPattern|/createBitNumberFromAlternatingPattern> - Create a number from a bit pattern.

32 L<CreateLibrary|/CreateLibrary> - Create a library.

33 L<Cstrlen|/Cstrlen> - Length of the C style string addressed by rax returning the length in r15.

34 L<Db|/Db> - Layout bytes in the data segment and return their label.

35 L<Dbwdq|/Dbwdq> - Layout data.

36 L<DComment|/DComment> - Insert a comment into the data segment.

37 L<Dd|/Dd> - Layout double words in the data segment and return their label.

38 L<DescribeArea|/DescribeArea> - Describe a relocatable area.

39 L<DescribeTree|/DescribeTree> - Return a descriptor for a tree with the specified options.

40 L<dFromX|/dFromX> - Get the double word from the numbered xmm register and return it in a variable.

41 L<dFromZ|/dFromZ> - Get the double word from the numbered zmm register and return it in a variable.

42 L<Dq|/Dq> - Layout quad words in the data segment and return their label.

43 L<Ds|/Ds> - Layout bytes in memory and return their label.

44 L<Dw|/Dw> - Layout words in the data segment and return their label.

45 L<Ef|/Ef> - Else if block for an If statement.

46 L<Else|/Else> - Else block for an If statement.

47 L<executeFileViaBash|/executeFileViaBash> - Execute the file named in a variable

48 L<Exit|/Exit> - Exit with the specified return code or zero if no return code supplied.

49 L<Extern|/Extern> - Name external references.

50 L<Fail|/Fail> - Fail block for an L<AndBlock>.

51 L<For|/For> - For - iterate the block as long as register is less than limit incrementing by increment each time.

52 L<ForEver|/ForEver> - Iterate for ever.

53 L<ForIn|/ForIn> - For - iterate the full block as long as register plus increment is less than than limit incrementing by increment each time then increment the last block for the last non full block.

54 L<Fork|/Fork> - Fork: create and execute a copy of the current process.

55 L<FreeMemory|/FreeMemory> - Free memory specified by variables.

56 L<getBwdqFromMm|/getBwdqFromMm> - Get the numbered byte|word|double word|quad word from the numbered zmm register and return it in a variable.

57 L<getInstructionCount|/getInstructionCount> - Get the number of instructions executed from the emulator mix file.

58 L<GetNextUtf8CharAsUtf32|/GetNextUtf8CharAsUtf32> - Get the next UTF-8 encoded character from the addressed memory and return it as a UTF-32 char.

59 L<GetPid|/GetPid> - Get process identifier.

60 L<GetPidInHex|/GetPidInHex> - Get process identifier in hex as 8 zero terminated bytes in rax.

61 L<GetPPid|/GetPPid> - Get parent process identifier.

62 L<GetUid|/GetUid> - Get userid of current process.

63 L<Hash|/Hash> - Hash a string addressed by rax with length held in rdi and return the hash code in r15.

64 L<hexTranslateTable|/hexTranslateTable> - Create/address a hex translate table and return its label.

65 L<If|/If> - If statement.

66 L<IfC|/IfC> - If the carry flag is set then execute the then block else the else block.

67 L<IfEq|/IfEq> - If equal execute the then block else the else block.

68 L<IfGe|/IfGe> - If greater than or equal execute the then block else the else block.

69 L<IfGt|/IfGt> - If greater than execute the then block else the else block.

70 L<IfLe|/IfLe> - If less than or equal execute the then block else the else block.

71 L<IfLt|/IfLt> - If less than execute the then block else the else block.

72 L<IfNc|/IfNc> - If the carry flag is not set then execute the then block else the else block.

73 L<IfNe|/IfNe> - If not equal execute the then block else the else block.

74 L<IfNs|/IfNs> - If signed less than execute the then block else the else block.

75 L<IfNz|/IfNz> - If the zero flag is not set then execute the then block else the else block.

76 L<IfS|/IfS> - If signed greater than or equal execute the then block else the else block.

77 L<IfZ|/IfZ> - If the zero flag is set then execute the then block else the else block.

78 L<InsertOneIntoRegisterAtPoint|/InsertOneIntoRegisterAtPoint> - Insert a one into the specified register at the point indicated by another register.

79 L<InsertZeroIntoRegisterAtPoint|/InsertZeroIntoRegisterAtPoint> - Insert a zero into the specified register at the point indicated by another general purpose or mask register moving the higher bits one position to the left.

80 L<K|/K> - Define a constant variable.

81 L<Label|/Label> - Create a unique label or reuse the one supplied.

82 L<Link|/Link> - Libraries to link with.

83 L<LoadBitsIntoMaskRegister|/LoadBitsIntoMaskRegister> - Load a bit string specification into a mask register in two clocks.

84 L<LoadConstantIntoMaskRegister|/LoadConstantIntoMaskRegister> - Set a mask register equal to a constant.

85 L<LoadRegFromMm|/LoadRegFromMm> - Load the specified register from the numbered zmm at the quad offset specified as a constant number.

86 L<LoadZmm|/LoadZmm> - Load a numbered zmm with the specified bytes.

87 L<LocateIntelEmulator|/LocateIntelEmulator> - Locate the Intel Software Development Emulator.

88 L<Nasm::X86::Area::allocate|/Nasm::X86::Area::allocate> - Allocate the variable amount of space in the variable addressed area and return the offset of the allocation in the area as a variable.

89 L<Nasm::X86::Area::allocZmmBlock|/Nasm::X86::Area::allocZmmBlock> - Allocate a block to hold a zmm register in the specified area and return the offset of the block as a variable.

90 L<Nasm::X86::Area::append|/Nasm::X86::Area::append> - Append one area to another.

91 L<Nasm::X86::Area::char|/Nasm::X86::Area::char> - Append a character expressed as a decimal number to the specified area.

92 L<Nasm::X86::Area::checkYggdrasilCreated|/Nasm::X86::Area::checkYggdrasilCreated> - Return a tree descriptor to the Yggdrasil world tree for an area.

93 L<Nasm::X86::Area::clear|/Nasm::X86::Area::clear> - Clear an area

94 L<Nasm::X86::Area::clearZmmBlock|/Nasm::X86::Area::clearZmmBlock> - Clear the zmm block at the specified offset in the area

95 L<Nasm::X86::Area::CreateTree|/Nasm::X86::Area::CreateTree> - Create a tree in an area.

96 L<Nasm::X86::Area::DescribeTree|/Nasm::X86::Area::DescribeTree> - Return a descriptor for a tree in the specified area with the specified options.

97 L<Nasm::X86::Area::dump|/Nasm::X86::Area::dump> - Dump details of an area.

98 L<Nasm::X86::Area::establishYggdrasil|/Nasm::X86::Area::establishYggdrasil> - Return a tree descriptor to the Yggdrasil world tree for an area creating the world tree Yggdrasil if it has not already been created.

99 L<Nasm::X86::Area::free|/Nasm::X86::Area::free> - Free an area

100 L<Nasm::X86::Area::freeChainSpace|/Nasm::X86::Area::freeChainSpace> - Count the number of blocks available on the free chain

101 L<Nasm::X86::Area::freeZmmBlock|/Nasm::X86::Area::freeZmmBlock> - Free a block in an area by placing it on the free chain.

102 L<Nasm::X86::Area::getZmmBlock|/Nasm::X86::Area::getZmmBlock> - Get the block with the specified offset in the specified string and return it in the numbered zmm.

103 L<Nasm::X86::Area::m|/Nasm::X86::Area::m> - Append the variable addressed content of variable size to the specified area.

104 L<Nasm::X86::Area::makeReadOnly|/Nasm::X86::Area::makeReadOnly> - Make an area read only.

105 L<Nasm::X86::Area::makeWriteable|/Nasm::X86::Area::makeWriteable> - Make an area writable.

106 L<Nasm::X86::Area::nl|/Nasm::X86::Area::nl> - Append a new line to the area addressed by rax.

107 L<Nasm::X86::Area::out|/Nasm::X86::Area::out> - Print the specified area on sysout.

108 L<Nasm::X86::Area::outNL|/Nasm::X86::Area::outNL> - Print the specified area on sysout followed by a new line.

109 L<Nasm::X86::Area::putZmmBlock|/Nasm::X86::Area::putZmmBlock> - Write the numbered zmm to the block at the specified offset in the specified area.

110 L<Nasm::X86::Area::q|/Nasm::X86::Area::q> - Append a constant string to the area.

111 L<Nasm::X86::Area::ql|/Nasm::X86::Area::ql> - Append a quoted string containing new line characters to the specified area.

112 L<Nasm::X86::Area::read|/Nasm::X86::Area::read> - Read a file specified by a variable addressed zero terminated string and place the contents of the file into the named area.

113 L<Nasm::X86::Area::size|/Nasm::X86::Area::size> - Get the size of an area as a variab;e.

114 L<Nasm::X86::Area::updateSpace|/Nasm::X86::Area::updateSpace> - Make sure that the variable addressed area has enough space to accommodate content of the variable size.

115 L<Nasm::X86::Area::used|/Nasm::X86::Area::used> - Return the currently used size of an area as a variable.

116 L<Nasm::X86::Area::write|/Nasm::X86::Area::write> - Write the content of the specified area to a file specified by a zero terminated string.

117 L<Nasm::X86::Area::z|/Nasm::X86::Area::z> - Append a trailing zero to the area addressed by rax.

118 L<Nasm::X86::Sub::call|/Nasm::X86::Sub::call> - Call a sub passing it some parameters.

119 L<Nasm::X86::Sub::callTo|/Nasm::X86::Sub::callTo> - Call a sub passing it some parameters.

120 L<Nasm::X86::Sub::dispatch|/Nasm::X86::Sub::dispatch> - Jump into the specified subroutine so that code of the target subroutine is executed instead of the code of the current subroutine allowing the target subroutine to be dispatched to process the parameter list of the current subroutine.

121 L<Nasm::X86::Sub::dispatchV|/Nasm::X86::Sub::dispatchV> - L<Dispatch|/Nasm::X86::Sub::dispatch> the variable subroutine using the specified register.

122 L<Nasm::X86::Sub::V|/Nasm::X86::Sub::V> - Put the address of a subroutine into a stack variable so that it can be passed as a parameter.

123 L<Nasm::X86::Sub::via|/Nasm::X86::Sub::via> - Call a sub by reference passing it some parameters.

124 L<Nasm::X86::Subroutine::call|/Nasm::X86::Subroutine::call> - Call a sub optionally passing it parameters.

125 L<Nasm::X86::Subroutine::mapStructureVariables|/Nasm::X86::Subroutine::mapStructureVariables> - Find the paths to variables in the copies of the structures passed as parameters and replace those variables with references so that in the subroutine we can refer to these variables regardless of where they are actually defined

126 L<Nasm::X86::Subroutine::uploadStructureVariablesToNewStackFrame|/Nasm::X86::Subroutine::uploadStructureVariablesToNewStackFrame> - Create references to variables in parameter structures from variables in the stack frame of the subroutine.

127 L<Nasm::X86::Subroutine::uploadToNewStackFrame|/Nasm::X86::Subroutine::uploadToNewStackFrame> - Map a variable in the current stack into a reference in the next stack frame being the one that will be used by this sub

128 L<Nasm::X86::Tree::allocBlock|/Nasm::X86::Tree::allocBlock> - Allocate a keys/data/node block and place it in the numbered zmm registers.

129 L<Nasm::X86::Tree::append|/Nasm::X86::Tree::append> - Append the second source string to the first target string renumbering the keys of the source string to follow on from those of the target string.

130 L<Nasm::X86::Tree::by|/Nasm::X86::Tree::by> - Call the specified block with each element of the specified tree in ascending order.

131 L<Nasm::X86::Tree::clear|/Nasm::X86::Tree::clear> - Delete everything in the tree recording the memory so liberated to the free chain for reuse by other trees.

132 L<Nasm::X86::Tree::clearTreeBit|/Nasm::X86::Tree::clearTreeBit> - Clear the tree bit in the numbered zmm register holding the keys of a node to indicate that the data element indexed by the specified register is an offset to a sub tree in the containing area.

133 L<Nasm::X86::Tree::clone|/Nasm::X86::Tree::clone> - Clone a string.

134 L<Nasm::X86::Tree::copyDescription|/Nasm::X86::Tree::copyDescription> - Make a copy of a tree descriptor

135 L<Nasm::X86::Tree::decLengthInKeys|/Nasm::X86::Tree::decLengthInKeys> - Decrement the number of keys in a keys block or complain if such is not possible

136 L<Nasm::X86::Tree::decSize|/Nasm::X86::Tree::decSize> - Decrement the size of a tree

137 L<Nasm::X86::Tree::decSizeInFirst|/Nasm::X86::Tree::decSizeInFirst> - Decrement the size field in the first block of a tree when the first block is held in a zmm register.

138 L<Nasm::X86::Tree::delete|/Nasm::X86::Tree::delete> - Find a key in a tree and delete it

139 L<Nasm::X86::Tree::deleteFirstKeyAndData|/Nasm::X86::Tree::deleteFirstKeyAndData> - Delete the first element of a leaf mode returning its characteristics in the calling tree descriptor.

140 L<Nasm::X86::Tree::depth|/Nasm::X86::Tree::depth> - Return the depth of a node within a tree.

141 L<Nasm::X86::Tree::describeTree|/Nasm::X86::Tree::describeTree> - Create a a description of a tree

142 L<Nasm::X86::Tree::dump|/Nasm::X86::Tree::dump> - Dump a tree and all its sub trees.

143 L<Nasm::X86::Tree::expand|/Nasm::X86::Tree::expand> - Expand the node at the specified offset in the specified tree if it needs to be expanded and is not the root node (which cannot be expanded because it has no siblings to take substance from whereas as all other nodes do).

144 L<Nasm::X86::Tree::extract|/Nasm::X86::Tree::extract> - Extract the key/data/node and tree bit at the specified point from the block held in the specified zmm registers.

145 L<Nasm::X86::Tree::extractFirst|/Nasm::X86::Tree::extractFirst> - Extract the first key/data and tree bit at the specified point from the block held in the specified zmm registers and place the extracted data/bit in tree data/subTree.

146 L<Nasm::X86::Tree::find|/Nasm::X86::Tree::find> - Find a key in a tree and tests whether the found data is a sub tree.

147 L<Nasm::X86::Tree::findAndReload|/Nasm::X86::Tree::findAndReload> - Find a key in the specified tree and clone it is it is a sub tree.

148 L<Nasm::X86::Tree::findFirst|/Nasm::X86::Tree::findFirst> - Find the first element in a tree

149 L<Nasm::X86::Tree::findLast|/Nasm::X86::Tree::findLast> - Find the last key in a tree

150 L<Nasm::X86::Tree::findNext|/Nasm::X86::Tree::findNext> - Find the next key greater than the one specified.

151 L<Nasm::X86::Tree::findPrev|/Nasm::X86::Tree::findPrev> - Find the previous key less than the one specified.

152 L<Nasm::X86::Tree::firstFromMemory|/Nasm::X86::Tree::firstFromMemory> - Load the first block for a tree into the numbered zmm.

153 L<Nasm::X86::Tree::firstIntoMemory|/Nasm::X86::Tree::firstIntoMemory> - Save the first block of a tree in the numbered zmm back into memory.

154 L<Nasm::X86::Tree::firstNode|/Nasm::X86::Tree::firstNode> - Return as a variable the last node block in the specified tree node held in a zmm

155 L<Nasm::X86::Tree::free|/Nasm::X86::Tree::free> - Free all the memory used by a tree

156 L<Nasm::X86::Tree::freeBlock|/Nasm::X86::Tree::freeBlock> - Free a keys/data/node block whise keys  block entry is located at the specified offset.

157 L<Nasm::X86::Tree::get|/Nasm::X86::Tree::get> - Retrieves the element at the specified zero based index in the stack.

158 L<Nasm::X86::Tree::getBlock|/Nasm::X86::Tree::getBlock> - Get the keys, data and child nodes for a tree node from the specified offset in the area for the tree.

159 L<Nasm::X86::Tree::getLoop|/Nasm::X86::Tree::getLoop> - Return the value of the loop field as a variable.

160 L<Nasm::X86::Tree::getTreeBit|/Nasm::X86::Tree::getTreeBit> - Get the tree bit from the numbered zmm at the specified point and return it in a variable as a one or a zero.

161 L<Nasm::X86::Tree::getTreeBits|/Nasm::X86::Tree::getTreeBits> - Load the tree bits from the numbered zmm into the specified register.

162 L<Nasm::X86::Tree::incLengthInKeys|/Nasm::X86::Tree::incLengthInKeys> - Increment the number of keys in a keys block or complain if such is not possible

163 L<Nasm::X86::Tree::incSize|/Nasm::X86::Tree::incSize> - Increment the size of a tree

164 L<Nasm::X86::Tree::incSizeInFirst|/Nasm::X86::Tree::incSizeInFirst> - Increment the size field in the first block of a tree when the first block is held in a zmm register.

165 L<Nasm::X86::Tree::indexEq|/Nasm::X86::Tree::indexEq> - Return the  position of a key in a zmm equal to the specified key as a point in a variable.

166 L<Nasm::X86::Tree::indexNode|/Nasm::X86::Tree::indexNode> - Return, as a variable, the point mask obtained by testing the nodes in a block for specified offset.

167 L<Nasm::X86::Tree::indexXX|/Nasm::X86::Tree::indexXX> - Return, as a variable, the mask obtained by performing a specified comparison on the key area of a node against a specified key.

168 L<Nasm::X86::Tree::insertIntoTreeBits|/Nasm::X86::Tree::insertIntoTreeBits> - Insert a one into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.

169 L<Nasm::X86::Tree::insertionPoint|/Nasm::X86::Tree::insertionPoint> - Return the position at which a key should be inserted into a zmm as a point in a variable.

170 L<Nasm::X86::Tree::insertKeyDataTreeIntoLeaf|/Nasm::X86::Tree::insertKeyDataTreeIntoLeaf> - Insert a new key/data/sub tree triple into a set of zmm registers if there is room, increment the length of the node and set the tree bit as indicated and increment the number of elements in the tree.

171 L<Nasm::X86::Tree::insertOneIntoTreeBits|/Nasm::X86::Tree::insertOneIntoTreeBits> - Insert a one into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.

172 L<Nasm::X86::Tree::insertTreeBit|/Nasm::X86::Tree::insertTreeBit> - Insert a zero or one into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.

173 L<Nasm::X86::Tree::insertZeroIntoTreeBits|/Nasm::X86::Tree::insertZeroIntoTreeBits> - Insert a zero into the tree bits field in the numbered zmm at the specified point moving the bits at and beyond point one position to the right.

174 L<Nasm::X86::Tree::isTree|/Nasm::X86::Tree::isTree> - Set the Zero Flag to oppose the tree bit in the numbered zmm register holding the keys of a node to indicate whether the data element indicated by the specified register is an offset to a sub tree in the containing area or not.

175 L<Nasm::X86::Tree::lastNode|/Nasm::X86::Tree::lastNode> - Return as a variable the last node block in the specified tree node held in a zmm

176 L<Nasm::X86::Tree::leafFromNodes|/Nasm::X86::Tree::leafFromNodes> - Return a variable containing true if we are on a leaf.

177 L<Nasm::X86::Tree::leftMost|/Nasm::X86::Tree::leftMost> - Return the offset of the left most node from the specified node.

178 L<Nasm::X86::Tree::leftOrRightMost|/Nasm::X86::Tree::leftOrRightMost> - Return the offset of the left most or right most node.

179 L<Nasm::X86::Tree::lengthFromKeys|/Nasm::X86::Tree::lengthFromKeys> - Get the length of the keys block in the numbered zmm and return it as a variable.

180 L<Nasm::X86::Tree::lengthIntoKeys|/Nasm::X86::Tree::lengthIntoKeys> - Get the length of the block in the numbered zmm from the specified variable.

181 L<Nasm::X86::Tree::maskForFullKeyArea|/Nasm::X86::Tree::maskForFullKeyArea> - Place a mask for the full key area in the numbered mask register

182 L<Nasm::X86::Tree::maskForFullNodesArea|/Nasm::X86::Tree::maskForFullNodesArea> - Place a mask for the full nodes area in the numbered mask register

183 L<Nasm::X86::Tree::merge|/Nasm::X86::Tree::merge> - Merge a left and right node if they are at minimum size.

184 L<Nasm::X86::Tree::mergeOrSteal|/Nasm::X86::Tree::mergeOrSteal> - Merge the block at the specified offset with its right sibling or steal from it.

185 L<Nasm::X86::Tree::nextNode|/Nasm::X86::Tree::nextNode> - Return as a variable the next node block offset after the specified one in the specified zmm

186 L<Nasm::X86::Tree::outAsUtf8|/Nasm::X86::Tree::outAsUtf8> - Print the data values of the specified string on stdout assuming each data value is a utf32 character and that the output device supports utf8

187 L<Nasm::X86::Tree::outAsUtf8NL|/Nasm::X86::Tree::outAsUtf8NL> - Print the data values of the specified string on stdout assuming each data value is a utf32 character and that the output device supports utf8.

188 L<Nasm::X86::Tree::overWriteKeyDataTreeInLeaf|/Nasm::X86::Tree::overWriteKeyDataTreeInLeaf> - Over write an existing key/data/sub tree triple in a set of zmm registers and set the tree bit as indicated.

189 L<Nasm::X86::Tree::pop|/Nasm::X86::Tree::pop> - Pop the last value out of a tree and return the key/data/subTree in the tree descriptor.

190 L<Nasm::X86::Tree::prevNode|/Nasm::X86::Tree::prevNode> - Return as a variable the previous node block offset after the specified one in the specified zmm

191 L<Nasm::X86::Tree::printInOrder|/Nasm::X86::Tree::printInOrder> - Print a tree in order

192 L<Nasm::X86::Tree::push|/Nasm::X86::Tree::push> - Push a data value onto a tree.

193 L<Nasm::X86::Tree::put|/Nasm::X86::Tree::put> - Put a variable key and data into a tree.

194 L<Nasm::X86::Tree::putBlock|/Nasm::X86::Tree::putBlock> - Put a tree block held in three zmm registers back into the area holding the tree at the specified offset.

195 L<Nasm::X86::Tree::putLoop|/Nasm::X86::Tree::putLoop> - Set the value of the loop field from a variable.

196 L<Nasm::X86::Tree::relativeNode|/Nasm::X86::Tree::relativeNode> - Return as a variable a node offset relative (specified as ac constant) to another offset in the same node in the specified zmm

197 L<Nasm::X86::Tree::replace|/Nasm::X86::Tree::replace> - Replace the key/data/subTree at the specified point in the specified zmm with the values found in the tree key/data/sub tree fields.

198 L<Nasm::X86::Tree::reverse|/Nasm::X86::Tree::reverse> - Create a clone of the sstring in reverse order

199 L<Nasm::X86::Tree::rightMost|/Nasm::X86::Tree::rightMost> - Return the offset of the left most node from the specified node.

200 L<Nasm::X86::Tree::root|/Nasm::X86::Tree::root> - Check whether the specified offset refers to the root of a tree when the first block is held in a zmm register.

201 L<Nasm::X86::Tree::rootFromFirst|/Nasm::X86::Tree::rootFromFirst> - Return a variable containing the offset of the root block of a tree from the first block when held in a zmm register.

202 L<Nasm::X86::Tree::rootIntoFirst|/Nasm::X86::Tree::rootIntoFirst> - Put the contents of a variable into the root field of the first block of a tree when held in a zmm register.

203 L<Nasm::X86::Tree::setOrClearTreeBit|/Nasm::X86::Tree::setOrClearTreeBit> - Set or clear the tree bit selected by the specified point in the numbered zmm register holding the keys of a node to indicate that the data element indicated by the specified register is an offset to a sub tree in the containing area.

204 L<Nasm::X86::Tree::setOrClearTreeBitToMatchContent|/Nasm::X86::Tree::setOrClearTreeBitToMatchContent> - Set or clear the tree bit pointed to by the specified register depending on the content of the specified variable.

205 L<Nasm::X86::Tree::setTreeBit|/Nasm::X86::Tree::setTreeBit> - Set the tree bit in the numbered zmm register holding the keys of a node to indicate that the data element indexed by the specified register is an offset to a sub tree in the containing area.

206 L<Nasm::X86::Tree::setTreeBits|/Nasm::X86::Tree::setTreeBits> - Put the tree bits in the specified register into the numbered zmm.

207 L<Nasm::X86::Tree::size|/Nasm::X86::Tree::size> - Return in a variable the number of elements currently in the tree.

208 L<Nasm::X86::Tree::sizeFromFirst|/Nasm::X86::Tree::sizeFromFirst> - Return a variable containing the number of keys in the specified tree when the first block is held in a zmm register.

209 L<Nasm::X86::Tree::sizeIntoFirst|/Nasm::X86::Tree::sizeIntoFirst> - Put the contents of a variable into the size field of the first block of a tree  when the first block is held in a zmm register.

210 L<Nasm::X86::Tree::splitNode|/Nasm::X86::Tree::splitNode> - Split a node if it it is full returning a variable that indicates whether a split occurred or not.

211 L<Nasm::X86::Tree::splitNotRoot|/Nasm::X86::Tree::splitNotRoot> - Split a non root left node pushing its excess right and up.

212 L<Nasm::X86::Tree::splitRoot|/Nasm::X86::Tree::splitRoot> - Split a non root node into left and right nodes with the left half left in the left node and splitting key/data pushed into the parent node with the remainder pushed into the new right node

213 L<Nasm::X86::Tree::stealFromLeft|/Nasm::X86::Tree::stealFromLeft> - Steal one key from the node on the left where the current left node,parent node and right node are held in zmm registers and return one if the steal was performed, else  zero.

214 L<Nasm::X86::Tree::stealFromRight|/Nasm::X86::Tree::stealFromRight> - Steal one key from the node on the right where the current left node,parent node and right node are held in zmm registers and return one if the steal was performed, else zero.

215 L<Nasm::X86::Tree::substring|/Nasm::X86::Tree::substring> - Create the substring of the specified string between the specified start and end keys.

216 L<Nasm::X86::Tree::upFromData|/Nasm::X86::Tree::upFromData> - Up from the data zmm in a block in a tree

217 L<Nasm::X86::Tree::upIntoData|/Nasm::X86::Tree::upIntoData> - Up into the data zmm in a block in a tree

218 L<Nasm::X86::Tree::yb|/Nasm::X86::Tree::yb> - Call the specified block with each element of the specified tree in descending order.

219 L<Nasm::X86::Variable::add|/Nasm::X86::Variable::add> - Add the right hand variable to the left hand variable and return the result as a new variable.

220 L<Nasm::X86::Variable::address|/Nasm::X86::Variable::address> - Get the address of a variable with an optional offset.

221 L<Nasm::X86::Variable::allocateMemory|/Nasm::X86::Variable::allocateMemory> - Allocate the specified amount of memory via mmap and return its address.

222 L<Nasm::X86::Variable::and|/Nasm::X86::Variable::and> - And two variables.

223 L<Nasm::X86::Variable::arithmetic|/Nasm::X86::Variable::arithmetic> - Return a variable containing the result of an arithmetic operation on the left hand and right hand side variables.

224 L<Nasm::X86::Variable::assign|/Nasm::X86::Variable::assign> - Assign to the left hand side the value of the right hand side.

225 L<Nasm::X86::Variable::bFromZ|/Nasm::X86::Variable::bFromZ> - Get the byte from the numbered zmm register and put it in a variable.

226 L<Nasm::X86::Variable::bIntoX|/Nasm::X86::Variable::bIntoX> - Place the value of the content variable at the byte in the numbered xmm register.

227 L<Nasm::X86::Variable::bIntoZ|/Nasm::X86::Variable::bIntoZ> - Place the value of the content variable at the byte in the numbered zmm register.

228 L<Nasm::X86::Variable::boolean|/Nasm::X86::Variable::boolean> - Combine the left hand variable with the right hand variable via a boolean operator.

229 L<Nasm::X86::Variable::booleanC|/Nasm::X86::Variable::booleanC> - Combine the left hand variable with the right hand variable via a boolean operator using a conditional move instruction.

230 L<Nasm::X86::Variable::booleanZF|/Nasm::X86::Variable::booleanZF> - Combine the left hand variable with the right hand variable via a boolean operator and indicate the result by setting the zero flag if the result is true.

231 L<Nasm::X86::Variable::call|/Nasm::X86::Variable::call> - Execute the call instruction for a target whose address is held in the specified variable.

232 L<Nasm::X86::Variable::clearBit|/Nasm::X86::Variable::clearBit> - Clear a bit in the specified mask register retaining the other bits.

233 L<Nasm::X86::Variable::clearMaskBit|/Nasm::X86::Variable::clearMaskBit> - Clear a bit in the specified mask register retaining the other bits.

234 L<Nasm::X86::Variable::clearMemory|/Nasm::X86::Variable::clearMemory> - Clear the memory described in this variable.

235 L<Nasm::X86::Variable::clone|/Nasm::X86::Variable::clone> - Clone a variable to make a new variable.

236 L<Nasm::X86::Variable::copy|/Nasm::X86::Variable::copy> - Copy one variable into another.

237 L<Nasm::X86::Variable::copyMemory|/Nasm::X86::Variable::copyMemory> - Copy from one block of memory to another.

238 L<Nasm::X86::Variable::copyRef|/Nasm::X86::Variable::copyRef> - Copy a reference to a variable.

239 L<Nasm::X86::Variable::copyZF|/Nasm::X86::Variable::copyZF> - Copy the current state of the zero flag into a variable.

240 L<Nasm::X86::Variable::copyZFInverted|/Nasm::X86::Variable::copyZFInverted> - Copy the opposite of the current state of the zero flag into a variable.

241 L<Nasm::X86::Variable::d|/Nasm::X86::Variable::d> - Dump the value of a variable on stderr and append a new line.

242 L<Nasm::X86::Variable::debug|/Nasm::X86::Variable::debug> - Dump the value of a variable on stdout with an indication of where the dump came from.

243 L<Nasm::X86::Variable::dec|/Nasm::X86::Variable::dec> - Decrement a variable.

244 L<Nasm::X86::Variable::dFromPointInZ|/Nasm::X86::Variable::dFromPointInZ> - Get the double word from the numbered zmm register at a point specified by the variable and return it in a variable.

245 L<Nasm::X86::Variable::dFromZ|/Nasm::X86::Variable::dFromZ> - Get the double word from the numbered zmm register and put it in a variable.

246 L<Nasm::X86::Variable::dIntoPointInZ|/Nasm::X86::Variable::dIntoPointInZ> - Put the variable double word content into the numbered zmm register at a point specified by the variable.

247 L<Nasm::X86::Variable::dIntoX|/Nasm::X86::Variable::dIntoX> - Place the value of the content variable at the double word in the numbered xmm register.

248 L<Nasm::X86::Variable::dIntoZ|/Nasm::X86::Variable::dIntoZ> - Place the value of the content variable at the double word in the numbered zmm register.

249 L<Nasm::X86::Variable::divide|/Nasm::X86::Variable::divide> - Divide the left hand variable by the right hand variable and return the result as a new variable.

250 L<Nasm::X86::Variable::division|/Nasm::X86::Variable::division> - Return a variable containing the result or the remainder that occurs when the left hand side is divided by the right hand side.

251 L<Nasm::X86::Variable::dump|/Nasm::X86::Variable::dump> - Dump the value of a variable to the specified channel adding an optional title and new line if requested.

252 L<Nasm::X86::Variable::eq|/Nasm::X86::Variable::eq> - Check whether the left hand variable is equal to the right hand variable.

253 L<Nasm::X86::Variable::equals|/Nasm::X86::Variable::equals> - Equals operator.

254 L<Nasm::X86::Variable::err|/Nasm::X86::Variable::err> - Dump the value of a variable on stderr.

255 L<Nasm::X86::Variable::errCString|/Nasm::X86::Variable::errCString> - Print a zero terminated C style string addressed by a variable on stderr.

256 L<Nasm::X86::Variable::errCStringNL|/Nasm::X86::Variable::errCStringNL> - Print a zero terminated C style string addressed by a variable on stderr followed by a new line.

257 L<Nasm::X86::Variable::errInDec|/Nasm::X86::Variable::errInDec> - Dump the value of a variable on stderr in decimal.

258 L<Nasm::X86::Variable::errInDecNL|/Nasm::X86::Variable::errInDecNL> - Dump the value of a variable on stderr in decimal followed by a new line.

259 L<Nasm::X86::Variable::errNL|/Nasm::X86::Variable::errNL> - Dump the value of a variable on stderr and append a new line.

260 L<Nasm::X86::Variable::errRightInBin|/Nasm::X86::Variable::errRightInBin> - Write the specified variable number in binary right justified in a field of specified width to stderr

261 L<Nasm::X86::Variable::errRightInBinNL|/Nasm::X86::Variable::errRightInBinNL> - Write the specified variable number in binary right justified in a field of specified width to stderr followed by a new line

262 L<Nasm::X86::Variable::errRightInDec|/Nasm::X86::Variable::errRightInDec> - Dump the value of a variable on stderr as a decimal number right adjusted in a field of specified width.

263 L<Nasm::X86::Variable::errRightInDecNL|/Nasm::X86::Variable::errRightInDecNL> - Dump the value of a variable on stderr as a decimal number right adjusted in a field of specified width followed by a new line.

264 L<Nasm::X86::Variable::errRightInHex|/Nasm::X86::Variable::errRightInHex> - Write the specified variable number in hexadecimal right justified in a field of specified width to stderr

265 L<Nasm::X86::Variable::errRightInHexNL|/Nasm::X86::Variable::errRightInHexNL> - Write the specified variable number in hexadecimal right justified in a field of specified width to stderr followed by a new line

266 L<Nasm::X86::Variable::errSpaces|/Nasm::X86::Variable::errSpaces> - Print the specified number of spaces to stderr.

267 L<Nasm::X86::Variable::for|/Nasm::X86::Variable::for> - Iterate a block a variable number of times.

268 L<Nasm::X86::Variable::freeMemory|/Nasm::X86::Variable::freeMemory> - Free the memory addressed by this variable for the specified length.

269 L<Nasm::X86::Variable::ge|/Nasm::X86::Variable::ge> - Check whether the left hand variable is greater than or equal to the right hand variable.

270 L<Nasm::X86::Variable::getConst|/Nasm::X86::Variable::getConst> - Load the variable from a constant in effect setting a variable to a specified value.

271 L<Nasm::X86::Variable::getReg|/Nasm::X86::Variable::getReg> - Load the variable from a register expression.

272 L<Nasm::X86::Variable::gt|/Nasm::X86::Variable::gt> - Check whether the left hand variable is greater than the right hand variable.

273 L<Nasm::X86::Variable::inc|/Nasm::X86::Variable::inc> - Increment a variable.

274 L<Nasm::X86::Variable::incDec|/Nasm::X86::Variable::incDec> - Increment or decrement a variable.

275 L<Nasm::X86::Variable::isRef|/Nasm::X86::Variable::isRef> - Check whether the specified  variable is a reference to another variable.

276 L<Nasm::X86::Variable::le|/Nasm::X86::Variable::le> - Check whether the left hand variable is less than or equal to the right hand variable.

277 L<Nasm::X86::Variable::loadZmm|/Nasm::X86::Variable::loadZmm> - Load bytes from the memory addressed by the specified source variable into the numbered zmm register.

278 L<Nasm::X86::Variable::lt|/Nasm::X86::Variable::lt> - Check whether the left hand variable is less than the right hand variable.

279 L<Nasm::X86::Variable::max|/Nasm::X86::Variable::max> - Maximum of two variables.

280 L<Nasm::X86::Variable::min|/Nasm::X86::Variable::min> - Minimum of two variables.

281 L<Nasm::X86::Variable::minusAssign|/Nasm::X86::Variable::minusAssign> - Implement minus and assign.

282 L<Nasm::X86::Variable::mod|/Nasm::X86::Variable::mod> - Divide the left hand variable by the right hand variable and return the remainder as a new variable.

283 L<Nasm::X86::Variable::ne|/Nasm::X86::Variable::ne> - Check whether the left hand variable is not equal to the right hand variable.

284 L<Nasm::X86::Variable::not|/Nasm::X86::Variable::not> - Form two complement of left hand side and return it as a variable.

285 L<Nasm::X86::Variable::or|/Nasm::X86::Variable::or> - Or two variables.

286 L<Nasm::X86::Variable::out|/Nasm::X86::Variable::out> - Dump the value of a variable on stdout.

287 L<Nasm::X86::Variable::outCString|/Nasm::X86::Variable::outCString> - Print a zero terminated C style string addressed by a variable on stdout.

288 L<Nasm::X86::Variable::outCStringNL|/Nasm::X86::Variable::outCStringNL> - Print a zero terminated C style string addressed by a variable on stdout followed by a new line.

289 L<Nasm::X86::Variable::outInDec|/Nasm::X86::Variable::outInDec> - Dump the value of a variable on stdout in decimal.

290 L<Nasm::X86::Variable::outInDecNL|/Nasm::X86::Variable::outInDecNL> - Dump the value of a variable on stdout in decimal followed by a new line.

291 L<Nasm::X86::Variable::outNL|/Nasm::X86::Variable::outNL> - Dump the value of a variable on stdout and append a new line.

292 L<Nasm::X86::Variable::outRightInBin|/Nasm::X86::Variable::outRightInBin> - Write the specified variable number in binary right justified in a field of specified width to stdout

293 L<Nasm::X86::Variable::outRightInBinNL|/Nasm::X86::Variable::outRightInBinNL> - Write the specified variable number in binary right justified in a field of specified width to stdout followed by a new line

294 L<Nasm::X86::Variable::outRightInDec|/Nasm::X86::Variable::outRightInDec> - Dump the value of a variable on stdout as a decimal number right adjusted in a field of specified width.

295 L<Nasm::X86::Variable::outRightInDecNL|/Nasm::X86::Variable::outRightInDecNL> - Dump the value of a variable on stdout as a decimal number right adjusted in a field of specified width followed by a new line.

296 L<Nasm::X86::Variable::outRightInHex|/Nasm::X86::Variable::outRightInHex> - Write the specified variable number in hexadecimal right justified in a field of specified width to stdout

297 L<Nasm::X86::Variable::outRightInHexNL|/Nasm::X86::Variable::outRightInHexNL> - Write the specified variable number in hexadecimal right justified in a field of specified width to stdout followed by a new line

298 L<Nasm::X86::Variable::outSpaces|/Nasm::X86::Variable::outSpaces> - Print the specified number of spaces to stdout.

299 L<Nasm::X86::Variable::plusAssign|/Nasm::X86::Variable::plusAssign> - Implement plus and assign.

300 L<Nasm::X86::Variable::printErrMemoryInHexNL|/Nasm::X86::Variable::printErrMemoryInHexNL> - Write the memory addressed by a variable to stderr.

301 L<Nasm::X86::Variable::printMemoryInHexNL|/Nasm::X86::Variable::printMemoryInHexNL> - Write, in hexadecimal, the memory addressed by a variable to stdout or stderr.

302 L<Nasm::X86::Variable::printOutMemoryInHexNL|/Nasm::X86::Variable::printOutMemoryInHexNL> - Write the memory addressed by a variable to stdout.

303 L<Nasm::X86::Variable::putBwdqIntoMm|/Nasm::X86::Variable::putBwdqIntoMm> - Place the value of the content variable at the byte|word|double word|quad word in the numbered zmm register.

304 L<Nasm::X86::Variable::putWIntoZmm|/Nasm::X86::Variable::putWIntoZmm> - Place the value of the content variable at the word in the numbered zmm register.

305 L<Nasm::X86::Variable::qFromZ|/Nasm::X86::Variable::qFromZ> - Get the quad word from the numbered zmm register and put it in a variable.

306 L<Nasm::X86::Variable::qIntoX|/Nasm::X86::Variable::qIntoX> - Place the value of the content variable at the quad word in the numbered xmm register.

307 L<Nasm::X86::Variable::qIntoZ|/Nasm::X86::Variable::qIntoZ> - Place the value of the content variable at the quad word in the numbered zmm register.

308 L<Nasm::X86::Variable::rightInBin|/Nasm::X86::Variable::rightInBin> - Write the specified variable number in binary right justified in a field of specified width to the specified channel.

309 L<Nasm::X86::Variable::rightInDec|/Nasm::X86::Variable::rightInDec> - Dump the value of a variable on the specified channel as a decimal  number right adjusted in a field of specified width.

310 L<Nasm::X86::Variable::rightInHex|/Nasm::X86::Variable::rightInHex> - Write the specified variable number in hexadecimal right justified in a field of specified width to the specified channel.

311 L<Nasm::X86::Variable::setBit|/Nasm::X86::Variable::setBit> - Set a bit in the specified register retaining the other bits.

312 L<Nasm::X86::Variable::setMask|/Nasm::X86::Variable::setMask> - Set the mask register to ones starting at the specified position for the specified length and zeroes elsewhere.

313 L<Nasm::X86::Variable::setMaskBit|/Nasm::X86::Variable::setMaskBit> - Set a bit in the specified mask register retaining the other bits.

314 L<Nasm::X86::Variable::setMaskFirst|/Nasm::X86::Variable::setMaskFirst> - Set the first bits in the specified mask register.

315 L<Nasm::X86::Variable::setReg|/Nasm::X86::Variable::setReg> - Set the named registers from the content of the variable.

316 L<Nasm::X86::Variable::setZmm|/Nasm::X86::Variable::setZmm> - Load bytes from the memory addressed by specified source variable into the numbered zmm register at the offset in the specified offset moving the number of bytes in the specified variable.

317 L<Nasm::X86::Variable::shiftLeft|/Nasm::X86::Variable::shiftLeft> - Shift the left hand variable left by the number of bits specified in the right hand variable and return the result as a new variable.

318 L<Nasm::X86::Variable::shiftRight|/Nasm::X86::Variable::shiftRight> - Shift the left hand variable right by the number of bits specified in the right hand variable and return the result as a new variable.

319 L<Nasm::X86::Variable::spaces|/Nasm::X86::Variable::spaces> - Print the specified number of spaces to the specified channel.

320 L<Nasm::X86::Variable::str|/Nasm::X86::Variable::str> - The name of the variable.

321 L<Nasm::X86::Variable::sub|/Nasm::X86::Variable::sub> - Subtract the right hand variable from the left hand variable and return the result as a new variable.

322 L<Nasm::X86::Variable::times|/Nasm::X86::Variable::times> - Multiply the left hand variable by the right hand variable and return the result as a new variable.

323 L<Nasm::X86::Variable::wFromZ|/Nasm::X86::Variable::wFromZ> - Get the word from the numbered zmm register and put it in a variable.

324 L<Nasm::X86::Variable::wIntoX|/Nasm::X86::Variable::wIntoX> - Place the value of the content variable at the word in the numbered xmm register.

325 L<NasmX86::Library::load|/NasmX86::Library::load> - Load a library and return the addresses of its subroutines as variables.

326 L<OnSegv|/OnSegv> - Request a trace back followed by exit on a B<segv> signal.

327 L<OpenRead|/OpenRead> - Open a file, whose name is addressed by rax, for read and return the file descriptor in rax.

328 L<OpenWrite|/OpenWrite> - Create the file named by the terminated string addressed by rax for write.

329 L<Optimize|/Optimize> - Perform code optimizations.

330 L<OrBlock|/OrBlock> - Short circuit B<or>: execute a block of code to test conditions which, if one of them is met, leads on to the execution of the pass block, if all of the tests fail we continue withe the test block.

331 L<Pass|/Pass> - Pass block for an L<OrBlock>.

332 L<PopR|/PopR> - Pop registers from the stack.

333 L<PopRR|/PopRR> - Pop registers from the stack without tracking.

334 L<PrintCString|/PrintCString> - Print a zero terminated C style string addressed by a variable on the specified channel.

335 L<PrintCStringNL|/PrintCStringNL> - Print a zero terminated C style string addressed by a variable on the specified channel followed by a new line.

336 L<PrintErrMemory|/PrintErrMemory> - Print the memory addressed by rax for a length of rdi on stderr.

337 L<PrintErrMemory_InHex|/PrintErrMemory_InHex> - Dump memory from the address in rax for the length in rdi on stderr.

338 L<PrintErrMemory_InHexNL|/PrintErrMemory_InHexNL> - Dump memory from the address in rax for the length in rdi and then print a new line.

339 L<PrintErrMemoryInHex|/PrintErrMemoryInHex> - Dump memory from the address in rax for the length in rdi on stderr.

340 L<PrintErrMemoryInHexNL|/PrintErrMemoryInHexNL> - Dump memory from the address in rax for the length in rdi and then print a new line.

341 L<PrintErrMemoryNL|/PrintErrMemoryNL> - Print the memory addressed by rax for a length of rdi followed by a new line on stderr.

342 L<PrintErrNL|/PrintErrNL> - Print a new line to stderr.

343 L<PrintErrOneRegisterInHex|/PrintErrOneRegisterInHex> - Print the named register as a hex string on stderr.

344 L<PrintErrOneRegisterInHexNL|/PrintErrOneRegisterInHexNL> - Print the named register as a hex string on stderr followed by new line.

345 L<PrintErrRax_InHex|/PrintErrRax_InHex> - Write the content of register rax in hexadecimal in big endian notation to stderr.

346 L<PrintErrRax_InHexNL|/PrintErrRax_InHexNL> - Write the content of register rax in hexadecimal in big endian notation to stderr followed by a new line.

347 L<PrintErrRaxAsChar|/PrintErrRaxAsChar> - Print the character in on stderr.

348 L<PrintErrRaxAsCharNL|/PrintErrRaxAsCharNL> - Print the character in on stderr followed by a new line.

349 L<PrintErrRaxAsText|/PrintErrRaxAsText> - Print rax as text on stderr.

350 L<PrintErrRaxAsTextNL|/PrintErrRaxAsTextNL> - Print rax as text on stderr followed by a new line.

351 L<PrintErrRaxInDec|/PrintErrRaxInDec> - Print rax in decimal on stderr.

352 L<PrintErrRaxInDecNL|/PrintErrRaxInDecNL> - Print rax in decimal on stderr followed by a new line.

353 L<PrintErrRaxInHex|/PrintErrRaxInHex> - Write the content of register rax in hexadecimal in big endian notation to stderr.

354 L<PrintErrRaxInHexNL|/PrintErrRaxInHexNL> - Write the content of register rax in hexadecimal in big endian notation to stderr followed by a new line.

355 L<PrintErrRaxRightInDec|/PrintErrRaxRightInDec> - Print rax in decimal right justified in a field of the specified width on stderr.

356 L<PrintErrRaxRightInDecNL|/PrintErrRaxRightInDecNL> - Print rax in decimal right justified in a field of the specified width on stderr followed by a new line.

357 L<PrintErrRegisterInHex|/PrintErrRegisterInHex> - Print the named registers as hex strings on stderr.

358 L<PrintErrRightInBin|/PrintErrRightInBin> - Write the specified variable in binary right justified in a field of specified width on stderr.

359 L<PrintErrRightInBinNL|/PrintErrRightInBinNL> - Write the specified variable in binary right justified in a field of specified width on stderr followed by a new line.

360 L<PrintErrRightInHex|/PrintErrRightInHex> - Write the specified variable in hexadecimal right justified in a field of specified width on stderr.

361 L<PrintErrRightInHexNL|/PrintErrRightInHexNL> - Write the specified variable in hexadecimal right justified in a field of specified width on stderr followed by a new line.

362 L<PrintErrSpace|/PrintErrSpace> - Print  a constant number of spaces to stderr.

363 L<PrintErrString|/PrintErrString> - Print a constant string to stderr.

364 L<PrintErrStringNL|/PrintErrStringNL> - Print a constant string to stderr followed by a new line.

365 L<PrintErrTraceBack|/PrintErrTraceBack> - Print sub routine track back on stderr and then exit with a message.

366 L<PrintErrZF|/PrintErrZF> - Print the zero flag without disturbing it on stderr.

367 L<PrintMemory|/PrintMemory> - Print the memory addressed by rax for a length of rdi on the specified channel.

368 L<PrintMemory_InHex|/PrintMemory_InHex> - Dump memory from the address in rax for the length in rdi on the specified channel.

369 L<PrintMemoryInHex|/PrintMemoryInHex> - Dump memory from the address in rax for the length in rdi on the specified channel.

370 L<PrintMemoryNL|/PrintMemoryNL> - Print the memory addressed by rax for a length of rdi on the specified channel followed by a new line.

371 L<PrintNL|/PrintNL> - Print a new line to stdout  or stderr.

372 L<PrintOneRegisterInHex|/PrintOneRegisterInHex> - Print the named register as a hex string.

373 L<PrintOutMemory|/PrintOutMemory> - Print the memory addressed by rax for a length of rdi on stdout.

374 L<PrintOutMemory_InHex|/PrintOutMemory_InHex> - Dump memory from the address in rax for the length in rdi on stdout.

375 L<PrintOutMemory_InHexNL|/PrintOutMemory_InHexNL> - Dump memory from the address in rax for the length in rdi and then print a new line.

376 L<PrintOutMemoryInHex|/PrintOutMemoryInHex> - Dump memory from the address in rax for the length in rdi on stdout.

377 L<PrintOutMemoryInHexNL|/PrintOutMemoryInHexNL> - Dump memory from the address in rax for the length in rdi and then print a new line.

378 L<PrintOutMemoryNL|/PrintOutMemoryNL> - Print the memory addressed by rax for a length of rdi followed by a new line on stdout.

379 L<PrintOutNL|/PrintOutNL> - Print a new line to stderr.

380 L<PrintOutOneRegisterInHex|/PrintOutOneRegisterInHex> - Print the named register as a hex string on stdout.

381 L<PrintOutOneRegisterInHexNL|/PrintOutOneRegisterInHexNL> - Print the named register as a hex string on stdout followed by new line.

382 L<PrintOutRax_InHex|/PrintOutRax_InHex> - Write the content of register rax in hexadecimal in big endian notation to stout.

383 L<PrintOutRax_InHexNL|/PrintOutRax_InHexNL> - Write the content of register rax in hexadecimal in big endian notation to stdout followed by a new line.

384 L<PrintOutRaxAsChar|/PrintOutRaxAsChar> - Print the character in on stdout.

385 L<PrintOutRaxAsCharNL|/PrintOutRaxAsCharNL> - Print the character in on stdout followed by a new line.

386 L<PrintOutRaxAsText|/PrintOutRaxAsText> - Print rax as text on stdout.

387 L<PrintOutRaxAsTextNL|/PrintOutRaxAsTextNL> - Print rax as text on stdout followed by a new line.

388 L<PrintOutRaxInDec|/PrintOutRaxInDec> - Print rax in decimal on stdout.

389 L<PrintOutRaxInDecNL|/PrintOutRaxInDecNL> - Print rax in decimal on stdout followed by a new line.

390 L<PrintOutRaxInHex|/PrintOutRaxInHex> - Write the content of register rax in hexadecimal in big endian notation to stout.

391 L<PrintOutRaxInHexNL|/PrintOutRaxInHexNL> - Write the content of register rax in hexadecimal in big endian notation to stdout followed by a new line.

392 L<PrintOutRaxInReverseInHex|/PrintOutRaxInReverseInHex> - Write the content of register rax to stderr in hexadecimal in little endian notation.

393 L<PrintOutRaxRightInDec|/PrintOutRaxRightInDec> - Print rax in decimal right justified in a field of the specified width on stdout.

394 L<PrintOutRaxRightInDecNL|/PrintOutRaxRightInDecNL> - Print rax in decimal right justified in a field of the specified width on stdout followed by a new line.

395 L<PrintOutRegisterInHex|/PrintOutRegisterInHex> - Print the named registers as hex strings on stdout.

396 L<PrintOutRegistersInHex|/PrintOutRegistersInHex> - Print the general purpose registers in hex.

397 L<PrintOutRflagsInHex|/PrintOutRflagsInHex> - Print the flags register in hex.

398 L<PrintOutRightInBin|/PrintOutRightInBin> - Write the specified variable in binary right justified in a field of specified width on stdout.

399 L<PrintOutRightInBinNL|/PrintOutRightInBinNL> - Write the specified variable in binary right justified in a field of specified width on stdout followed by a new line.

400 L<PrintOutRightInHex|/PrintOutRightInHex> - Write the specified variable in hexadecimal right justified in a field of specified width on stdout.

401 L<PrintOutRightInHexNL|/PrintOutRightInHexNL> - Write the specified variable in hexadecimal right justified in a field of specified width on stdout followed by a new line.

402 L<PrintOutRipInHex|/PrintOutRipInHex> - Print the instruction pointer in hex.

403 L<PrintOutSpace|/PrintOutSpace> - Print a constant number of spaces to stdout.

404 L<PrintOutString|/PrintOutString> - Print a constant string to stdout.

405 L<PrintOutStringNL|/PrintOutStringNL> - Print a constant string to stdout followed by a new line.

406 L<PrintOutTraceBack|/PrintOutTraceBack> - Print sub routine track back on stdout and then exit with a message.

407 L<PrintOutZF|/PrintOutZF> - Print the zero flag without disturbing it on stdout.

408 L<PrintRax_InHex|/PrintRax_InHex> - Write the content of register rax in hexadecimal in big endian notation to the specified channel replacing zero bytes with __.

409 L<PrintRaxAsChar|/PrintRaxAsChar> - Print the ascii character in rax on the specified channel.

410 L<PrintRaxAsText|/PrintRaxAsText> - Print the string in rax on the specified channel.

411 L<PrintRaxInDec|/PrintRaxInDec> - Print rax in decimal on the specified channel.

412 L<PrintRaxInHex|/PrintRaxInHex> - Write the content of register rax in hexadecimal in big endian notation to the specified channel.

413 L<PrintRaxRightInDec|/PrintRaxRightInDec> - Print rax in decimal right justified in a field of the specified width on the specified channel.

414 L<PrintRegisterInHex|/PrintRegisterInHex> - Print the named registers as hex strings.

415 L<PrintRightInBin|/PrintRightInBin> - Print out a number in hex right justified in a field of specified width on the specified channel

416 L<PrintRightInHex|/PrintRightInHex> - Print out a number in hex right justified in a field of specified width on the specified channel

417 L<PrintSpace|/PrintSpace> - Print a constant number of spaces to the specified channel.

418 L<PrintString|/PrintString> - Print a constant string to the specified channel.

419 L<PrintStringNL|/PrintStringNL> - Print a constant string to the specified channel followed by a new line.

420 L<PrintTraceBack|/PrintTraceBack> - Trace the call stack.

421 L<PushR|/PushR> - Push registers onto the stack.

422 L<PushRR|/PushRR> - Push registers onto the stack without tracking.

423 L<qFromX|/qFromX> - Get the quad word from the numbered xmm register and return it in a variable.

424 L<qFromZ|/qFromZ> - Get the quad word from the numbered zmm register and return it in a variable.

425 L<R|/R> - Define a reference variable.

426 L<Rb|/Rb> - Layout bytes in the data segment and return their label.

427 L<Rbwdq|/Rbwdq> - Layout data.

428 L<RComment|/RComment> - Insert a comment into the read only data segment.

429 L<Rd|/Rd> - Layout double words in the data segment and return their label.

430 L<ReadChar|/ReadChar> - Read a character from stdin and return it in rax else return -1 in rax if no character was read.

431 L<ReadFile|/ReadFile> - Read a file into memory.

432 L<ReadInteger|/ReadInteger> - Reads an integer in decimal and returns it in rax.

433 L<ReadLine|/ReadLine> - Reads up to 8 characters followed by a terminating return and place them into rax.

434 L<ReadTimeStampCounter|/ReadTimeStampCounter> - Read the time stamp counter and return the time in nanoseconds in rax.

435 L<registerNameFromNumber|/registerNameFromNumber> - Register name from number where possible

436 L<RegisterSize|/RegisterSize> - Return the size of a register.

437 L<removeNonAsciiChars|/removeNonAsciiChars> - Return a copy of the specified string with all the non ascii characters removed.

438 L<RestoreFirstFour|/RestoreFirstFour> - Restore the first 4 parameter registers.

439 L<RestoreFirstFourExceptRax|/RestoreFirstFourExceptRax> - Restore the first 4 parameter registers except rax so it can return its value.

440 L<RestoreFirstFourExceptRaxAndRdi|/RestoreFirstFourExceptRaxAndRdi> - Restore the first 4 parameter registers except rax  and rdi so we can return a pair of values.

441 L<RestoreFirstSeven|/RestoreFirstSeven> - Restore the first 7 parameter registers.

442 L<RestoreFirstSevenExceptRax|/RestoreFirstSevenExceptRax> - Restore the first 7 parameter registers except rax which is being used to return the result.

443 L<RestoreFirstSevenExceptRaxAndRdi|/RestoreFirstSevenExceptRaxAndRdi> - Restore the first 7 parameter registers except rax and rdi which are being used to return the results.

444 L<Rq|/Rq> - Layout quad words in the data segment and return their label.

445 L<Rs|/Rs> - Layout bytes in read only memory and return their label.

446 L<Rutf8|/Rutf8> - Layout a utf8 encoded string as bytes in read only memory and return their label.

447 L<Rw|/Rw> - Layout words in the data segment and return their label.

448 L<SaveFirstFour|/SaveFirstFour> - Save the first 4 parameter registers making any parameter registers read only.

449 L<SaveFirstSeven|/SaveFirstSeven> - Save the first 7 parameter registers.

450 L<SaveRegIntoMm|/SaveRegIntoMm> - Save the specified register into the numbered zmm at the quad offset specified as a constant number.

451 L<SetLabel|/SetLabel> - Create (if necessary) and set a label in the code section returning the label so set.

452 L<SetMaskRegister|/SetMaskRegister> - Set the mask register to ones starting at the specified position for the specified length and zeroes elsewhere.

453 L<SetZF|/SetZF> - Set the zero flag.

454 L<Start|/Start> - Initialize the assembler.

455 L<StatSize|/StatSize> - Stat a file whose name is addressed by rax to get its size in rax.

456 L<StringLength|/StringLength> - Length of a zero terminated string.

457 L<Subroutine|/Subroutine> - Create a subroutine that can be called in assembler code.

458 L<SubroutineStartStack|/SubroutineStartStack> - Initialize a new stack frame.

459 L<Then|/Then> - Then block for an If statement.

460 L<totalBytesAssembled|/totalBytesAssembled> - Total size in bytes of all files assembled during testing.

461 L<unlinkFile|/unlinkFile> - Unlink the named file.

462 L<V|/V> - Define a variable.

463 L<Variable|/Variable> - Create a new variable with the specified name initialized via an optional expression.

464 L<WaitPid|/WaitPid> - Wait for the pid in rax to complete.

465 L<wFromX|/wFromX> - Get the word from the numbered xmm register and return it in a variable.

466 L<wFromZ|/wFromZ> - Get the word from the numbered zmm register and return it in a variable.

467 L<wRegFromZmm|/wRegFromZmm> - Load the specified register from the word at the specified offset located in the numbered zmm.

468 L<wRegIntoZmm|/wRegIntoZmm> - Put the specified register into the word in the numbered zmm at the specified offset in the zmm.

469 L<xmm|/xmm> - Add xmm to the front of a list of register expressions.

470 L<ymm|/ymm> - Add ymm to the front of a list of register expressions.

471 L<zmm|/zmm> - Add zmm to the front of a list of register expressions.

472 L<zmmM|/zmmM> - Add zmm to the front of a register number and a mask after it

473 L<zmmMZ|/zmmMZ> - Add zmm to the front of a register number and mask and zero after it

=head1 Installation

This module is written in 100% Pure Perl and, thus, it is easy to read,
comprehend, use, modify and install via B<cpan>:

  sudo cpan install Nasm::X86

=head1 Author

L<philiprbrenan@gmail.com|mailto:philiprbrenan@gmail.com>

L<http://www.appaapps.com|http://www.appaapps.com>

=head1 Copyright

Copyright (c) 2016-2021 Philip R Brenan.

This module is free software. It may be used, redistributed and/or modified
under the same terms as Perl itself.

=cut

# Tests and documentation

sub test
 {my $p = __PACKAGE__;
  binmode($_, ":utf8") for *STDOUT, *STDERR;
  return if eval "eof(${p}::DATA)";
  my $s = eval "join('', <${p}::DATA>)";
  $@ and die $@;
  eval $s;
  $@ and die $@;
  1
 }

test unless caller;

1;
# podDocumentation
#__DATA__
use Time::HiRes qw(time);
use Test::Most;

bail_on_fail unless $ENV{GITHUB_REPOSITORY_OWNER};

my $localTest = ((caller(1))[0]//'Nasm::X86') eq "Nasm::X86";                   # Local testing mode
my $homeTest  = -e q(/home/phil/);                                              # Testing on a local machine

Test::More->builder->output("/dev/null") if $localTest;                         # Reduce number of confirmation messages during testing

if ($^O =~ m(bsd|linux|cygwin)i)                                                # Supported systems
 {if (confirmHasCommandLineCommand(q(nasm)) and LocateIntelEmulator){}          # Network assembler and Intel Software Development emulator
  else
   {plan skip_all => qq(Nasm or Intel 64 emulator not available);
   }
 }
else
 {plan skip_all => qq(Not supported on: $^O);
 }

my $start = time;                                                               # Tests

eval {goto latest} if !caller(0) and -e "/home/phil";                           # Go to latest test if specified

#latest:
if (1) {                                                                        #TPrintOutStringNL #TPrintErrStringNL #TAssemble
  PrintOutStringNL "Hello World";
  PrintOutStringNL "Hello\nWorld";
  PrintErrStringNL "Hello World";

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
Hello World
Hello
World
END
 }

#latest:
if (1) {                                                                        #TPrintOutRaxInHexNL
  my $s = Rb(0..255);

  Vmovdqu64 xmm1, "[$s]";
  PrintOutRegisterInHex xmm1;
  PrintOutRegisterInHex xmm1;

  Vmovdqu64 ymm1, "[$s]";
  PrintOutRegisterInHex ymm1;
  PrintOutRegisterInHex ymm1;

  Vmovdqu64 zmm1, "[$s]";
  PrintOutRegisterInHex zmm1;
  PrintOutRegisterInHex zmm1;

  ok Assemble avx512=>1, debug=>0, eq =><<END;
  xmm1: .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  xmm1: .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  ymm1: 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  ymm1: 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  zmm1: 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130 - 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120 + 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  zmm1: 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130 - 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120 + 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
END
 }

#latest:;
if (1) {                                                                        #TMov #TComment #TRs #TPrintOutMemory #TExit
  Comment "Print a string from memory";
  my $s = "Hello World";
  Mov rax, Rs($s);
  Mov rdi, length $s;
  PrintOutMemory;
  Exit(0);

  ok Assemble(avx512=>0) =~ m(Hello World);
 }

#latest:;
if (1) {                                                                        #TPrintOutMemoryNL #TStringLength
  my $s = Rs("Hello World\n\nHello Skye");
  my $l = StringLength(my $t = V string => $s);
  $t->setReg(rax);
  $l->setReg(rdi);
  PrintOutMemoryNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
Hello World

Hello Skye
END
 }

#latest:;
if (1) {                                                                        #TPrintOutRaxInHex #TPrintOutNL #TPrintOutString
  my $q = Rs('abababab');
  Mov(rax, "[$q]");
  PrintOutString "rax: ";
  PrintOutRaxInHex;
  PrintOutNL;
  Xor rax, rax;
  PrintOutString "rax: ";
  PrintOutRaxInHex;
  PrintOutNL;

  ok Assemble(avx512=>0, eq=><<END)
rax: 6261 6261 6261 6261
rax: .... .... .... ....
END
 }

#latest:;
if (1) {                                                                        #TPrintOutRegistersInHex #TRs
  my $q = Rs('abababab');
  Mov r10, 0x10;
  Mov r11, 0x11;
  Mov r12, 0x12;
  Mov r13, 0x13;
  Mov r14, 0x14;
  Mov r15, 0x15;
  Mov  r8, 0x08;
  Mov  r9, 0x09;
  Mov rax, 1;
  Mov rbx, 2;
  Mov rcx, 3;
  Mov rdi, 4;
  Mov rdx, 5;
  Mov rsi, 6;
  PrintOutRegistersInHex;

  my $r = Assemble(avx512=>0, eq=><<END, debug=>0);
rfl: .... .... .... .2.2
r10: .... .... .... ..10
r11: .... .... .... .2.2
r12: .... .... .... ..12
r13: .... .... .... ..13
r14: .... .... .... ..14
r15: .... .... .... ..15
 r8: .... .... .... ...8
 r9: .... .... .... ...9
rax: .... .... .... ...1
rbx: .... .... .... ...2
rcx: .... .... ..40 18E1
rdi: .... .... .... ...4
rdx: .... .... .... ...5
rsi: .... .... .... ...6
END
 }

#latest:;
if (1) {                                                                        #TDs TRs
  my $q = Rs('a'..'z');
  Mov rax, Ds('0'x64);                                                          # Output area
  Vmovdqu32(xmm0, "[$q]");                                                      # Load
  Vprolq   (xmm0,   xmm0, 32);                                                  # Rotate double words in quad words
  Vmovdqu32("[rax]", xmm0);                                                     # Save
  Mov rdi, 16;
  PrintOutMemoryNL;

  ok Assemble(avx512=>1, eq=><<END)
efghabcdmnopijkl
END
 }

#latest:;
if (1) {
  my $q = Rs(('a'..'p')x2);
  Mov rax, Ds('0'x64);
  Vmovdqu32(ymm0, "[$q]");
  Vprolq   (ymm0,   ymm0, 32);
  Vmovdqu32("[rax]", ymm0);
  Mov rdi, 32;
  PrintOutMemoryNL;

  ok Assemble(avx512=>1, eq=><<END)
efghabcdmnopijklefghabcdmnopijkl
END
 }

#latest:;
if (1) {
  my $q = Rs my $s = join '', ('a'..'p')x4;                                     # Sample string
  Mov rax, Ds('0'x128);

  Vmovdqu64 zmm0, "[$q]";                                                       # Load zmm0 with sample string
  Vprolq    zmm1, zmm0, 32;                                                     # Rotate left 32 bits in lanes
  Vmovdqu64 "[rax]", zmm1;                                                      # Save results

  Mov rdi, length $s;                                                           # Print results
  PrintOutMemoryNL;

  is_deeply "$s\n", <<END;                                                      # Initial string
abcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnop
END

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
efghabcdmnopijklefghabcdmnopijklefghabcdmnopijklefghabcdmnopijkl
END
 }

#latest:
if (1) {
  my $q = Rb(0..255);
  Vmovdqu8 xmm0, "[$q]";
  Vmovdqu8 xmm1, "[$q+16]";
  Vmovdqu8 xmm2, "[$q+32]";
  Vmovdqu8 xmm3, "[$q+48]";
  PrintOutRegisterInHex xmm0, xmm1,  xmm2, xmm3;

  Vmovdqu8 ymm0, "[$q]";
  Vmovdqu8 ymm1, "[$q+16]";
  Vmovdqu8 ymm2, "[$q+32]";
  Vmovdqu8 ymm3, "[$q+48]";
  PrintOutRegisterInHex ymm0, ymm1, ymm2, ymm3;

  Vmovdqu8 zmm0, "[$q]";
  Vmovdqu8 zmm1, "[$q+16]";
  Vmovdqu8 zmm2, "[$q+32]";
  Vmovdqu8 zmm3, "[$q+48]";
  PrintOutRegisterInHex zmm0, zmm1, zmm2, zmm3;

  ok Assemble(avx512=>1, eq=><<END);
  xmm0: .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  xmm1: 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110
  xmm2: 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120
  xmm3: 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130
  ymm0: 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  ymm1: 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120 - 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110
  ymm2: 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130 - 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120
  ymm3: 4F4E 4D4C 4B4A 4948  4746 4544 4342 4140 - 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130
  zmm0: 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130 - 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120 + 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  zmm1: 4F4E 4D4C 4B4A 4948  4746 4544 4342 4140 - 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130 + 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120 - 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110
  zmm2: 5F5E 5D5C 5B5A 5958  5756 5554 5352 5150 - 4F4E 4D4C 4B4A 4948  4746 4544 4342 4140 + 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130 - 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120
  zmm3: 6F6E 6D6C 6B6A 6968  6766 6564 6362 6160 - 5F5E 5D5C 5B5A 5958  5756 5554 5352 5150 + 4F4E 4D4C 4B4A 4948  4746 4544 4342 4140 - 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Variable::copyZF #TNasm::X86::Variable::copyZFInverted
  Mov r15, 1;
  my $z = V(zf => undef);
  Cmp r15, 1; $z->copyZF;         $z->outNL;
  Cmp r15, 2; $z->copyZF;         $z->outNL;
  Cmp r15, 1; $z->copyZFInverted; $z->outNL;
  Cmp r15, 2; $z->copyZFInverted; $z->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
zf: .... .... .... ...1
zf: .... .... .... ....
zf: .... .... .... ....
zf: .... .... .... ...1
END
 }

#latest:
if (1) {                                                                        #TPrintOutRightInHexNL
  my $N = K number => 0x12345678;

  for my $i(reverse 1..16)
   {PrintOutRightInHexNL($N, K width => $i);
   }
  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>1);
        12345678
       12345678
      12345678
     12345678
    12345678
   12345678
  12345678
 12345678
12345678
2345678
345678
45678
5678
678
78
8
END
 }

#latest:
if (1) {                                                                        #TPrintOutRightInBinNL
  K(count => 64)->for(sub
   {my ($index, $start, $next, $end) = @_;
    PrintOutRightInBinNL K(number => 0x99), K(max => 64) - $index;
   });
  ok Assemble(debug => 0, eq => <<END, avx512=>0);
                                                        10011001
                                                       10011001
                                                      10011001
                                                     10011001
                                                    10011001
                                                   10011001
                                                  10011001
                                                 10011001
                                                10011001
                                               10011001
                                              10011001
                                             10011001
                                            10011001
                                           10011001
                                          10011001
                                         10011001
                                        10011001
                                       10011001
                                      10011001
                                     10011001
                                    10011001
                                   10011001
                                  10011001
                                 10011001
                                10011001
                               10011001
                              10011001
                             10011001
                            10011001
                           10011001
                          10011001
                         10011001
                        10011001
                       10011001
                      10011001
                     10011001
                    10011001
                   10011001
                  10011001
                 10011001
                10011001
               10011001
              10011001
             10011001
            10011001
           10011001
          10011001
         10011001
        10011001
       10011001
      10011001
     10011001
    10011001
   10011001
  10011001
 10011001
10011001
0011001
011001
11001
1001
001
01
1
END
 }

#latest:
if (1) {                                                                        #TAllocateMemory #TFreeMemory
  my $N = K size => 2048;
  my $q = Rs('a'..'p');
  my $address = AllocateMemory $N;

  Vmovdqu8 xmm0, "[$q]";
  $address->setReg(rax);
  Vmovdqu8 "[rax]", xmm0;
  Mov rdi, 16;
  PrintOutMemory;
  PrintOutNL;

  FreeMemory $address, $N;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
abcdefghijklmnop
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Variable::allocateMemory #TNasm::X86::Variable::freeMemory
  my $N = K size => 2048;
  my $q = Rs('a'..'p');
  my $address = $N->allocateMemory;

  Vmovdqu8 xmm0, "[$q]";
  $address->setReg(rax);
  Vmovdqu8 "[rax]", xmm0;
  Mov rdi, 16;
  PrintOutMemory;
  PrintOutNL;

  $address->freeMemory($N);

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
abcdefghijklmnop
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Variable::outNL
  my $a = V a => 0x1111;
  $a->outNL('');
  $a->outRightInBinNL(K width => 16);
  $a->outRightInDecNL(K width => 16);
  $a->outRightInHexNL(K width => 16);
  ok Assemble(debug => 0, eq => <<END, avx512=>1);
.... .... .... 1111
   1000100010001
            4369
            1111
END
 }

#latest:
if (1) {                                                                        #TReadTimeStampCounter
  for(1..10)
   {ReadTimeStampCounter;
    PrintOutRegisterInHex rax;
   }

  my @s = split /\n/, Assemble(avx512=>0);
  my @S = sort @s;
  is_deeply \@s, \@S;
 }

#latest:
if (1) {                                                                        #TIf
  my $c = K(one => 1);
  If ($c == 0,
  Then
   {PrintOutStringNL "1 == 0";
   },
  Else
   {PrintOutStringNL "1 != 0";
   });

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
1 != 0
END
 }

if (1) {                                                                        #TIfNz
  Mov rax, 0;
  Test rax,rax;
  IfNz
  Then
   {PrintOutRegisterInHex rax;
   },
  Else
   {PrintOutRegisterInHex rbx;
   };
  Mov rax, 1;
  Test rax,rax;
  IfNz
  Then
   {PrintOutRegisterInHex rcx;
   },
  Else
   {PrintOutRegisterInHex rdx;
   };

  ok Assemble(avx512=>0) =~ m(rbx.*rcx)s;
 }

if (1) {                                                                        #TFork #TGetPid #TGetPPid #TWaitPid
  Fork;                                                                         # Fork

  Test rax,rax;
  IfNz                                                                          # Parent
  Then
   {Mov rbx, rax;
    WaitPid;
    GetPid;                                                                     # Pid of parent as seen in parent
    Mov rcx,rax;
    PrintOutRegisterInHex rax, rbx, rcx;
   },
  Else                                                                          # Child
   {Mov r8,rax;
    GetPid;                                                                     # Child pid as seen in child
    Mov r9,rax;
    GetPPid;                                                                    # Parent pid as seen in child
    Mov r10,rax;
    PrintOutRegisterInHex r8, r9, r10;
   };

  my $r = Assemble(avx512=>0);

#    r8: 0000 0000 0000 0000   #1 Return from fork as seen by child
#    r9: 0000 0000 0003 0C63   #2 Pid of child
#   r10: 0000 0000 0003 0C60   #3 Pid of parent from child
#   rax: 0000 0000 0003 0C63   #4 Return from fork as seen by parent
#   rbx: 0000 0000 0003 0C63   #5 Wait for child pid result
#   rcx: 0000 0000 0003 0C60   #6 Pid of parent

  if ($r =~ m(r8:( 0000){4}.*r9:(.*)\s{5,}r10:(.*)\s{5,}rax:(.*)\s{5,}rbx:(.*)\s{5,}rcx:(.*)\s{2,})s)
   {ok $2 eq $4;
    ok $2 eq $5;
    ok $3 eq $6;
    ok $2 gt $6;
   }
 }

if ($homeTest) {                                                                #TGetUid
  GetUid;                                                                       # Userid
  PrintOutRegisterInHex rax;

  my $r = Assemble(avx512=>0);
  ok $r =~ m(3E8);
 }

if (1) {                                                                        #TStatSize
  Mov rax, Rs($0);                                                              # File to stat
  StatSize;                                                                     # Stat the file
  PrintOutRegisterInHex rax;

  my $r = Assemble(avx512=>0) =~ s( ) ()gsr;
  if ($r =~ m(rax:([0-9a-f]{16}))is)                                            # Compare file size obtained with that from fileSize()
   {is_deeply $1, sprintf("%016X", fileSize($0));
   }
 }

if (1) {                                                                        #TOpenRead #TCloseFile #TOpenWrite
  Mov rax, Rs($0);                                                              # File to read
  OpenRead;                                                                     # Open file
  PrintOutRegisterInHex rax;
  CloseFile;                                                                    # Close file
  PrintOutRegisterInHex rax;

  Mov rax, Rs(my $f = "zzzTemporaryFile.txt");                                  # File to write
  OpenWrite;                                                                    # Open file
  CloseFile;                                                                    # Close file

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
   rax: .... .... .... ...3
   rax: .... .... .... ....
END
  ok -e $f;                                                                     # Created file
  unlink $f;
 }

if (1) {                                                                        #TFor
  For
   {my ($start, $end, $next) = @_;
    Cmp rax, 3;
    Jge $end;
    PrintOutRegisterInHex rax;
   } rax, 16, 1;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
   rax: .... .... .... ....
   rax: .... .... .... ...1
   rax: .... .... .... ...2
END
 }

if (1) {                                                                        #TAndBlock #TFail
  Mov rax, 1; Mov rdx, 2;
  AndBlock
   {my ($fail, $end, $start) = @_;
    Cmp rax, 1;
    Jne $fail;
    Cmp rdx, 2;
    Jne $fail;
    PrintOutStringNL "Pass";
   }
  Fail
   {my ($end, $fail, $start) = @_;
    PrintOutStringNL "Fail";
   };

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
Pass
END
 }

if (1) {                                                                        #TOrBlock #TPass
  Mov rax, 1;
  OrBlock
   {my ($pass, $end, $start) = @_;
    Cmp rax, 1;
    Je  $pass;
    Cmp rax, 2;
    Je  $pass;
    PrintOutStringNL "Fail";
   }
  Pass
   {my ($end, $pass, $start) = @_;
    PrintOutStringNL "Pass";
   };

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
Pass
END
 }

if (1) {                                                                        #TPrintOutRaxInReverseInHex #TPrintOutMemoryInHex
  Mov rax, 0x07654321;
  Shl rax, 32;
  Or  rax, 0x07654321;
  PushR rax;

  PrintOutRaxInHex;
  PrintOutNL;
  PrintOutRaxInReverseInHex;
  PrintOutNL;

  Mov rax, rsp;
  Mov rdi, 8;
  PrintOutMemoryInHex;
  PrintOutNL;
  PopR rax;

  Mov rax, 4096;
  PushR rax;
  Mov rax, rsp;
  Mov rdi, 8;
  PrintOutMemoryInHex;
  PrintOutNL;
  PopR rax;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
.765 4321 .765 4321
2143 65.7 2143 65.7
2143 65.7 2143 65.7
..10 .... .... ....
END
 }

if (1) {                                                                        #TPushR #TPopR
  Mov rax, 0x11111111;
  Mov rbx, 0x22222222;
  PushR my @save = (rax, rbx);
  Mov rax, 0x33333333;
  PopR;
  PrintOutRegisterInHex rax;
  PrintOutRegisterInHex rbx;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
   rax: .... .... 1111 1111
   rbx: .... .... 2222 2222
END
 }

#latest:;
if (1) {                                                                        #TClearMemory
  K(loop => 8+1)->for(sub
   {my ($index, $start, $next, $end) = @_;
    $index->setReg(15);
    Push r15;
   });

  Mov rax, rsp;
  Mov rdi, 8*9;
  PrintOutMemory_InHexNL;
  ClearMemory(V(address => rax), K(size => 8*9));
  PrintOutMemory_InHexNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
.8__ ____ ____ ____  .7__ ____ ____ ____  .6__ ____ ____ ____  .5__ ____ ____ ____  .4__ ____ ____ ____  .3__ ____ ____ ____  .2__ ____ ____ ____  .1__ ____ ____ ____  ____ ____ ____ ____
____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
END
 }

#latest:;
if (1) {                                                                        #TAllocateMemory #TFreeMemory #TClearMemory
  my $N = K size => 4096;                                                       # Size of the initial allocation which should be one or more pages

  my $A = AllocateMemory $N;

  ClearMemory($A, $N);

  $A->setReg(rax);
  Mov rdi, 128;
  PrintOutMemory_InHexNL;

  FreeMemory $A, $N;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
END
 }

#latest:;
if (1) {
  Mov rax, 0x44332211;
  PrintOutRegisterInHex rax;

  my $s = Subroutine
   {PrintOutRegisterInHex rax;
    Inc rax;
    PrintOutRegisterInHex rax;
   } name => "printIncPrint";

  $s->call;

  PrintOutRegisterInHex rax;

  my $r = Assemble(avx512=>0, eq=><<END);
   rax: .... .... 4433 2211
   rax: .... .... 4433 2211
   rax: .... .... 4433 2212
   rax: .... .... 4433 2212
END
 }

#latest:;
if (!$homeTest) {                                                               #TReadFile #TPrintMemory
  my $file = V(file => Rs $0);
  my ($address, $size) = ReadFile $file;                                        # Read file into memory
  $address->setReg(rax);                                                        # Address of file in memory
  $size   ->setReg(rdi);                                                        # Length  of file in memory
  PrintOutMemory;                                                               # Print contents of memory to stdout

  my $r = Assemble(avx512=>0);                                                  # Assemble and execute
  ok stringMd5Sum($r) eq fileMd5Sum($0);                                        # Output contains this file
 }

#latest:;
if (1) {                                                                        #TCreateArena #TArena::clear #TArena::outNL #TArena::copy #TArena::nl
  my $a = CreateArea;
  $a->q('aa');
  $a->outNL;
  ok Assemble(debug => 0, eq => <<END, avx512=>0);
aa
END
 }

#latest:
if (1) {                                                                        #TArena::dump
  my $a = CreateArea;
  my $b = CreateArea;
  $a->q("aaaa");
  $a->dump("aaaaa");
  $b->q("bbbb");
  $b->dump("bbbb");

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
aaaaa
Area     Size:     4096    Used:       68
.... .... .... .... | __10 ____ ____ ____  44__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 6161 6161 ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
bbbb
Area     Size:     4096    Used:       68
.... .... .... .... | __10 ____ ____ ____  44__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 6262 6262 ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
END
 }

if (1) {                                                                        #TCreateArena #TArena::clear #TArena::out #TArena::copy #TArena::nl
  my $a = CreateArea;
  my $b = CreateArea;
  $a->q('aa');
  $b->q('bb');
  $a->out;
  PrintOutNL;
  $b->out;
  PrintOutNL;
  ok Assemble(debug => 0, eq => <<END, avx512=>0);
aa
bb
END
 }

if (1) {                                                                        #TCreateArena #TArena::clear #TArena::out #TArena::copy #TArena::nl
  my $a = CreateArea;
  my $b = CreateArea;
  $a->q('aa');
  $a->q('AA');
  $a->out;
  PrintOutNL;
  ok Assemble(debug => 0, eq => <<END, avx512=>0);
aaAA
END
 }

if (1) {                                                                        #TCreateArena #TArena::clear #TArena::out #TArena::copy #TArena::nl
  my $a = CreateArea;
  my $b = CreateArea;
  $a->q('aa');
  $b->q('bb');
  $a->q('AA');
  $b->q('BB');
  $a->q('aa');
  $b->q('bb');
  $a->out;
  $b->out;
  PrintOutNL;
  ok Assemble(debug => 0, eq => <<END, avx512=>0);
aaAAaabbBBbb
END
 }

#latest:
if (1) {                                                                        #TCreateArena #TArena::length  #TArena::clear #TArena::out #TArena::copy #TArena::nl
  my $a = CreateArea;
  $a->q('ab');
  my $b = CreateArea;
  $b->append($a);
  $b->append($a);
  $a->append($b);
  $b->append($a);
  $a->append($b);
  $b->append($a);
  $b->append($a);
  $b->append($a);
  $b->append($a);


  $a->out;   PrintOutNL;
  $b->out;   PrintOutNL;
  my $sa = $a->used; $sa->outNL;
  my $sb = $b->used; $sb->outNL;
  $a->clear;
  my $sA = $a->used; $sA->outNL;
  my $sB = $b->used; $sB->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
abababababababab
ababababababababababababababababababababababababababababababababababababab
area used up: .... .... .... ..10
area used up: .... .... .... ..4A
area used up: .... .... .... ....
area used up: .... .... .... ..4A
END
 }


if (1) {                                                                        # Mask register instructions #TClearRegisters
  Mov rax,1;
  Kmovq k0,  rax;
  Kaddb k0,  k0, k0;
  Kaddb k0,  k0, k0;
  Kaddb k0,  k0, k0;
  Kmovq rax, k0;
  PushR k0;
  ClearRegisters k0;
  Kmovq k1, k0;
  PopR  k0;
  PrintOutRegisterInHex k0;
  PrintOutRegisterInHex k1;

  ok Assemble(avx512 => 1, eq => <<END)
    k0: .... .... .... ...8
    k1: .... .... .... ....
END
 }

if (1) {                                                                        # Count leading zeros
  Mov   rax, 8;                                                                 # Append a constant to the area
  Lzcnt rax, rax;                                                               # New line
  PrintOutRegisterInHex rax;

  Mov   rax, 8;                                                                 # Append a constant to the area
  Tzcnt rax, rax;                                                               # New line
  PrintOutRegisterInHex rax;

  ok Assemble(avx512 => 1, eq => <<END)
   rax: .... .... .... ..3C
   rax: .... .... .... ...3
END
 }

#latest:;
if (1) {                                                                        #TArena::nl
  my $s = CreateArea;
  $s->q("A");
  $s->nl;
  $s->q("B");
  $s->out;
  PrintOutNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
A
B
END
 }

#latest:;
if (!$homeTest) {                                                               # Print this file - slow -  #TArena::read #TArena::z #TArena::q
  my $s = CreateArea;                                                           # Create a string
  $s->read(K file => Rs($0));
  $s->out;

  my $r = Assemble(emulator => 0);
  is_deeply stringMd5Sum($r), fileMd5Sum($0);                                   # Output contains this file
 }

#latest:;
if (1) {                                                                        # Print rdi in hex into an area #TGetPidInHex
  GetPidInHex;
  Mov r15, rax;

  GetPidInHex;
  Cmp r15, rax;
  IfEq Then {PrintOutStringNL "Same"}, Else {PrintOutStringNL "Diff"};

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
Same
END
 }

#latest:;
if ($homeTest) {                                                                # Execute the content of an area #TexecuteFileViaBash #TArena::write #TArena::out #TunlinkFile #TArena::ql
  my $s = CreateArea;                                                           # Create a string
  $s->ql(<<END);                                                                # Write code to execute
#!/usr/bin/bash
whoami
END
  $s->write         (my $f = V('file', Rs("zzz.sh")));                          # Write code to a file
  executeFileViaBash($f);                                                       # Execute the file
  unlinkFile        ($f);                                                       # Delete the file

  my $u = qx(whoami); chomp($u);
  ok Assemble(debug => 0, eq => <<END, avx512=>0);
phil
END
 }

#latest:;
if (!hasAvx512) {                                                               # Make an area readonly - but we need the emulator to test this
  my $s = CreateArea;                                                           # Create an area
  $s->q("Hello");                                                               # Write code to area
  $s->makeReadOnly;                                                             # Make area read only
  $s->q(" World");                                                              # Try to write to area

  ok Assemble(debug=>2, emulator=>1) =~ m(SDE ERROR: DEREFERENCING BAD MEMORY POINTER.*mov byte ptr .rax.rdx.1., r8b);
 }

#latest:;
if (1) {                                                                        # Make a read only area writable  #TArena::makeReadOnly #TArena::makeWriteable
  my $s = CreateArea;                                                           # Create an area
  $s->q("Hello");                                                               # Write data to area
  $s->makeReadOnly;                                                             # Make area read only - tested above
  $s->makeWriteable;                                                            # Make area writable again
  $s->q(" World");                                                              # Try to write to area
  $s->outNL;

  ok Assemble(avx512=>0, eq => <<END);
Hello World
END
 }

#latest:;
if (1) {                                                                        # Allocate some space in area #TArena::allocate
  my $s = CreateArea;                                                           # Create an area
  my $o1 = $s->allocate(K size => 0x20);                                        # Allocate space wanted
  my $o2 = $s->allocate(K size => 0x30);
  my $o3 = $s->allocate(K size => 0x10);
  $o1->outNL;
  $o2->outNL;
  $o3->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
offset: .... .... .... ..40
offset: .... .... .... ..60
offset: .... .... .... ..90
END
 }

#latest:;
if (1) {                                                                        #TNasm::X86::Area::checkYggdrasilCreated #TNasm::X86::Area::establishYggdrasil
  my $A = CreateArea;
  my $t = $A->checkYggdrasilCreated;
     $t->found->outNL;
  my $y = $A->establishYggdrasil;
  my $T = $A->checkYggdrasilCreated;
     $T->found->outNL;
  ok Assemble(debug => 0, eq => <<END, avx512=>1);
found: .... .... .... ....
found: .... .... .... ...1
END
 }

# It is one of the happiest characteristics of this glorious country that official utterances are invariably regarded as unanswerable

#latest:;
if (1) {                                                                        #TPrintOutZF #TSetZF #TClearZF #TIfC #TIfNc #TIfZ #IfNz
  SetZF;
  PrintOutZF;
  ClearZF;
  PrintOutZF;
  SetZF;
  PrintOutZF;
  SetZF;
  PrintOutZF;
  ClearZF;
  PrintOutZF;

  SetZF;
  IfZ  Then {PrintOutStringNL "Zero"},     Else {PrintOutStringNL "NOT zero"};
  ClearZF;
  IfNz Then {PrintOutStringNL "NOT zero"}, Else {PrintOutStringNL "Zero"};

  Mov r15, 5;
  Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
  Shr r15, 1; IfC  Then {PrintOutStringNL "Carry"}   , Else {PrintOutStringNL "NO carry"};
  Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};
  Shr r15, 1; IfNc Then {PrintOutStringNL "NO carry"}, Else {PrintOutStringNL "Carry"};

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
ZF=1
ZF=0
ZF=1
ZF=1
ZF=0
Zero
NOT zero
Carry
NO carry
Carry
NO carry
END
 }

if (1) {                                                                        #TSetLabel #TRegisterSize #TSaveFirstFour #TSaveFirstSeven #TRestoreFirstFour #TRestoreFirstSeven #TRestoreFirstFourExceptRax #TRestoreFirstSevenExceptRax #TRestoreFirstFourExceptRaxAndRdi #TRestoreFirstSevenExceptRaxAndRdi #TReverseBytesInRax
  Mov rax, 1;
  Mov rdi, 1;
  SaveFirstFour;
  Mov rax, 2;
  Mov rdi, 2;
  SaveFirstSeven;
  Mov rax, 3;
  Mov rdi, 4;
  PrintOutRegisterInHex rax, rdi;
  RestoreFirstSeven;
  PrintOutRegisterInHex rax, rdi;
  RestoreFirstFour;
  PrintOutRegisterInHex rax, rdi;

  SaveFirstFour;
  Mov rax, 2;
  Mov rdi, 2;
  SaveFirstSeven;
  Mov rax, 3;
  Mov rdi, 4;
  PrintOutRegisterInHex rax, rdi;
  RestoreFirstSevenExceptRax;
  PrintOutRegisterInHex rax, rdi;
  RestoreFirstFourExceptRax;
  PrintOutRegisterInHex rax, rdi;

  SaveFirstFour;
  Mov rax, 2;
  Mov rdi, 2;
  SaveFirstSeven;
  Mov rax, 3;
  Mov rdi, 4;
  PrintOutRegisterInHex rax, rdi;
  RestoreFirstSevenExceptRaxAndRdi;
  PrintOutRegisterInHex rax, rdi;
  RestoreFirstFourExceptRaxAndRdi;
  PrintOutRegisterInHex rax, rdi;

  Bswap rax;
  PrintOutRegisterInHex rax;

  my $l = Label;
  Jmp $l;
  SetLabel $l;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
   rax: .... .... .... ...3
   rdi: .... .... .... ...4
   rax: .... .... .... ...2
   rdi: .... .... .... ...2
   rax: .... .... .... ...1
   rdi: .... .... .... ...1
   rax: .... .... .... ...3
   rdi: .... .... .... ...4
   rax: .... .... .... ...3
   rdi: .... .... .... ...2
   rax: .... .... .... ...3
   rdi: .... .... .... ...1
   rax: .... .... .... ...3
   rdi: .... .... .... ...4
   rax: .... .... .... ...3
   rdi: .... .... .... ...4
   rax: .... .... .... ...3
   rdi: .... .... .... ...4
   rax: .3.. .... .... ....
END

  ok 8 == RegisterSize rax;
 }

#latest:
if (1) {                                                                        #TRb #TRd #TRq #TRw #TDb #TDd #TDq #TDw #TCopyMemory
  my $s = Rb 0; Rb 1; Rw 2; Rd 3;  Rq 4;
  my $t = Db 0; Db 1; Dw 2; Dd 3;  Dq 4;

  Vmovdqu8 xmm0, "[$s]";
  Vmovdqu8 xmm1, "[$t]";
  PrintOutRegisterInHex xmm0;
  PrintOutRegisterInHex xmm1;
  Sub rsp, 16;

  Mov rax, rsp;                                                                 # Copy memory, the target is addressed by rax, the length is in rdi, the source is addressed by rsi
  Mov rdi, 16;
  Mov rsi, $s;
  CopyMemory(V(source => rsi), V(target => rax), V size => rdi);
  PrintOutMemory_InHexNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
  xmm0: .... .... .... ...4  .... ...3 ...2 .1..
  xmm1: .... .... .... ...4  .... ...3 ...2 .1..
__.1 .2__ .3__ ____  .4__ ____ ____ ____
END
 }

#latest:
if (1) {
  my $a = V(a => 1);
  my $b = V(b => 2);
  my $c = $a + $b;
  Mov r15, 22;
  $a->getReg(r15);
  $b->copy($a);
  $b = $b + 1;
  $b->setReg(14);
  $a->outNL;
  $b->outNL;
  $c->outNL;
  PrintOutRegisterInHex r14, r15;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
a: .... .... .... ..16
(b add 1): .... .... .... ..17
(a add b): .... .... .... ...3
   r14: .... .... .... ..17
   r15: .... .... .... ..16
END
 }

#latest:
if (1) {                                                                        #TV #TK #TG #TNasm::X86::Variable::copy
  my $s = Subroutine
   {my ($p) = @_;
    $$p{v}->copy($$p{v} + $$p{k} + $$p{g} + 1);
   } name => 'add', parameters=>[qw(v k g)];

  my $v = V(v => 1);
  my $k = K(k => 2);
  my $g = V(g => 3);
  $s->call(parameters=>{v=>$v, k=>$k, g=>$g});
  $v->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
v: .... .... .... ...7
END
 }

#latest:
if (1) {                                                                        #TV #TK #TG #TNasm::X86::Variable::copy
  my $g = V g => 0;
  my $s = Subroutine
   {my ($p) = @_;
    $$p{g}->copy(K value => 1);
   } name => 'ref2', parameters=>[qw(g)];

  my $t = Subroutine
   {my ($p) = @_;
    $s->call(parameters=>{g=>$$p{g}});
   } name => 'ref', parameters=>[qw(g)];

  $t->call(parameters=>{g=>$g});
  $g->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
g: .... .... .... ...1
END
 }

#latest:
if (1) {                                                                        #TSubroutine
  my $g = V g => 3;
  my $s = Subroutine
   {my ($p, $s, $sub) = @_;
    my $g = $$p{g};
    $g->copy($g - 1);
    $g->outNL;
    If ($g > 0,
    Then
     {$sub->call(parameters=>{g => $g});
     });
   } parameters=>[qw(g)], name => 'ref';

  $s->call(parameters=>{g => $g});

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
g: .... .... .... ...2
g: .... .... .... ...1
g: .... .... .... ....
END
 }

#latest:
if (0) {                                                                        #TPrintOutTraceBack
  my $d = V depth => 3;                                                         # Create a variable on the stack

  my $s = Subroutine
   {my ($p, $s, $sub) = @_;                                                     # Parameters, structures, subroutine descriptor

    my $d = $$p{depth}->copy($$p{depth} - 1);                                   # Modify the variable referenced by the parameter

    If $d > 0,
    Then
     {$sub->call(parameters => {depth => $d});                                  # Recurse
     };

    #PrintOutTraceBack 'AAAA';
   } parameters =>[qw(depth)], name => 'ref';

  $s->call(parameters=>{depth => V depth => 0});

  ok Assemble(debug => 0, eq => <<END, avx512=>0);

Subroutine trace back, depth:  3
0000 0000 0000 0001    ref
0000 0000 0000 0001    ref
0000 0000 0000 0001    ref
END
 }

#latest:
if (0) {                                                                        #TSubroutine
  my $g = V g, 2;
  my $u = Subroutine33
   {my ($p, $s) = @_;
    $$p{g}->copy(K gg, 1);
    PrintOutTraceBack '';
   } [qw(g)], name => 'uuuu';
  my $t = Subroutine33
   {my ($p, $s) = @_;
    $u->call($$p{g});
   } [qw(g)], name => 'tttt';
  my $s = Subroutine33
   {my ($p, $s) = @_;
    $t->call($$p{g});
   } [qw(g)], name => 'ssss';

  $g->outNL;
  $s->call($g);
  $g->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
Subroutine trace back, depth:  3
0000 0000 0000 0002    uuuu
0000 0000 0000 0002    tttt
0000 0000 0000 0002    ssss
END
 }

#latest:
if (0) {                                                                        #TSubroutine
  my $r = V r, 2;

  my $u = Subroutine33
   {my ($p, $s) = @_;
    $$p{u}->copy(K gg, 1);
    PrintOutTraceBack '';
   } [qw(u)], name => 'uuuu';

  my $t = Subroutine33
   {my ($p, $s) = @_;
    $u->call(u => $$p{t});
   } [qw(t)], name => 'tttt';

  my $s = Subroutine33
   {my ($p, $s) = @_;
   $t->call(t => $$p{s});
   } [qw(s)], name => 'ssss';

  $r->outNL;
  $s->call(s=>$r);
  $r->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
r: 0000 0000 0000 0002

Subroutine trace back, depth:  3
0000 0000 0000 0002    uuuu
0000 0000 0000 0002    tttt
0000 0000 0000 0002    ssss


Subroutine trace back, depth:  3
0000 0000 0000 0001    uuuu
0000 0000 0000 0001    tttt
0000 0000 0000 0001    ssss

r: 0000 0000 0000 0001
END
 }

#latest:;
if (1) {                                                                        #TAllocateMemory #TPrintOutMemoryInHexNL #TCopyMemory
  my $N = 256;
  my $s = Rb 0..$N-1;
  my $a = AllocateMemory K size => $N;
  CopyMemory(V(source => $s), $a, K(size => $N));

  my $b = AllocateMemory K size => $N;
  CopyMemory($a, $b, K size => $N);

  $b->setReg(rax);
  Mov rdi, $N;
  PrintOutMemory_InHexNL;

  ok Assemble(debug=>0, eq => <<END, avx512=>0);
__.1 .2.3 .4.5 .6.7  .8.9 .A.B .C.D .E.F  1011 1213 1415 1617  1819 1A1B 1C1D 1E1F  2021 2223 2425 2627  2829 2A2B 2C2D 2E2F  3031 3233 3435 3637  3839 3A3B 3C3D 3E3F  4041 4243 4445 4647  4849 4A4B 4C4D 4E4F  5051 5253 5455 5657  5859 5A5B 5C5D 5E5F  6061 6263 6465 6667  6869 6A6B 6C6D 6E6F  7071 7273 7475 7677  7879 7A7B 7C7D 7E7F  8081 8283 8485 8687  8889 8A8B 8C8D 8E8F  9091 9293 9495 9697  9899 9A9B 9C9D 9E9F  A0A1 A2A3 A4A5 A6A7  A8A9 AAAB ACAD AEAF  B0B1 B2B3 B4B5 B6B7  B8B9 BABB BCBD BEBF  C0C1 C2C3 C4C5 C6C7  C8C9 CACB CCCD CECF  D0D1 D2D3 D4D5 D6D7  D8D9 DADB DCDD DEDF  E0E1 E2E3 E4E5 E6E7  E8E9 EAEB ECED EEEF  F0F1 F2F3 F4F5 F6F7  F8F9 FAFB FCFD FEFF
END
 }

if (1) {                                                                        # Variable length shift
  Mov rax, -1;
  Mov cl, 30;
  Shl rax, cl;
  Kmovq k0, rax;
  PrintOutRegisterInHex k0;

  ok Assemble(avx512=>1, eq=><<END);
    k0: FFFF FFFF C0.. ....
END
 }

#latest:;
if (1) {                                                                        # Expand
  ClearRegisters rax;
  Bts rax, 14;
  Not rax;
  PrintOutRegisterInHex rax;
  Kmovq k1, rax;
  PrintOutRegisterInHex k1;

  Mov rax, 1;
  Vpbroadcastb zmm0, rax;
  PrintOutRegisterInHex zmm0;

  Vpexpandd "zmm1{k1}", zmm0;
  PrintOutRegisterInHex zmm1;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
   rax: FFFF FFFF FFFF BFFF
    k1: FFFF FFFF FFFF BFFF
  zmm0: .1.1 .1.1 .1.1 .1.1  .1.1 .1.1 .1.1 .1.1 - .1.1 .1.1 .1.1 .1.1  .1.1 .1.1 .1.1 .1.1 + .1.1 .1.1 .1.1 .1.1  .1.1 .1.1 .1.1 .1.1 - .1.1 .1.1 .1.1 .1.1  .1.1 .1.1 .1.1 .1.1
  zmm1: .1.1 .1.1 .... ....  .1.1 .1.1 .1.1 .1.1 - .1.1 .1.1 .1.1 .1.1  .1.1 .1.1 .1.1 .1.1 + .1.1 .1.1 .1.1 .1.1  .1.1 .1.1 .1.1 .1.1 - .1.1 .1.1 .1.1 .1.1  .1.1 .1.1 .1.1 .1.1
END
 }

#latest:;
if (1) {
  my $P = "2F";                                                                 # Value to test for
  my $l = Rb 0;  Rb $_ for 1..RegisterSize zmm0;                                # The numbers 0..63
  Vmovdqu8 zmm0, "[$l]";                                                        # Load data to test
  PrintOutRegisterInHex zmm0;
  PrintOutRegisterInHex zmm0;

  Mov rax, "0x$P";                                                              # Broadcast the value to be tested
  Vpbroadcastb zmm1, rax;
  PrintOutRegisterInHex zmm1;

  for my $c(0..7)                                                               # Each possible test
   {my $m = "k$c";
    Vpcmpub $m, zmm1, zmm0, $c;
    PrintOutRegisterInHex $m;
   }

  Kmovq rax, k0;                                                                # Count the number of trailing zeros in k0
  Tzcnt rax, rax;

  PrintOutRegisterInHex rax;

  ok Assemble(avx512=>1, eq=><<END);
  zmm0: 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130 - 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120 + 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  zmm0: 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130 - 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120 + 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
  zmm1: 2F2F 2F2F 2F2F 2F2F  2F2F 2F2F 2F2F 2F2F - 2F2F 2F2F 2F2F 2F2F  2F2F 2F2F 2F2F 2F2F + 2F2F 2F2F 2F2F 2F2F  2F2F 2F2F 2F2F 2F2F - 2F2F 2F2F 2F2F 2F2F  2F2F 2F2F 2F2F 2F2F
    k0: .... 80.. .... ....
    k1: FFFF .... .... ....
    k2: FFFF 80.. .... ....
    k3: .... .... .... ....
    k4: FFFF 7FFF FFFF FFFF
    k5: .... FFFF FFFF FFFF
    k6: .... 7FFF FFFF FFFF
    k7: FFFF FFFF FFFF FFFF
   rax: .... .... .... ..2F
END
#   0 eq    1 lt    2 le    4 ne    5 ge    6 gt   comparisons
 }

#latest:;
if (1) {
  my $P = "2F";                                                                 # Value to test for
  my $l = Rb 0;  Rb $_ for 1..RegisterSize zmm0;                                # The numbers 0..63
  Vmovdqu8 zmm0, "[$l]";                                                        # Load data to test

  Mov rax, "0x$P";                                                              # Broadcast the value to be tested
  Vpbroadcastb zmm1, rax;

  for my $c(0..7)                                                               # Each possible test
   {my $m = "k$c";
    Vpcmpub $m, zmm1, zmm0, $c;
   }

  Kmovq rax, k0;                                                                # Count the number of trailing zeros in k0
  Tzcnt rax, rax;
  PrintOutRegisterInHex rax;

  Kmovq rax, k0;                                                                # Count the number of leading zeros in k0
  Lzcnt rax, rax;
  PrintOutRegisterInHex rax;

  ok Assemble(avx512=>1, eq=><<END);
   rax: .... .... .... ..2F
   rax: .... .... .... ..10
END
 }

#latest:;
if (1) {                                                                        #TStringLength
  StringLength(V string => Rs("abcd"))->outNL;
  Assemble(debug => 0, eq => <<END, avx512=>0);
size: .... .... .... ...4
END
 }

#latest:;
if (0) {                                                                        # Hash a string #THash
  Mov rax, "[rbp+24]";                                                          # Address of string as parameter
  StringLength(V string => rax)->setReg(rdi);                                   # Length of string to hash
  Hash();                                                                       # Hash string

  PrintOutRegisterInHex r15;

  my $e = Assemble keep => 'hash';                                              # Assemble to the specified file name
  say STDERR qx($e "");
  say STDERR qx($e "a");
  ok qx($e "")  =~ m(r15: 0000 3F80 0000 3F80);                                 # Test well known hashes
  ok qx($e "a") =~ m(r15: 0000 3F80 C000 45B2);

  if (0)                                                                        # Hash various strings
   {my %r; my %f; my $count = 0;
    my $N = RegisterSize zmm0;

    if (1)                                                                      # Fixed blocks
     {for my $l(qw(a ab abc abcd), 'a a', 'a  a')
       {for my $i(1..$N)
         {my $t = $l x $i;
          last if $N < length $t;
          my $s = substr($t.(' ' x $N), 0, $N);
          next if $f{$s}++;
          my $r = qx($e "$s");
          say STDERR "$count  $r";
          if ($r =~ m(^.*r15:\s*(.*)$)m)
           {push $r{$1}->@*, $s;
            ++$count;
           }
         }
       }
     }

    if (1)                                                                      # Variable blocks
     {for my $l(qw(a ab abc abcd), '', 'a a', 'a  a')
       {for my $i(1..$N)
         {my $t = $l x $i;
          next if $f{$t}++;
          my $r = qx($e "$t");
          say STDERR "$count  $r";
          if ($r =~ m(^.*r15:\s*(.*)$)m)
           {push $r{$1}->@*, $t;
            ++$count;
           }
         }
       }
     }
    for my $r(keys %r)
     {delete $r{$r} if $r{$r}->@* < 2;
     }

    say STDERR dump(\%r);
    say STDERR "Keys hashed: ", $count;
    confess "Duplicates : ",  scalar keys(%r);
   }

  unlink 'hash';
 }

if (1) {                                                                        #TIfEq #TIfNe #TIfLe #TIfLt #TIfGe #TIfGt
  my $cmp = sub
   {my ($a, $b) = @_;

    for my $op(qw(eq ne lt le gt ge))
     {Mov rax, $a;
      Cmp rax, $b;
      my $Op = ucfirst $op;
      eval qq(If$Op Then {PrintOutStringNL("$a $op $b")}, Else {PrintOutStringNL("$a NOT $op $b")});
      $@ and confess $@;
     }
   };
  &$cmp(1,1);
  &$cmp(1,2);
  &$cmp(3,2);
  Assemble(debug => 0, eq => <<END, avx512=>0);
1 eq 1
1 NOT ne 1
1 NOT lt 1
1 le 1
1 NOT gt 1
1 ge 1
1 NOT eq 2
1 ne 2
1 lt 2
1 le 2
1 NOT gt 2
1 NOT ge 2
3 NOT eq 2
3 ne 2
3 NOT lt 2
3 NOT le 2
3 gt 2
3 ge 2
END
 }

if (1) {                                                                        #TSetMaskRegister
  Mov rax, 8;
  Mov rsi, -1;
  Inc rsi; SetMaskRegister(0, rax, rsi); PrintOutRegisterInHex k0;
  Inc rsi; SetMaskRegister(1, rax, rsi); PrintOutRegisterInHex k1;
  Inc rsi; SetMaskRegister(2, rax, rsi); PrintOutRegisterInHex k2;
  Inc rsi; SetMaskRegister(3, rax, rsi); PrintOutRegisterInHex k3;
  Inc rsi; SetMaskRegister(4, rax, rsi); PrintOutRegisterInHex k4;
  Inc rsi; SetMaskRegister(5, rax, rsi); PrintOutRegisterInHex k5;
  Inc rsi; SetMaskRegister(6, rax, rsi); PrintOutRegisterInHex k6;
  Inc rsi; SetMaskRegister(7, rax, rsi); PrintOutRegisterInHex k7;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
    k0: .... .... .... ....
    k1: .... .... .... .1..
    k2: .... .... .... .3..
    k3: .... .... .... .7..
    k4: .... .... .... .F..
    k5: .... .... .... 1F..
    k6: .... .... .... 3F..
    k7: .... .... .... 7F..
END
 }

#latest:;
if (1) {                                                                        #TNasm::X86::Variable::dump  #TNasm::X86::Variable::print #TThen #TElse #TV #TK
  my $a = V(a => 3);  $a->outNL;
  my $b = K(b => 2);  $b->outNL;
  my $c = $a +  $b; $c->outNL;
  my $d = $c -  $a; $d->outNL;
  my $g = $a *  $b; $g->outNL;
  my $h = $g /  $b; $h->outNL;
  my $i = $a %  $b; $i->outNL;

  If ($a == 3,
  Then
   {PrintOutStringNL "a == 3"
   },
  Else
   {PrintOutStringNL "a != 3"
   });

  ++$a; $a->outNL;
  --$a; $a->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
a: .... .... .... ...3
b: .... .... .... ...2
(a add b): .... .... .... ...5
((a add b) sub a): .... .... .... ...2
(a times b): .... .... .... ...6
((a times b) / b): .... .... .... ...3
(a % b): .... .... .... ...1
a == 3
a: .... .... .... ...4
a: .... .... .... ...3
END
 }

#latest:;
if (1) {                                                                        #TNasm::X86::Variable::for
  V(limit => 10)->for(sub
   {my ($i, $start, $next, $end) = @_;
    $i->outNL;
   });

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
index: .... .... .... ....
index: .... .... .... ...1
index: .... .... .... ...2
index: .... .... .... ...3
index: .... .... .... ...4
index: .... .... .... ...5
index: .... .... .... ...6
index: .... .... .... ...7
index: .... .... .... ...8
index: .... .... .... ...9
END
 }

#latest:;
if (1) {                                                                        #TNasm::X86::Variable::min #TNasm::X86::Variable::max
  my $a = V("a", 1);
  my $b = V("b", 2);
  my $c = $a->min($b);
  my $d = $a->max($b);
  $a->outNL;
  $b->outNL;
  $c->outNL;
  $d->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
a: .... .... .... ...1
b: .... .... .... ...2
min: .... .... .... ...1
max: .... .... .... ...2
END
 }

#latest:;
if (1) {                                                                        #TNasm::X86::Variable::setMask
  my $start  = V("Start",  7);
  my $length = V("Length", 3);
  $start->setMask($length, k7);
  PrintOutRegisterInHex k7;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
    k7: .... .... .... .380
END
 }

#latest:;
if (1) {                                                                        #TNasm::X86::Variable::setZmm
  my $s = Rb(0..128);
  my $source = V(Source=> $s);

  if (1)                                                                        # First block
   {$source->setZmm(0, K(key => 7), K length => 3);
   }

  if (1)                                                                        # Second block
   {$source->setZmm(0, K(key => 33), K key => 12);
   }

  PrintOutRegisterInHex zmm0;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
  zmm0: .... .... .... ....  .... .... .... .... - .... ...B .A.9 .8.7  .6.5 .4.3 .2.1 .... + .... .... .... ....  .... .... .... .... - .... .... .... .2.1  .... .... .... ....
END
 }

#latest:;
if (1) {                                                                        #TLoadZmm #Tzmm
  LoadZmm 0, 0..63;
  PrintOutRegisterInHex zmm 0;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
  zmm0: 3F3E 3D3C 3B3A 3938  3736 3534 3332 3130 - 2F2E 2D2C 2B2A 2928  2726 2524 2322 2120 + 1F1E 1D1C 1B1A 1918  1716 1514 1312 1110 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
END
 }

#latest:;
if (1) {                                                                        #TgetDFromZmm #TNasm::X86::Variable::dIntoZ
  my $s = Rb(0..8);
  my $c = V("Content",   "[$s]");
     $c->bIntoZ     (0, 4);
     $c->putWIntoZmm(0, 6);
     $c->dIntoZ(0, 10);
     $c->qIntoZ(0, 16);
  PrintOutRegisterInHex zmm0;
  bFromZ(0, 12)->outNL;
  wFromZ(0, 12)->outNL;
  dFromZ(0, 12)->outNL;
  qFromZ(0, 12)->outNL;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
  zmm0: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .7.6 .5.4 .3.2 .1.. - .... .3.2 .1.. ....  .1.. .... .... ....
b at offset 12 in zmm0: .... .... .... ...2
w at offset 12 in zmm0: .... .... .... .3.2
d at offset 12 in zmm0: .... .... .... .3.2
q at offset 12 in zmm0: .3.2 .1.. .... .3.2
END
 }

#latest:;
if (1) {                                                                        #TNasm::X86::Area::used #TNasm::X86::Area::clear #TNasm::X86::Area::size  #TNasm::X86::Area::free
  my $a = CreateArea;

  $a->q("a" x 255);
  $a->used->outNL;
  $a->size->outNL;
  $a->dump('A');
  $a->clear;
  $a->used->outNL;
  $a->size->outNL;
  $a->dump('B');

  $a->q("a" x 4095);
  $a->used->outNL;
  $a->size->outNL;
  $a->dump('C');
  $a->clear;
  $a->used->outNL;
  $a->size->outNL;
  $a->dump('D');

  $a->free;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
area used up: .... .... .... ..FF
size of area: .... .... .... 10..
A
Area     Size:     4096    Used:      319
.... .... .... .... | __10 ____ ____ ____  3F.1 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
.... .... .... ..80 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
.... .... .... ..C0 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
area used up: .... .... .... ....
size of area: .... .... .... 10..
B
Area     Size:     4096    Used:       64
.... .... .... .... | __10 ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
.... .... .... ..80 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
.... .... .... ..C0 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
area used up: .... .... .... .FFF
size of area: .... .... .... 20..
C
Area     Size:     8192    Used:     4159
.... .... .... .... | __20 ____ ____ ____  3F10 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
.... .... .... ..80 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
.... .... .... ..C0 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
area used up: .... .... .... ....
size of area: .... .... .... 20..
D
Area     Size:     8192    Used:       64
.... .... .... .... | __20 ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
.... .... .... ..80 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
.... .... .... ..C0 | 6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161  6161 6161 6161 6161
END
 }

#latest:;
if (1) {                                                                        #TNasm::X86::Variable::setMask
  my $z = V('zero', 0);
  my $o = V('one',  1);
  my $t = V('two',  2);
  $z->setMask($o,       k7); PrintOutRegisterInHex k7;
  $z->setMask($t,       k6); PrintOutRegisterInHex k6;
  $z->setMask($o+$t,    k5); PrintOutRegisterInHex k5;
  $o->setMask($o,       k4); PrintOutRegisterInHex k4;
  $o->setMask($t,       k3); PrintOutRegisterInHex k3;
  $o->setMask($o+$t,    k2); PrintOutRegisterInHex k2;

  $t->setMask($o,       k1); PrintOutRegisterInHex k1;
  $t->setMask($t,       k0); PrintOutRegisterInHex k0;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
    k7: .... .... .... ...1
    k6: .... .... .... ...3
    k5: .... .... .... ...7
    k4: .... .... .... ...2
    k3: .... .... .... ...6
    k2: .... .... .... ...E
    k1: .... .... .... ...4
    k0: .... .... .... ...C
END
 }

#latest:
if (1) {                                                                        #TExtern #TLink #TCallC
  my $format = Rs "Hello %s\n";
  my $data   = Rs "World";

  Extern qw(printf exit malloc strcpy); Link 'c';

  CallC 'malloc', length($format)+1;
  Mov r15, rax;
  CallC 'strcpy', r15, $format;
  CallC 'printf', r15, $data;
  CallC 'exit', 0;

  ok Assemble avx512=>0, eq => <<END;
Hello World
END
 }

#latest:
if (1) {
  my $a = Rb((reverse 0..16)x16);
  my $b = Rb((        0..16)x16);
  Mov rax, $a;  Vmovdqu8 zmm0, "[rax]";
  Mov rax, $b;  Vmovdqu8 zmm1, "[rax]";
  Vpcmpeqb k0, zmm0, zmm1;

  Kmovq rax, k0; Popcnt rax, rax;
  PrintOutRegisterInHex zmm0, zmm1, k0, rax;

  ok Assemble avx512=>1, eq => <<END;
  zmm0: .4.5 .6.7 .8.9 .A.B  .C.D .E.F 10.. .1.2 - .3.4 .5.6 .7.8 .9.A  .B.C .D.E .F10 ...1 + .2.3 .4.5 .6.7 .8.9  .A.B .C.D .E.F 10.. - .1.2 .3.4 .5.6 .7.8  .9.A .B.C .D.E .F10
  zmm1: .C.B .A.9 .8.7 .6.5  .4.3 .2.1 ..10 .F.E - .D.C .B.A .9.8 .7.6  .5.4 .3.2 .1.. 10.F + .E.D .C.B .A.9 .8.7  .6.5 .4.3 .2.1 ..10 - .F.E .D.C .B.A .9.8  .7.6 .5.4 .3.2 .1..
    k0: .8.. .4.. .2.. .1..
   rax: .... .... .... ...4
END
 }

#latest:
if (1) {                                                                        #TConvertUtf8ToUtf32
  my ($out, $size, $fail) = (V(out=>undef), V(size=>undef), V(fail=>undef));

  my $Chars = Rb(0x24, 0xc2, 0xa2, 0xc9, 0x91, 0xE2, 0x82, 0xAC, 0xF0, 0x90, 0x8D, 0x88);
  my $chars = V(chars => $Chars);

  GetNextUtf8CharAsUtf32 $chars+0, $out, $size, $fail;                          # Dollar               UTF-8 Encoding: 0x24                UTF-32 Encoding: 0x00000024
  $out->out('out1 : ');     $size->outNL(' size : ');

  GetNextUtf8CharAsUtf32 $chars+1, $out, $size, $fail;                          # Cents                UTF-8 Encoding: 0xC2 0xA2           UTF-32 Encoding: 0x000000a2
  $out->out('out2 : ');     $size->outNL(' size : ');

  GetNextUtf8CharAsUtf32 $chars+3, $out, $size, $fail;                          # Alpha                UTF-8 Encoding: 0xC9 0x91           UTF-32 Encoding: 0x00000251
  $out->out('out3 : ');     $size->outNL(' size : ');

  GetNextUtf8CharAsUtf32 $chars+5, $out, $size, $fail;                          # Euro                 UTF-8 Encoding: 0xE2 0x82 0xAC      UTF-32 Encoding: 0x000020AC
  $out->out('out4 : ');     $size->outNL(' size : ');

  GetNextUtf8CharAsUtf32 $chars+8, $out, $size, $fail;                          # Gothic Letter Hwair  UTF-8 Encoding  0xF0 0x90 0x8D 0x88 UTF-32 Encoding: 0x00010348
  $out->out('out5 : ');     $size->outNL(' size : ');

  my $statement = qq(\n    \nAAAAAAAA);                        # A sample sentence to parse

  my $s = K(statement => Rutf8($statement));
  my $l = StringLength $s;

  my $address = AllocateMemory $l;                                              # Allocate enough memory for a copy of the string
  CopyMemory($s, $address, $l);

  GetNextUtf8CharAsUtf32 $address, $out, $size, $fail;
  $out->out('outA : ');     $size->outNL(' size : ');

  GetNextUtf8CharAsUtf32 $address+4, $out, $size, $fail;
  $out->out('outB : ');     $size->outNL(' size : ');

  GetNextUtf8CharAsUtf32 $address+5, $out, $size, $fail;
  $out->out('outC : ');     $size->outNL(' size : ');

  GetNextUtf8CharAsUtf32 $address+30, $out, $size, $fail;
  $out->out('outD : ');     $size->outNL(' size : ');

  GetNextUtf8CharAsUtf32 $address+35, $out, $size, $fail;
  $out->out('outE : ');     $size->outNL(' size : ');

  $address->printOutMemoryInHexNL($l);

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
out1 : .... .... .... ..24 size : .... .... .... ...1
out2 : .... .... .... ..A2 size : .... .... .... ...2
out3 : .... .... .... .251 size : .... .... .... ...2
out4 : .... .... .... 20AC size : .... .... .... ...3
out5 : .... .... ...1 .348 size : .... .... .... ...4
outA : .... .... ...1 D5BA size : .... .... .... ...4
outB : .... .... .... ...A size : .... .... .... ...1
outC : .... .... .... ..20 size : .... .... .... ...1
outD : .... .... .... ..20 size : .... .... .... ...1
outE : .... .... .... ..10 size : .... .... .... ...2
F09D 96BA .A20 F09D  918E F09D 91A0 F09D  91A0 F09D 9196 F09D  9194 F09D 919B 20E3  8090 E380 90F0 9D96  BB20 F09D 90A9 F09D  90A5 F09D 90AE F09D  90AC 20F0 9D96 BCE3  8091 E380 91.A 4141  4141 4141 4141 ....
END
 }

#latest:
if (1) {                                                                        #TLoadBitsIntoMaskRegister
  for (0..7)
   {ClearRegisters "k$_";
    K($_,$_)->setMaskBit("k$_");
    PrintOutRegisterInHex "k$_";
   }

  ClearRegisters k7;
  LoadBitsIntoMaskRegister(7, '1010', -4, +4, -2, +2, -1, +1, -1, +1);
  PrintOutRegisterInHex "k7";

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
    k0: .... .... .... ...1
    k1: .... .... .... ...2
    k2: .... .... .... ...4
    k3: .... .... .... ...8
    k4: .... .... .... ..10
    k5: .... .... .... ..20
    k6: .... .... .... ..40
    k7: .... .... .... ..80
    k7: .... .... ...A .F35
END
 }

#latest:
if (1) {                                                                        #TInsertZeroIntoRegisterAtPoint #TInsertOneIntoRegisterAtPoint
  Mov r15, 0x100;                                                               # Given a register with a single one in it indicating the desired position,
  Mov r14, 0xFFDC;                                                              # Insert a zero into the register at that position shifting the bits above that position up left one to make space for the new zero.
  Mov r13, 0xF03F;
  PrintOutRegisterInHex         r14, r15;
  InsertZeroIntoRegisterAtPoint r15, r14;
  PrintOutRegisterInHex r14;
  Or r14, r15;                                                                  # Replace the inserted zero with a one
  PrintOutRegisterInHex r14;
  InsertOneIntoRegisterAtPoint r15, r13;
  PrintOutRegisterInHex r13;
  ok Assemble(debug => 0, eq => <<END, avx512=>0);
   r14: .... .... .... FFDC
   r15: .... .... .... .1..
   r14: .... .... ...1 FEDC
   r14: .... .... ...1 FFDC
   r13: .... .... ...1 E13F
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::setOrClearTreeBits
  my $b = CreateArea;
  my $t = $b->CreateTree;

  Mov r15, 8;
  $t->setTreeBit  (31, r15); PrintOutRegisterInHex 31;
  $t->isTree      (31, r15); PrintOutZF;

  Mov r15, 16;
  $t->isTree      (31, r15); PrintOutZF;
  $t->setTreeBit  (31, r15); PrintOutRegisterInHex 31;
  $t->clearTreeBit(31, r15); PrintOutRegisterInHex 31;
  $t->isTree      (31, r15); PrintOutZF;

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
 zmm31: .... .... ...8 ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
ZF=0
ZF=1
 zmm31: .... .... ..18 ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm31: .... .... ...8 ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
ZF=0
END
 }

#latest:
if (00) {                                                                       #TNasm::X86::Tree::insertTreeAndReload #TNasm::X86::Tree::Reload  #TNasm::X86::Tree::findAndReload
  my $L = K(loop, 4);
  my $b = CreateArea;
  my $T = $b->CreateTree;
  my $t = $T->describeTreereload;

  $L->for(sub
   {my ($i, $start, $next, $end) = @_;
    $t->insertTreeAndReload($i);
    $t->first->outNL;
   });

  $t->insert($L, $L*2);

  my $f = $T->reload;
  $L->for(sub
   {my ($i, $start, $next, $end) = @_;
    $f->findAndReload($i);
    $i->out('i: '); $f->found->out('  f: '); $f->data->out('  d: '); $f->subTree->outNL('  s: ');
   });
  $f->find($L);
  $L->out('N: '); $f->found->out('  f: '); $f->data->out('  d: ');   $f->subTree->outNL('  s: ');

  ok Assemble(debug => 0, eq => <<END, avx512=>0);
first: 0000 0000 0000 0098
first: 0000 0000 0000 0118
first: 0000 0000 0000 0198
first: 0000 0000 0000 0218
i: 0000 0000 0000 0000  f: 0000 0000 0000 0001  d: 0000 0000 0000 0098  s: 0000 0000 0000 0001
i: 0000 0000 0000 0001  f: 0000 0000 0000 0001  d: 0000 0000 0000 0118  s: 0000 0000 0000 0001
i: 0000 0000 0000 0002  f: 0000 0000 0000 0001  d: 0000 0000 0000 0198  s: 0000 0000 0000 0001
i: 0000 0000 0000 0003  f: 0000 0000 0000 0001  d: 0000 0000 0000 0218  s: 0000 0000 0000 0001
N: 0000 0000 0000 0004  f: 0000 0000 0000 0001  d: 0000 0000 0000 0008  s: 0000 0000 0000 0000
END
 }

#latest:
if (1) {                                                                        # Print empty tree
  my $b = CreateArea;
  my $t = $b->CreateTree;
  $t->dump("AAAA");

  ok Assemble(debug => 0, eq => <<END, avx512=>1);
AAAA
- empty
END
 }

#latest:
if (0) {                                                                        # An example of using sigaction in x86 and x64 assembler code.  Linux on x86 requires not only a signal handler but a signal trampoline.  The following code shows how to set up a signal and its associated trampoline using sigaction or rt_sigaction.
  my $end   = Label;
  Jmp $end;                                                                     # Jump over subroutine definition
  my $start = SetLabel;
  Enter 0, 0;                                                                   # Inline code of signal handler
  Mov r15, rbp;                                                                 # Preserve the new stack frame
  Mov rbp, "[rbp]";                                                             # Restore our last stack frame
  PrintOutTraceBack '';                                                         # Print our trace back
  Mov rbp, r15;                                                                 # Restore supplied stack frame
  Exit(0);                                                                      # Exit so we do not trampoline. Exit with code zero to show that the program is functioning correctly, else L<Assemble> will report an error.
  Leave;
  Ret;
  SetLabel $end;

  Mov r15, 0;                                                                   # Push sufficient zeros onto the stack to make a struct sigaction as described in: https://www.man7.org/linux/man-pages/man2/sigaction.2.html
  Push r15 for 1..16;

  Mov r15, $start;                                                              # Actual signal handler
  Mov "[rsp]", r15;                                                             # Show as signal handler
  Mov "[rsp+0x10]", r15;                                                        # Add as trampoline as well - which is fine because we exit in the handler so this will never be called
  Mov r15, 0x4000000;                                                           # Mask to show we have a trampoline which is, apparently, required on x86
  Mov "[rsp+0x8]", r15;                                                         # Confirm we have a trampoline

  Mov rax, 13;                                                                  # Sigaction from "kill -l"
  Mov rdi, 11;                                                                  # Confirmed SIGSEGV = 11 from kill -l and tracing with sde64
  Mov rsi, rsp;                                                                 # Sigaction structure on stack
  Mov rdx, 0;                                                                   # Confirmed by trace
  Mov r10, 8;                                                                   # Found by tracing "signal.c" with sde64 it is the width of the signal set and mask. "signal.c" is reproduced below.
  Syscall;
  Add rsp, 128;

  my $s = Subroutine                                                            # Subroutine that will cause an error to occur to force a trace back to be printed
   {Mov r15, 0;
    Mov r15, "[r15]";                                                           # Try to read an unmapped memory location
   } [qw(in)], name => 'sub that causes a segv';                                # The name that will appear in the trace back

  $s->call(K(in, 42));

  ok Assemble(debug => 0, keep2 => 'signal', avx512=>0, eq => <<END, avx512=>0);         # Cannot use the emulator because it does not understand signals

Subroutine trace back, depth:  1
0000 0000 0000 002A    sub that causes a segv

END

# /var/isde/sde64 -mix -ptr-check -debugtrace -- ./signal
##include <stdlib.h>
##include <stdio.h>
##include <signal.h>
##include <string.h>
##include <unistd.h>
#
#void handle_sigint(int sig)
# {exit(sig);
# }
#
#int main(void)
# {struct sigaction s;
#  memset(&s, 0, sizeof(s));
#  s.sa_sigaction = (void *)handle_sigint;
#
#  long a = 0xabcdef;
#  sigaction(SIGSEGV, &s, 0);
#  long *c = 0; *c = a;
# }
#
# gcc -finput-charset=UTF-8 -fmax-errors=7 -rdynamic -Wall -Wextra -Wno-unused-function -o signal signal.c  && /var/isde/sde64 -mix -ptr-check -debugtrace  -- ./signal; echo $?;
 }

#latest:
if (0) {                                                                        #TOnSegv
  OnSegv();                                                                     # Request a trace back followed by exit on a segv signal.

  my $t = Subroutine                                                            # Subroutine that will cause an error to occur to force a trace back to be printed
   {Mov r15, 0;
    Mov r15, "[r15]";                                                           # Try to read an unmapped memory location
   } [qw(in)], name => 'sub that causes a segv';                                # The name that will appear in the trace back

  $t->call(K(in, 42));

  ok Assemble(debug => 0, keep2 => 'signal', avx512=>0, eq => <<END, avx512=>0);         # Cannot use the emulator because it does not understand signals

Subroutine trace back, depth:  1
0000 0000 0000 002A    sub that causes a segv

END
 }

#latest:
if (1) {                                                                        # R11 being disturbed by syscall 1
  Push 0x0a61;                                                                  # A followed by new line on the stack
  Mov  rax, rsp;
  Mov  rdx, 2;                                                                  # Length of string
  Mov  rsi, rsp;                                                                # Address of string
  Mov  rax, 1;                                                                  # Write
  Mov  rdi, 1;                                                                  # File descriptor
  Syscall;
  Pushfq;
  Pop rax;
  PrintOutRegisterInHex rax, r11;
  ok Assemble(debug => 0, keep2=>'z', emulator => 0, eq => <<END, avx512=>0);
a
   rax: .... .... .... .2.2
   r11: .... .... .... .212
END
 }

#latest:
if (0) {                                                                        # Print the utf8 string corresponding to a lexical item
  PushR zmm0, zmm1, rax, 14, 15;
  Sub rsp, RegisterSize xmm0;;
  Mov "dword[rsp+0*4]", 0x0600001A;
  Mov "dword[rsp+1*4]", 0x0600001B;
  Mov "dword[rsp+2*4]", 0x05000001;
  Mov "dword[rsp+3*4]", 0x0600001B;
  Vmovdqu8 zmm0, "[rsp]";
  Add rsp, RegisterSize zmm0;

  Pextrw rax,  xmm0, 1;                                                         # Extract lexical type of first element
  Vpbroadcastw zmm1, ax;                                                        # Broadcast
  Vpcmpeqw k0, zmm0, zmm1;                                                      # Check extent of first lexical item up to 16
  Shr rax, 8;                                                                   # Lexical type in lowest byte

  Mov r15, 0x55555555;                                                          # Set odd positions to one where we know the match will fail
  Kmovq k1, r15;
  Korq k2, k0, k1;                                                              # Fill in odd positions

  Kmovq r15, k2;
  Not r15;                                                                      # Swap zeroes and ones
  Tzcnt r14, r15;                                                               # Trailing zero count is a factor two too big
  Shr r14, 1;                                                                   # Normalized count of number of characters int name

  Mov r15, 0xffff;                                                              # Zero out lexical type
  Vpbroadcastd zmm1, r15d;                                                      # Broadcast
  Vpandd zmm1, zmm0, zmm1;                                                      # Remove lexical type to leave index into alphabet

  Cmp rax, 6;                                                                   # Test for variable
  IfEq
  Then
   {my $va = Rutf8 "\x{1D5D4}\x{1D5D5}\x{1D5D6}\x{1D5D7}\x{1D5D8}\x{1D5D9}\x{1D5DA}\x{1D5DB}\x{1D5DC}\x{1D5DD}\x{1D5DE}\x{1D5DF}\x{1D5E0}\x{1D5E1}\x{1D5E2}\x{1D5E3}\x{1D5E4}\x{1D5E5}\x{1D5E6}\x{1D5E7}\x{1D5E8}\x{1D5E9}\x{1D5EA}\x{1D5EB}\x{1D5EC}\x{1D5ED}\x{1D5EE}\x{1D5EF}\x{1D5F0}\x{1D5F1}\x{1D5F2}\x{1D5F3}\x{1D5F4}\x{1D5F5}\x{1D5F6}\x{1D5F7}\x{1D5F8}\x{1D5F9}\x{1D5FA}\x{1D5FB}\x{1D5FC}\x{1D5FD}\x{1D5FE}\x{1D5FF}\x{1D600}\x{1D601}\x{1D602}\x{1D603}\x{1D604}\x{1D605}\x{1D606}\x{1D607}\x{1D756}\x{1D757}\x{1D758}\x{1D759}\x{1D75A}\x{1D75B}\x{1D75C}\x{1D75D}\x{1D75E}\x{1D75F}\x{1D760}\x{1D761}\x{1D762}\x{1D763}\x{1D764}\x{1D765}\x{1D766}\x{1D767}\x{1D768}\x{1D769}\x{1D76A}\x{1D76B}\x{1D76C}\x{1D76D}\x{1D76E}\x{1D76F}\x{1D770}\x{1D771}\x{1D772}\x{1D773}\x{1D774}\x{1D775}\x{1D776}\x{1D777}\x{1D778}\x{1D779}\x{1D77A}\x{1D77B}\x{1D77C}\x{1D77D}\x{1D77E}\x{1D77F}\x{1D780}\x{1D781}\x{1D782}\x{1D783}\x{1D784}\x{1D785}\x{1D786}\x{1D787}\x{1D788}\x{1D789}\x{1D78A}\x{1D78B}\x{1D78C}\x{1D78D}\x{1D78E}\x{1D78F}";
    V(loop => r14)->for(sub                                                     # Write each letter out from its position on the stack
     {my ($index, $start, $next, $end) = @_;                                    # Execute body
      $index->setReg(14);                                                       # Index stack
      ClearRegisters r15;
      Mov r15b, "[rsp+4*r14]";                                                  # Load alphabet offset from stack
      Shl r15, 2;                                                               # Each letter is 4 bytes wide in utf8
      Mov r14, $va;                                                             # Alphabet address
      Mov r14d, "[r14+r15]";                                                    # Alphabet letter as utf8
      PushR 14;                                                                 # Utf8 is on the stack and it is 4 bytes wide
      Mov rax, rsp;
      Mov rdi, 4;
      PrintOutMemory;                                                           # Print letter from stack
      PopR;
     });
    PrintOutNL;
   };

  PopR;

  ok Assemble(avx512=>1, debug => 0, eq => "\n");
 }

#latest:
if (1) {                                                                        #TNasm::X86::Variable::outCStringNL
  my $s = Rutf8 '';
  V(address => $s)->outCStringNL;

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);

END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Variable::printOutMemoryInHexNL
  my $u = Rd(ord(''), ord(''), ord(''), ord(''));
  Mov rax, $u;
  my $address = V address=>rax;
  $address->printOutMemoryInHexNL(K size => 16);

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
70D7 .1.. 71D7 .1..  72D7 .1.. 73D7 .1..
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Variable::printOutMemoryInHexNL
  my $v = V var => 2;

  If  $v == 0, Then {Mov rax, 0},
  Ef {$v == 1} Then {Mov rax, 1},
  Ef {$v == 2} Then {Mov rax, 2},
               Else {Mov rax, 3};
  PrintOutRegisterInHex rax;
  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
   rax: .... .... .... ...2
END
 }

#latest:
if (1) {                                                                        #TloadRegFromMm #TsaveRegIntoMm
  Mov rax, 1; SaveRegIntoMm(zmm0, 0, rax);
  Mov rax, 2; SaveRegIntoMm(zmm0, 1, rax);
  Mov rax, 3; SaveRegIntoMm(zmm0, 2, rax);
  Mov rax, 4; SaveRegIntoMm(zmm0, 3, rax);

  LoadRegFromMm(zmm0, 0, r15);
  LoadRegFromMm(zmm0, 1, r14);
  LoadRegFromMm(zmm0, 2, r13);
  LoadRegFromMm(zmm0, 3, r12);

  PrintOutRegisterInHex ymm0, r15, r14, r13, r12;
  ok Assemble(debug => 0, trace => 1, eq => <<END, avx512=>1);
  ymm0: .... .... .... ...4  .... .... .... ...3 - .... .... .... ...2  .... .... .... ...1
   r15: .... .... .... ...1
   r14: .... .... .... ...2
   r13: .... .... .... ...3
   r12: .... .... .... ...4
END
 }

#latest:
if (1) {                                                                        #TNasm::Variable::copy  #TNasm::Variable::copyRef
  my $a = V('a', 1);
  my $r = R('r')->copyRef($a);
  my $R = R('R')->copyRef($r);

  $a->outNL;
  $r->outNL;
  $R->outNL;

  $a->copy(2);

  $a->outNL;
  $r->outNL;
  $R->outNL;

  $r->copy(3);

  $a->outNL;
  $r->outNL;
  $R->outNL;

  $R->copy(4);

  $a->outNL;
  $r->outNL;
  $R->outNL;

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
a: .... .... .... ...1
r: .... .... .... ...1
R: .... .... .... ...1
a: .... .... .... ...2
r: .... .... .... ...2
R: .... .... .... ...2
a: .... .... .... ...3
r: .... .... .... ...3
R: .... .... .... ...3
a: .... .... .... ...4
r: .... .... .... ...4
R: .... .... .... ...4
END
 }

#latest:
if (1) {                                                                        # Register expressions in parameter lists
  my $s = Subroutine
   {my ($p) = @_;
    $$p{p}->outNL;
   } parameters=>[qw(p)], name => 'test';

  $s->call(parameters=>{p => K key => 221});
  $s->call(parameters=>{p => V key => 222});
  Mov r15, 0xcc;
  $s->call(parameters=>{p => V(key => r15)});

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
p: .... .... .... ..DD
p: .... .... .... ..DE
p: .... .... .... ..CC
END
 }

#latest:
if (0) {                                                                        #TNasm::X86::Sub::dispatch
  my $p = Subroutine                                                            # Prototype subroutine to establish parameter list
   {} [qw(p)], name => 'prototype';

  my $a = Subroutine                                                            # Subroutine we are actually going to call
   {$p->variables->{p}->outNL;
   } [], name => 'actual', with => $p;

  my $d = Subroutine                                                            # Dispatcher
   {my ($p, $s) = @_;
    $a->dispatch;
    PrintOutStringNL "This should NOT happen!";
   } [], name => 'dispatch', with => $p;

  $d->call(p => 0xcc);
  PrintOutStringNL "This should happen!";

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
p: 0000 0000 0000 00CC
This should happen!
END
 }

#latest:
if (0) {                                                                        #TNasm::X86::Sub::dispatchV
  my $s = Subroutine                                                            # Containing sub
   {my ($parameters, $sub) = @_;

    my $p = Subroutine                                                          # Prototype subroutine with cascading parameter lists
     {} [qw(q)], with => $sub, name => 'prototype';

    my $a = Subroutine                                                          # Subroutine we are actually going to call with extended parameter list
     {$p->variables->{p}->outNL;
      $p->variables->{q}->outNL;
     } [], name => 'actual', with => $p;

    my $d = Subroutine                                                          # Dispatcher
     {my ($p, $s) = @_;
      $a->dispatchV($a->V);
      PrintOutStringNL "This should NOT happen!";
     } [], name => 'dispatch', with => $p;

    $d->call(q => 0xdd) ;                                                       # Extend cascading parameter list
   } [qw(p)], name => 'outer';

  $s->call(p => 0xcc);                                                          # Start cascading parameter list
  PrintOutStringNL "This should happen!";

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
p: 0000 0000 0000 00CC
q: 0000 0000 0000 00DD
This should happen!
END
 }

#latest:
if (0) {                                                                        #TNasm::X86::CreateQuarks #TNasm::X86::Quarks::put #TNasm::X86::Quarks::putSub #TNasm::X86::Quarks::dump #TNasm::X86::Quarks::subFromQuarkViaQuarks #TNasm::X86::Quarks::subFromQuarkNumber #TNasm::X86::Quarks::subFromShortString #TNasm::X86::Quarks::callSubFromShortString
  my $s = Subroutine33
   {my ($p, $s) = @_;
    PrintOutString "SSSS";
    $$p{p}->setReg(15);
    PrintOutRegisterInHex r15;
   } [qw(p)], name => 'ssss';

  my $t = Subroutine33
   {my ($p, $s) = @_;
    PrintOutString "TTTT";
    $$p{p}->setReg(15);
    PrintOutRegisterInHex r15;
   } [], name => 'tttt', with => $s;

  my $A = CreateArea;

  my $Q  = $A->CreateQuarks;
           $Q->put('aaaa');
           $Q->put('bbbb');
  my $Qs = $Q->put('ssss');
  my $Qt = $Q->put('tttt');

  my $q  = $A->CreateQuarks;
  my $qs = $q->putSub('ssss', $s);
  my $qt = $q->putSub('tttt', $t);

  PrintOutStringNL "Quarks";   $Q->dump;
  PrintOutStringNL "Subs";     $q->dump;

  $q->subFromQuarkViaQuarks($Q, $Qs)->outNL;
  $q->subFromQuarkViaQuarks($Q, $Qt)->outNL;
  $q->subFromQuarkNumber($qs)->outNL;
  $q->subFromQuarkNumber($qt)->outNL;

  my $cs = $q->subFromQuarkNumber($qs);
  $s->via($cs, p => 1);
  my $ct = $q->subFromQuarkNumber($qt);
  $s->via($ct, p => 2);

  $q->callSubFromQuarkNumber   (    $s, $qs, p => 0x11);
  $q->callSubFromQuarkNumber   (    $s, $qt, p => 0x22);
  $q->callSubFromQuarkViaQuarks($Q, $s, $Qs, p => 0x111);
  $q->callSubFromQuarkViaQuarks($Q, $s, $Qt, p => 0x222);

  if (1)
   {my $s = CreateShortString(0);
       $s->loadConstantString("ssss");
    $q->subFromShortString($s)->outNL;
   }

  if (1)
   {my $s = CreateShortString(0);
       $s->loadConstantString("ssss");
    $q->callSubFromShortString($t, $s, p => 3);
   }

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
Quarks
Quark : 0000 0000 0000 0000 => 0000 0000 0000 00D8 == 0000 00D8 0000 00D8   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0061 6161 6104
Quark : 0000 0000 0000 0001 => 0000 0000 0000 0198 == 0000 0198 0000 0198   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0062 6262 6204
Quark : 0000 0000 0000 0002 => 0000 0000 0000 01D8 == 0000 01D8 0000 01D8   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0073 7373 7304
Quark : 0000 0000 0000 0003 => 0000 0000 0000 0218 == 0000 0218 0000 0218   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0074 7474 7404
Subs
Quark : 0000 0000 0000 0000 => 0000 0000 0000 0318 == 0000 0318 0000 0318   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0073 7373 7300   0000 0000 4010 090C
Quark : 0000 0000 0000 0001 => 0000 0000 0000 03D8 == 0000 03D8 0000 03D8   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0000 0000 0000   0000 0074 7474 7400   0000 0000 4013 870C
sub: 0000 0000 0040 1009
sub: 0000 0000 0040 1387
sub: 0000 0000 0040 1009
sub: 0000 0000 0040 1387
SSSS   r15: 0000 0000 0000 0001
TTTT   r15: 0000 0000 0000 0002
SSSS   r15: 0000 0000 0000 0011
TTTT   r15: 0000 0000 0000 0022
SSSS   r15: 0000 0000 0000 0111
TTTT   r15: 0000 0000 0000 0222
sub: 0000 0000 0040 1009
SSSS   r15: 0000 0000 0000 0003
END
 }

#latest:
if (11) {                                                                       #TNasm::X86::Variable::clone
  my $a = V('a', 1);
  my $b = $a->clone('a');

  $_->outNL for $a, $b;

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
a: .... .... .... ...1
a: .... .... .... ...1
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::ClassifyWithInRangeAndSaveWordOffset Nasm::X86::Variable::loadZmm
  my $l = V('low',   Rd(2, 7, (0) x 14));
  my $h = V('high' , Rd(3, 9, (0) x 14));
  my $o = V('off',   Rd(2, 5, (0) x 14));
  my $u = V('utf32', Dd(2, 3, 7, 8, 9, (0) x 11));


  $l->loadZmm(0);
  $h->loadZmm(1);
  $o->loadZmm(2);

  ClassifyWithInRangeAndSaveWordOffset($u, V('size', 5), V('classification', 7));
  $u->loadZmm(3);

  PrintOutRegisterInHex zmm 0..3;

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>1);
  zmm0: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... ...7 .... ...2
  zmm1: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... ...9 .... ...3
  zmm2: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... ...5 .... ...2
  zmm3: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .7.. ...4 - .7.. ...3 .7.. ...2  .7.. ...1 .7.. ....
END
 }

#latest:
if (1) {                                                                        #TPrintOutRaxInDecNL #TPrintOutRaxRightInDec
  my $w = V width => 12;

  Mov rax, 0;
  PrintOutRaxRightInDecNL $w;

  Mov rax, 0x2a;
  PrintOutRaxRightInDecNL $w;

  Mov rax, 1;
  PrintOutRaxRightInDecNL $w;

  Mov rax, 255;
  PrintOutRaxRightInDecNL $w;

  Mov rax, 123456;
  PrintOutRaxRightInDecNL $w;

  Mov rax, 1234567890;
  PrintOutRaxRightInDecNL $w;

  Mov rax, 0x2;
  Shl rax, 16;
  Mov rdx, 0xdfdc;
  Or rax, rdx;
  Shl rax, 16;
  Mov rdx, 0x1c35;
  Or rax, rdx;
  PrintOutRaxRightInDecNL $w;

# 1C BE99 1A14
  Mov rax, 0x1c;
  Shl rax, 16;
  Mov rdx, 0xbe99;
  Or rax, rdx;
  Shl rax, 16;
  Mov rdx, 0x1a14;
  Or rax, rdx;
  PrintOutRaxInDecNL;

# 2 EE33 3961
  Mov rax, 0x2;
  Shl rax, 16;
  Mov rdx, 0xee33;
  Or rax, rdx;
  Shl rax, 16;
  Mov rdx, 0x3961;
  Or rax, rdx;
  PrintOutRaxRightInDecNL $w;

  ok Assemble avx512=>0, eq => <<END;
           0
          42
           1
         255
      123456
  1234567890
 12345678901
123456789012
 12586269025
END
 }

#latest:
if (0) {                                                                        #TNasm::X86::Variable::call Create a library file and call the code in the library file.
  my $l = "aaa.so";
  Mov rax, 0x12345678;
  Ret;

  ok Assemble library => $l;                                                    # Create the library file
  ok -e $l;

  my ($address, $size) = ReadFile $l;                                           # Read library file into memory

  Mov rax, 0;
  PrintOutRaxInHexNL;

  $address->call;                                                               # Call code in memory loaded from library file

  PrintOutRaxInHexNL;                                                           # Print value set in library

  ok Assemble avx512=>1, eq =><<END;
.... .... .... ....
.... .... 1234 5678
END
  unlink $l;
 }

#latest:
if (0) {
  unlink my $l = "aaa.so";

  PrintOutRaxInDecNL;
  Ret;
  ok Assemble library => $l;                                                    # Create the library file

  my ($address, $size) = ReadFile $l;                                           # Read library file into memory

  Mov rax, 42;
  $address->call;                                                               # Call code in memory loaded from library file

  ok Assemble avx512=>1, eq =><<END;
42
END
  unlink $l;
 }

#latest:
if (0) {
  unlink my $l = "aaa.so";

  PrintOutRaxInHexNL;
  Ret;
  ok Assemble library => $l;                                                    # Create the library file

  my ($address, $size) = ReadFile $l;                                           # Read library file into memory

  Mov rax, 42;
  $address->call;                                                               # Call code in memory loaded from library file

  ok Assemble avx512=>1, eq =><<END;
.... .... .... ..2A
END
  unlink $l;
 }

#latest:
if (0) {
  unlink my $l = "aaa.so";
  my $N = 11;
  V(n => $N)->for(sub
   {my ($index, $start, $next, $end) = @_;
    $index->outNL;
    Inc rax;
   });
  Ret;
  ok Assemble library => $l;                                                    # Create the library file

  my ($address, $size) = ReadFile $l;                                           # Read library file into memory
  Mov rax, 0;
  $address->call;                                                               # Call code in memory loaded from library file
  PrintOutRaxInDecNL;

  ok Assemble avx512=>1, eq => <<END;
index: .... .... .... ....
index: .... .... .... ...1
index: .... .... .... ...2
index: .... .... .... ...3
index: .... .... .... ...4
index: .... .... .... ...5
index: .... .... .... ...6
index: .... .... .... ...7
index: .... .... .... ...8
index: .... .... .... ...9
index: .... .... .... ...A
11
END
  unlink $l;
 }

#latest:
if (0) {
  unlink my $l = "aaa.so";
  my $N = 21;
  my $q = Rq($N);
  Mov rax, "[$q]";
  Ret;
  ok Assemble library => $l;                                                    # Create the library file


  my ($address, $size) = ReadFile $l;                                           # Read library file into memory
  Mov rax, 0;
  $address->call;                                                               # Call code in memory loaded from library file
  PrintOutRaxInDecNL;

  ok Assemble avx512=>1, eq => <<END;
$N
END
  unlink $l;
 }

#latest:
if (0) {
  unlink my $l = "library";                                                     # The name of the file containing the library

  my @s = qw(inc dup put);                                                      # Subroutine names
  my %s = map
   {my $l = Label;                                                              # Start label for subroutine
    my  $o = "qword[rsp-".(($_+1) * RegisterSize rax)."]";                      # Position of subroutine on stack
    Mov $o, $l.'-$$';                                                           # Put offset of subroutine on stack
    Add $o, r15;                                                                # The library must be called via r15 to convert the offset to the address of each subroutine

    $s[$_] => genHash("NasmX86::Library::Subroutine",                           # Subroutine definitions
      number  => $_ + 1,                                                        # Number of subroutine from 1
      label   => $l,                                                            # Label of subroutine
      name    => $s[$_],                                                        # Name of subroutine
      call    => undef,                                                         # Perl subroutine to call assembler subroutine
   )} keys @s;

  Ret;

  sub NasmX86::Library::Subroutine::gen($$)                                     # Write the code of a subroutine
   {my ($sub, $code) = @_;                                                      # Subroutine definition, asssociated code as a sub
    SetLabel $sub->label;                                                       # Start label
    &$code;                                                                     # Code of subroutine
    Ret;                                                                        # Return from sub routine
   }

  $s{inc}->gen(sub {Inc rax});                                                  # Increment rax
  $s{dup}->gen(sub {Shl rax, 1});                                               # Double rax
  $s{put}->gen(sub {PrintOutRaxInDecNL});                                       # Print rax in decimal

  ok Assemble library => $l;                                                    # Create the library file

  my ($address, $size) = ReadFile $l;                                           # Read library file into memory
  $address->call(r15);                                                          # Load addresses of subroutines onto stack

  for my $s(@s{@s})                                                             # Each subroutine
   {Mov r15, "[rsp-".(($s->number + 1) * RegisterSize rax)."]";                 # Address of subroutine in this process
    $s->call = V $s->name => r15;                                               # Address of subroutine in this process from stack as a variable
   }
  my ($inc, $dup, $put) = map {my $c = $_->call; sub {$c->call}} @s{@s};        # Call subroutine via variable - perl bug because $_ by  itself is not enough

   Mov rax, 1; &$put;
#  &$inc;      &$put;                                                           # Use the subroutines from the library
#  &$dup;      &$put;
#  &$dup;      &$put;
#  &$inc;      &$put;

  ok Assemble eq => <<END, avx512=>0;
1
2
4
8
9
END
  unlink $l;
 }

#latest:
if (0) {

  my $library = CreateLibrary                                                   # Library definition
   (subroutines =>                                                              # Sub routines in libray
     {inc => sub {Inc rax},                                                     # Increment rax
      dup => sub {Shl rax, 1},                                                  # Double rax
      put => sub {PrintOutRaxInDecNL},                                          # Print rax in decimal
     },
    file => q(library),
   );

  my ($dup, $inc, $put) = $library->load;                                       # Load the library into memory

  Mov rax, 1; &$put;
  &$inc;      &$put;                                                            # Use the subroutines from the library
  &$dup;      &$put;
  &$dup;      &$put;
  &$inc;      &$put;

  ok Assemble eq => <<END, avx512=>0;
1
2
4
8
9
END
  unlink $$library{file};
 }

#latest:
if (1) {                                                                        #TreadChar #TPrintOutRaxAsChar
  my $e = q(readChar);

  ForEver
   {my ($start, $end) = @_;
    ReadChar;
    Cmp rax, 0xa;
    Jle $end;
    PrintOutRaxAsChar;
    PrintOutRaxAsChar;
   };
  PrintOutNL;

  Assemble keep => $e;

  is_deeply qx(echo "ABCDCBA" | ./$e), <<END;
AABBCCDDCCBBAA
END
  unlink $e;
 }

#latest:
if (1) {                                                                        #TPrintOutRaxAsTextNL
  my $t = Rs('abcdefghi');
  Mov rax, $t;
  Mov rax, "[rax]";
  PrintOutRaxAsTextNL;
  ok Assemble eq => <<END, avx512=>0;
abcdefgh
END
}

#latest:
if (1) {                                                                        #TNasm::X86::Variable::outCStringNL #TNasm::X86::Variable::outInDecNL;
  my $e = q(parameters);

  (V string => "[rbp+8]")->outInDecNL;
  (V string => "[rbp+16]")->outCStringNL;
  (V string => "[rbp+24]")->outCStringNL;
  (V string => "[rbp+32]")->outCStringNL;
  (V string => "[rbp+40]")->outCStringNL;
  (V string => "[rbp+48]")->outInDecNL;

  (V string => "[rbp+8]")->for(sub
   {my ($index, $start, $next, $end) = @_;
    $index->setReg(rax);
    Inc rax;
    PrintOutRaxInDec;
    Inc rax;
    PrintOutString " : ";
    Shl rax, 3;
    (V string => "[rbp+rax]")->outCStringNL;
   });

  Assemble keep => $e;

  is_deeply scalar(qx(./$e AaAaAaAaAa BbCcDdEe 123456789)), <<END;
string: 4
./parameters
AaAaAaAaAa
BbCcDdEe
123456789
string: 0
1 : ./parameters
2 : AaAaAaAaAa
3 : BbCcDdEe
4 : 123456789
END

  unlink $e;
 }

#latest:
if (1) {                                                                        #TPrintOutRaxAsTextNL
  V( loop => 16)->for(sub
   {my ($index, $start, $next, $end) = @_;
    $index->setReg(rax);
    Add rax, 0xb0;   Shl rax, 16;
    Mov  ax, 0x9d9d; Shl rax, 8;
    Mov  al, 0xf0;
    PrintOutRaxAsText;
   });
  PrintOutNL;

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);

END
 }

#latest:
if (1) {                                                                        #TPrintOutRaxRightInDec #TPrintOutRaxRightInDecNL
  Mov rax, 0x2a;
  PrintOutRaxRightInDec   V width=> 4;
  Shl rax, 1;
  PrintOutRaxRightInDecNL V width=> 6;

  ok Assemble eq => <<END, avx512=>0;
  42    84
END
 }

#latest:
if (1) {                                                                        # Fibonacci numbers
  my $N = 11;                                                                   # The number of Fibonacci numbers to generate
  Mov r13, 0;                                                                   # First  Fibonacci number
  Mov r14, 1;                                                                   # Second Fibonacci
  PrintOutStringNL " i   Fibonacci";                                            # The title of the piece

  V(N => $N)->for(sub                                                           # Generate each Fibonacci number by adding the two previous ones together
   {my ($index, $start, $next, $end) = @_;
    $index->outRightInDec(V(width => 2));                                       # Index
    Mov rax, r13;
    PrintOutRaxRightInDecNL V width => 12;                                      # Fibonacci number at this index

    Mov r15, r14;                                                               # Next number is the sum of the two previous ones
    Add r15, r13;

    Mov r13, r14;                                                               # Move up
    Mov r14, r15;
   });

  ok Assemble eq => <<END, avx512=>0;
 i   Fibonacci
 0           0
 1           1
 2           1
 3           2
 4           3
 5           5
 6           8
 7          13
 8          21
 9          34
10          55
END
 }

#latest:
if (1) {                                                                        #TReadLine
  my $e = q(readLine);
  my $f = writeTempFile("hello\nworld\n");

  ReadLine;
  PrintOutRaxAsTextNL;
  ReadLine;
  PrintOutRaxAsTextNL;

  Assemble keep => $e;

  is_deeply scalar(qx(./$e < $f)), <<END;
hello
world
END
  unlink $f;
}

#latest:
if (1) {                                                                        #TReadInteger
  my $e = q(readInteger);
  my $f = writeTempFile("11\n22\n");

  ReadInteger;
  Shl rax, 1;
  PrintOutRaxInDecNL;
  ReadInteger;
  Shl rax, 1;
  PrintOutRaxInDecNL;

  Assemble keep => $e;

  is_deeply scalar(qx(./$e < $f)), <<END;
22
44
END

  unlink $e, $f;
 }

#latest:
if (1) {                                                                        #TSubroutine2
  package InnerStructure
   {use Data::Table::Text qw(:all);
    sub new($)                                                                  # Create a new structure
     {my ($value) = @_;                                                         # Value for structure variable
      describe(value => Nasm::X86::V(var => $value))
     };
    sub describe(%)                                                             # Describe the components of a structure
     {my (%options) = @_;                                                       # Options
      genHash(__PACKAGE__,
        value => $options{value},
       );
     }
   }

  package OuterStructure
   {use Data::Table::Text qw(:all);
    sub new($$)                                                                 # Create a new structure
     {my ($valueOuter, $valueInner) = @_;                                       # Value for structure variable
      describe
       (value => Nasm::X86::V(var => $valueOuter),
        inner => InnerStructure::new($valueInner),
       )
     };
    sub describe(%)                                                             # Describe the components of a structure
     {my (%options) = @_;                                                       # Options
      genHash(__PACKAGE__,
        value => $options{value},
        inner => $options{inner},
       );
     }
   }

  my $t = OuterStructure::new(42, 4);

  my $s = Subroutine
   {my ($parameters, $structures, $sub) = @_;                                   # Variable parameters, structure variables, structure copies, subroutine description

    $$structures{test}->value->setReg(rax);
    Mov r15, 84;
    $$structures{test}->value->getReg(r15);
    Mov r15, 8;
    $$structures{test}->inner->value->getReg(r15);

    $$parameters{p}->setReg(rdx);
   } parameters=>[qw(p)], structures => {test => $t}, name => 'test';

  my $T = OuterStructure::new(42, 4);
  my $V = V parameter => 21;

  $s->call(parameters=>{p => $V}, structures=>{test => $T});

  PrintOutRaxInDecNL;
  Mov rax, rdx;
  PrintOutRaxInDecNL;
  $t->value->outInDecNL;
  $t->inner->value->outInDecNL;
  $T->value->outInDecNL;
  $T->inner->value->outInDecNL;
  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
42
21
var: 42
var: 4
var: 84
var: 8
END
 }

#latest:
if (1) {
  my $s = Subroutine                                                            #TSubroutine2
   {my ($p, $s, $sub) = @_;                                                     # Variable parameters, structure variables, structure copies, subroutine description
    $$s{var}->setReg(rax);
    Dec rax;
    $$s{var}->getReg(rax);
   } structures => {var => my $v = V var => 42}, name => 'test', call => 1;

  $v->outNL;

  $s->call(structures => {var => my $V = V var => 2});
  $V->outNL;

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
var: .... .... .... ..29
var: .... .... .... ...1
END
 }

#latest:
if (1) {
  my $N = 256;
  my $t = V struct => 33;

  my $s = Subroutine                                                            #TSubroutine2
   {my ($p, $s, $sub) = @_;                                                     # Variable parameters, structure variables, structure copies, subroutine description
    SaveFirstFour;
    my $v = V var => 0;
    $v->copy($$p{i});
    $$p{o}->copy($v);
    $$p{O}->copy($$s{struct});
    $$s{struct}->copy($$s{struct} + 1);

    my $M = AllocateMemory K size => $N;                                        # Allocate memory and save its location in a variable
    $$p{M}->copy($M);
    $M->setReg(rax);
    Mov "qword[rax]", -1;
    FreeMemory $M, K size => $N;                                                # Free memory
    RestoreFirstFour;
   } structures => {struct => $t}, parameters => [qw(i o O M)], name => 'test';

  $s->call(parameters => {i => (my $i = K i => 22),
                          o => (my $o = V o =>  0),
                          O => (my $O = V O =>  0),
                          M => (my $M = V M =>  0)},
           structures => {struct => $t});
  $i->outInDecNL;
  $o->outInDecNL;
  $O->outInDecNL;
  $t->outInDecNL;

  ok Assemble(debug => 0, trace => 0, eq => <<END, avx512=>0);
i: 22
o: 22
O: 33
struct: 34
END
 }

#latest:
if (1) {                                                                        # Split a left node held in zmm28..zmm26 with its parent in zmm31..zmm29 pushing to the right zmm25..zmm23
  my $newRight = K newRight => 0x9119;                                          # Offset of new right block
  my $tree = DescribeTree(length => 3);                                         # Test with a narrow tree
  my ($RN, $RD, $RK, $LN, $LD, $LK, $PN, $PD, $PK) = 23..31;                    # Zmm names
  my $transfer = r8;

  for my $test(0..13)                                                           # Test each key position
   {PrintOutStringNL "Test $test";

    K(PK => Rd(map {($_<<28) +0x9999999} 1..15, 0))->loadZmm($PK);
    K(PD => Rd(map {($_<<28) +0x7777777} 1..15, 0))->loadZmm($PD);
    K(PN => Rd(map {($_<<28) +0x8888888} 1..15, 0))->loadZmm($PN);

    K(LK => Rd(map {($_<<28) +0x6666666} $test..15, 0..($test-1)))->loadZmm($LK);
    K(LD => Rd(map {($_<<28) +0x4444444} $test..15, 0..($test-1)))->loadZmm($LD);
    K(LN => Rd(map {($_<<28) +0x5555555} 0..15))->loadZmm($LN);

    K(RK => Rd(map {($_<<28) +0x3333333} 0..15))->loadZmm($RK);
    K(RD => Rd(map {($_<<28) +0x1111111} 0..15))->loadZmm($RD);
    K(RN => Rd(map {($_<<28) +0x2222222} 0..15))->loadZmm($RN);

    Mov $transfer, 0;                                                           # Test set of tree bits
    wRegIntoZmm $transfer, $PK, $tree->treeBits;

    Mov $transfer, 1;                                                           # Test set of parent length
    wRegIntoZmm $transfer, $PK, $tree->lengthOffset;

    Mov $transfer, 0b11011101;                                                  # Test set of tree bits in node being split
    wRegIntoZmm $transfer, $LK, $tree->treeBits;

    $tree->splitNotRoot($newRight, reverse 23..31);

    PrintOutStringNL "Parent";
    PrintOutRegisterInHex zmm reverse 29..31;

    PrintOutStringNL "Left";
    PrintOutRegisterInHex zmm reverse 26..28;

    PrintOutStringNL "Right";
    PrintOutRegisterInHex zmm reverse 23..25;
   }

  ok Assemble eq => <<END, avx512=>1;
Test 0
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  1999 9999 1666 6666
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  1777 7777 1444 4444
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 2888 8888  .... 9119 1888 8888
Left
 zmm28: F666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .666 6666
 zmm27: F444 4444 E444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 2666 6666
 zmm24: F111 1111 E444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 2444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 1
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  2666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  2444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: .666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 1666 6666
 zmm27: .444 4444 F444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 1444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 3666 6666
 zmm24: F111 1111 F444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 3444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 2
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  3666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  3444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: 1666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 2666 6666
 zmm27: 1444 4444 .444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 2444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 4666 6666
 zmm24: F111 1111 .444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 4444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 3
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  4666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  4444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: 2666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 3666 6666
 zmm27: 2444 4444 1444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 3444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 5666 6666
 zmm24: F111 1111 1444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 5444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 4
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  5666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  5444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: 3666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 4666 6666
 zmm27: 3444 4444 2444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 4444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 6666 6666
 zmm24: F111 1111 2444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 6444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 5
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  6666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  6444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: 4666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 5666 6666
 zmm27: 4444 4444 3444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 5444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 7666 6666
 zmm24: F111 1111 3444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 7444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 6
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  7666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  7444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: 5666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 6666 6666
 zmm27: 5444 4444 4444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 6444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 8666 6666
 zmm24: F111 1111 4444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 8444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 7
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  8666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  8444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: 6666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 7666 6666
 zmm27: 6444 4444 5444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 7444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 9666 6666
 zmm24: F111 1111 5444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 9444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 8
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  9666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  9444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: 7666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 8666 6666
 zmm27: 7444 4444 6444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 8444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... A666 6666
 zmm24: F111 1111 6444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... A444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 9
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  A666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  A444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: 8666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 9666 6666
 zmm27: 8444 4444 7444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 9444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... B666 6666
 zmm24: F111 1111 7444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... B444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 10
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  B666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  B444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: 9666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... A666 6666
 zmm27: 9444 4444 8444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... A444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... C666 6666
 zmm24: F111 1111 8444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... C444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 11
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  C666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  C444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: A666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... B666 6666
 zmm27: A444 4444 9444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... B444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... D666 6666
 zmm24: F111 1111 9444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... D444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 12
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  D666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  D444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: B666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... C666 6666
 zmm27: B444 4444 A444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... C444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... E666 6666
 zmm24: F111 1111 A444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... E444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
Test 13
Parent
 zmm31: .999 9999 .... ...2  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  E666 6666 1999 9999
 zmm30: .777 7777 F777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  E444 4444 1777 7777
 zmm29: .888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 .... 9119  2888 8888 1888 8888
Left
 zmm28: C666 6666 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... D666 6666
 zmm27: C444 4444 B444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... D444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  1555 5555 .555 5555
Right
 zmm25: F333 3333 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... F666 6666
 zmm24: F111 1111 B444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... F444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  3555 5555 2555 5555
END
 }

#latest:
if (1) {                                                                        # Split a root node held in zmm28..zmm26 into a parent in zmm31..zmm29 and a right node held in zmm25..zmm23
  my $newLeft   = K newLeft  => 0x9119;                                         # Offset of new left  block
  my $newRight  = K newRight => 0x9229;                                         # Offset of new right block
  my $tree      = DescribeTree(length => 7);                                    # Tree definition

  my $transfer  = r8;                                                           # Transfer register
  my ($RN, $RD, $RK, $LN, $LD, $LK, $PN, $PD, $PK) = 23..31;                    # Zmm names

  K(PK => Rd(map {($_<<28) +0x9999999} 0..15))->loadZmm($PK);
  K(PD => Rd(map {($_<<28) +0x7777777} 0..15))->loadZmm($PD);
  K(PN => Rd(map {($_<<28) +0x8888888} 0..15))->loadZmm($PN);

  K(LK => Rd(map {($_<<28) +0x6666666} 0..15))->loadZmm($LK);
  K(LD => Rd(map {($_<<28) +0x4444444} 0..15))->loadZmm($LD);
  K(LN => Rd(map {($_<<28) +0x5555555} 0..15))->loadZmm($LN);

  K(RK => Rd(map {($_<<28) +0x3333333} 0..15))->loadZmm($RK);
  K(RD => Rd(map {($_<<28) +0x1111111} 0..15))->loadZmm($RD);
  K(RN => Rd(map {($_<<28) +0x2222222} 0..15))->loadZmm($RN);

  Mov $transfer, 0b11011101;                                                    # Test set of tree bits
  wRegIntoZmm $transfer, $LK, $tree->treeBits;

  Mov $transfer, 7;                                                             # Test set of length in left keys
  wRegIntoZmm $transfer, $LK, $tree->lengthOffset;
  PrintOutStringNL "Initial Parent";
  PrintOutRegisterInHex zmm reverse 29..31;

  PrintOutStringNL "Initial Left";
  PrintOutRegisterInHex zmm reverse 26..28;

  PrintOutStringNL "Initial Right";
  PrintOutRegisterInHex zmm reverse 23..25;

  $tree->splitRoot($newLeft, $newRight, reverse 23..31);

  PrintOutStringNL "Final Parent";
  PrintOutRegisterInHex zmm reverse 29..31;

  PrintOutStringNL "Final Left";
  PrintOutRegisterInHex zmm reverse 26..28;

  PrintOutStringNL "Final Right";
  PrintOutRegisterInHex zmm reverse 23..25;

  ok Assemble eq => <<END, avx512=>1;
Initial Parent
 zmm31: F999 9999 E999 9999  D999 9999 C999 9999 - B999 9999 A999 9999  9999 9999 8999 9999 + 7999 9999 6999 9999  5999 9999 4999 9999 - 3999 9999 2999 9999  1999 9999 .999 9999
 zmm30: F777 7777 E777 7777  D777 7777 C777 7777 - B777 7777 A777 7777  9777 7777 8777 7777 + 7777 7777 6777 7777  5777 7777 4777 7777 - 3777 7777 2777 7777  1777 7777 .777 7777
 zmm29: F888 8888 E888 8888  D888 8888 C888 8888 - B888 8888 A888 8888  9888 8888 8888 8888 + 7888 8888 6888 8888  5888 8888 4888 8888 - 3888 8888 2888 8888  1888 8888 .888 8888
Initial Left
 zmm28: F666 6666 ..DD ...7  D666 6666 C666 6666 - B666 6666 A666 6666  9666 6666 8666 6666 + 7666 6666 6666 6666  5666 6666 4666 6666 - 3666 6666 2666 6666  1666 6666 .666 6666
 zmm27: F444 4444 E444 4444  D444 4444 C444 4444 - B444 4444 A444 4444  9444 4444 8444 4444 + 7444 4444 6444 4444  5444 4444 4444 4444 - 3444 4444 2444 4444  1444 4444 .444 4444
 zmm26: F555 5555 E555 5555  D555 5555 C555 5555 - B555 5555 A555 5555  9555 5555 8555 5555 + 7555 5555 6555 5555  5555 5555 4555 5555 - 3555 5555 2555 5555  1555 5555 .555 5555
Initial Right
 zmm25: F333 3333 E333 3333  D333 3333 C333 3333 - B333 3333 A333 3333  9333 3333 8333 3333 + 7333 3333 6333 3333  5333 3333 4333 3333 - 3333 3333 2333 3333  1333 3333 .333 3333
 zmm24: F111 1111 E111 1111  D111 1111 C111 1111 - B111 1111 A111 1111  9111 1111 8111 1111 + 7111 1111 6111 1111  5111 1111 4111 1111 - 3111 1111 2111 1111  1111 1111 .111 1111
 zmm23: F222 2222 E222 2222  D222 2222 C222 2222 - B222 2222 A222 2222  9222 2222 8222 2222 + 7222 2222 6222 2222  5222 2222 4222 2222 - 3222 2222 2222 2222  1222 2222 .222 2222
Final Parent
 zmm31: F999 9999 ...1 ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 3666 6666
 zmm30: F777 7777 E777 7777  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... 3444 4444
 zmm29: F888 8888 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... 9229 .... 9119
Final Left
 zmm28: F666 6666 ...5 ...3  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... 2666 6666  1666 6666 .666 6666
 zmm27: F444 4444 E444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... 2444 4444  1444 4444 .444 4444
 zmm26: F555 5555 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - 3555 5555 2555 5555  1555 5555 .555 5555
Final Right
 zmm25: F333 3333 ...5 ...3  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... 6666 6666  5666 6666 4666 6666
 zmm24: F111 1111 E444 4444  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... 6444 4444  5444 4444 4444 4444
 zmm23: F222 2222 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - 7555 5555 6555 5555  5555 5555 4555 5555
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::setTree  #TNasm::X86::Tree::clearTree #TNasm::X86::Tree::insertZeroIntoTreeBits #TNasm::X86::Tree::insertOneIntoTreeBits #TNasm::X86::Tree::getTreeBits #TNasm::X86::Tree::setTreeBits #TNasm::X86::Tree::isTree

  my $t = DescribeTree;
  Mov r8, 0b100; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
  Mov r8, 0b010; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
  Mov r8, 0b001; $t->setTreeBit(31, r8);              PrintOutRegisterInHex 31;
  Mov r8, 0b010; $t->clearTreeBit(31, r8);            PrintOutRegisterInHex 31;

                                                     $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
  Mov r8, 0b010; $t->insertZeroIntoTreeBits(31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);
  Mov r8, 0b010; $t->insertOneIntoTreeBits (31, r8); $t->getTreeBits(31, r8); V(TreeBits => r8)->outRightInBinNL(K width => 16);

  $t->getTreeBits(31, r8);
  V(TreeBits => r8)->outRightInHexNL(K width => 4);
  PrintOutRegisterInHex 31;

  Mov r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;
  Shl r8, 1; $t->isTree(31, r8); PrintOutZF;

  Not r8; $t->setTreeBits(31, r8); PrintOutRegisterInHex 31;

  ok Assemble eq => <<END, avx512=>1;
 zmm31: .... .... ...4 ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm31: .... .... ...6 ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm31: .... .... ...7 ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm31: .... .... ...5 ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
             101
            1001
           10011
  13
 zmm31: .... .... ..13 ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
ZF=0
ZF=0
ZF=1
ZF=1
ZF=0
ZF=1
ZF=1
ZF=1
ZF=1
ZF=1
ZF=1
ZF=1
ZF=1
ZF=1
ZF=1
ZF=1
 zmm31: .... .... 3FFF ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::allocBlock #TNasm::X86::Tree::putBlock #TNasm::X86::Tree::getBlock #TNasm::X86::Tree::root
  my $a = CreateArea;
  my $t = $a->CreateTree;
  my $b = $t->allocBlock(31, 30, 29);
  K(data => 0x33)->dIntoZ(31, 4);
  $t->lengthIntoKeys(31, K length =>0x9);
  $t->putBlock($b, 31, 30, 29);
  $t->getBlock($b, 25, 24, 23);
  PrintOutRegisterInHex 25;
  $t->lengthFromKeys(25)->outNL;


  $t->firstFromMemory(28);
  $t->incSizeInFirst (28);
  $t->rootIntoFirst  (28, K value => 0x2222);
  $t->root           (28, K value => 0x2222);  PrintOutZF;
  $t->root           (28, K value => 0x2221);  PrintOutZF;
  $t->root           (28, K value => 0x2222);  PrintOutZF;
  $t->firstIntoMemory(28);

  $t->first->outNL;
  $b->outNL;
  $a->dump("1111");
  PrintOutRegisterInHex 31, 30, 29, 28;


  my $l = $t->leafFromNodes(29); If $l > 0, Then {PrintOutStringNL "29 Leaf"}, Else {PrintOutStringNL "29 Branch"};
  my $r = $t->leafFromNodes(28); If $r > 0, Then {PrintOutStringNL "28 Leaf"}, Else {PrintOutStringNL "28 Branch"};


  ok Assemble eq => <<END, avx512=>1;
 zmm25: .... ..C0 .... ...9  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... ..33 .... ....
b at offset 56 in zmm25: .... .... .... ...9
ZF=1
ZF=0
ZF=1
first: .... .... .... ..40
address: .... .... .... ..80
1111
Area     Size:     4096    Used:      320
.... .... .... .... | __10 ____ ____ ____  40.1 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 2222 ____ ____ ____  .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | ____ ____ 33__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .9__ ____ C0__ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ __.1 ____
 zmm31: .... ..C0 .... ...9  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... ..33 .... ....
 zmm30: .... .1.. .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm29: .... ..40 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm28: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ...1  .... .... .... 2222
29 Leaf
28 Branch
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::indexEq
  my $tree = DescribeTree(length => 7);

  my $K = 31;

  K(K => Rd(0..15))->loadZmm($K);
  $tree->lengthIntoKeys($K, K length => 13);

  K(loop => 16)->for(sub
   {my ($index, $start, $next, $end) = @_;
    my $f = $tree->indexEq ($index, $K);
    $index->outRightInDec(K width =>  2);
    $f    ->outRightInBin(K width => 14);
    PrintOutStringNL " |"
   });

  ok Assemble eq => <<END, avx512=>1;
 0             1 |
 1            10 |
 2           100 |
 3          1000 |
 4         10000 |
 5        100000 |
 6       1000000 |
 7      10000000 |
 8     100000000 |
 9    1000000000 |
10   10000000000 |
11  100000000000 |
12 1000000000000 |
13               |
14               |
15               |
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::insertionPoint
  my $tree = DescribeTree(length => 7);

  my $K = 31;

  K(K => Rd(map {2*$_} 1..16))->loadZmm($K);
  $tree->lengthIntoKeys($K, K length => 13);

  K(loop => 32)->for(sub
   {my ($index, $start, $next, $end) = @_;
    my $f = $tree->insertionPoint($index, $K);
    $index->outRightInDec(K width =>  2);
    $f    ->outRightInBin(K width => 16);
    PrintOutStringNL " |"
   });

  ok Assemble eq => <<END, avx512=>1;
 0               1 |
 1               1 |
 2              10 |
 3              10 |
 4             100 |
 5             100 |
 6            1000 |
 7            1000 |
 8           10000 |
 9           10000 |
10          100000 |
11          100000 |
12         1000000 |
13         1000000 |
14        10000000 |
15        10000000 |
16       100000000 |
17       100000000 |
18      1000000000 |
19      1000000000 |
20     10000000000 |
21     10000000000 |
22    100000000000 |
23    100000000000 |
24   1000000000000 |
25   1000000000000 |
26  10000000000000 |
27  10000000000000 |
28  10000000000000 |
29  10000000000000 |
30  10000000000000 |
31  10000000000000 |
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Variable::dFromPointInZ
  my $tree = DescribeTree(length => 7);

  my $K = 31;

  K(K => Rd(0..15))->loadZmm($K);

  PrintOutRegisterInHex zmm $K;
  K( offset => 1 << 5)->dFromPointInZ($K)->outNL;

  ok Assemble eq => <<END, avx512=>1;
 zmm31: .... ...F .... ...E  .... ...D .... ...C - .... ...B .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
d: .... .... .... ...5
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::indexEq
  my $tree = DescribeTree();
  $tree->maskForFullKeyArea(7);                                                 # Mask for full key area
  PrintOutRegisterInHex k7;
  $tree->maskForFullNodesArea(7);                                               # Mask for full nodes area
  PrintOutRegisterInHex k7;
  ok Assemble eq => <<END, avx512=>1;
    k7: .... .... .... 3FFF
    k7: .... .... .... 7FFF
END
 }

#latest:
if (1) {                                                                        # Perform the insertion
  my $tree = DescribeTree();

  my $F = 31; my $K  = 30; my $D = 29;
  my $IK = K insert  => 0x44;
  my $ID = K insert  => 0x55;
  my $tb = K treebit => 1;                                                      # Value to insert, tree bit to insert

  K(K => Rd(0..15))->loadZmm($_) for $F, $K, $D;                                # First, keys, data
  $tree->lengthIntoKeys($K, K length => 5);                                     # Set a length
  Mov rdi, 0x3FF0;                                                              # Initial tree bits
  $tree->setTreeBits(31, rdi);                                                  # Save tree bits

  my $point = K point => 1<<3;                                                  # Show insertion point

  PrintOutStringNL "Start";
  PrintOutRegisterInHex $F, $K, $D;

  $tree->insertKeyDataTreeIntoLeaf($point, $F, $K, $D, $IK, $ID, K subTree => 1);

  PrintOutStringNL "Inserted";
  PrintOutRegisterInHex $F, $K, $D;

  $tree->overWriteKeyDataTreeInLeaf($point, $K, $D, $ID, $IK, K subTree => 0);

  PrintOutStringNL "Overwritten";
  PrintOutRegisterInHex $F, $K, $D;

  ok Assemble eq => <<END, avx512=>1;                                           # Once we know the insertion point we can add the key/data/subTree triple, increase the length and update the tree bits
Start
 zmm31: .... ...F 3FF0 ...E  .... ...D .... ...C - .... ...B .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...F .... ...5  .... ...D .... ...C - .... ...B .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm29: .... ...F .... ...E  .... ...D .... ...C - .... ...B .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
Inserted
 zmm31: .... ...F 3FF0 ...E  .... ...D .... ...C - .... ...B .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...3  .... ...1 .... ....
 zmm30: .... ...F ...8 ...6  .... ...C .... ...B - .... ...A .... ...9  .... ...8 .... ...7 + .... ...6 .... ...5  .... ...4 .... ...3 - .... ..44 .... ...2  .... ...1 .... ....
 zmm29: .... ...F .... ...E  .... ...C .... ...B - .... ...A .... ...9  .... ...8 .... ...7 + .... ...6 .... ...5  .... ...4 .... ...3 - .... ..55 .... ...2  .... ...1 .... ....
Overwritten
 zmm31: .... ...F 3FF0 ...E  .... ...D .... ...C - .... ...B .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...3  .... ...1 .... ....
 zmm30: .... ...F .... ...6  .... ...C .... ...B - .... ...A .... ...9  .... ...8 .... ...7 + .... ...6 .... ...5  .... ...4 .... ...3 - .... ..55 .... ...2  .... ...1 .... ....
 zmm29: .... ...F .... ...E  .... ...C .... ...B - .... ...A .... ...9  .... ...8 .... ...7 + .... ...6 .... ...5  .... ...4 .... ...3 - .... ..44 .... ...2  .... ...1 .... ....
END
 }

#latest:
if (1) {
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $a->dump("0000", K depth => 6);
  $t->dump("0000");

  $t->put(K(key=>1), K(data=>0x11));
  $a->dump("1111", K depth => 6);
  $t->dump("1111");

  $t->put(K(key=>2), K(data=>0x22));
  $a->dump("2222", K depth => 6);
  $t->dump("2222");

  $t->put(K(key=>3), K(data=>0x33));
  $a->dump("3333", K depth => 6);
  $t->dump("3333");

  $t->splitNode(K offset => 0x80);
  $a->dump("4444", K depth => 11);
  $t->dump("4444");

  ok Assemble eq => <<END, avx512=>1;
0000
Area     Size:     4096    Used:      128
.... .... .... .... | __10 ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... .140 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
0000
- empty
1111
Area     Size:     4096    Used:      320
.... .... .... .... | __10 ____ ____ ____  40.1 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 80__ ____ ____ ____  .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ C0__ ____
.... .... .... ..C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
1111
At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0
  Keys :    1
  Data :   17
end
2222
Area     Size:     4096    Used:      320
.... .... .... .... | __10 ____ ____ ____  40.1 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 80__ ____ ____ ____  .2__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ .2__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .2__ ____ C0__ ____
.... .... .... ..C0 | 11__ ____ 22__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
2222
At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0    1
  Keys :    1    2
  Data :   17   34
end
3333
Area     Size:     4096    Used:      320
.... .... .... .... | __10 ____ ____ ____  40.1 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 80__ ____ ____ ____  .3__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ .2__ ____  .3__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .3__ ____ C0__ ____
.... .... .... ..C0 | 11__ ____ 22__ ____  33__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
3333
At:   80                    length:    3,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0    1    2
  Keys :    1    2    3
  Data :   17   34   51
end
4444
Area     Size:     4096    Used:      704
.... .... .... .... | __10 ____ ____ ____  C0.2 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | __.2 ____ ____ ____  .3__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ C0__ ____
.... .... .... ..C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | .3__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ 80.1 ____
.... .... .... .180 | 33__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ C0.1 ____
.... .... .... .1C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2.. | .2__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ 40.2 ____
.... .... .... .240 | 22__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 80.2 ____
.... .... .... .280 | 80__ ____ 40.1 ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
4444
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :   34
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   17
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    3
      Data :   51
    end
end
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::put
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $t->put(K(key=>1), K(data=>0x11));
  $t->put(K(key=>2), K(data=>0x22));
  $t->put(K(key=>3), K(data=>0x33));
  $t->put(K(key=>4), K(data=>0x44));
  $a->dump("4444", K depth => 11);
  $t->dump("4444");

  ok Assemble eq => <<END, avx512=>1;
4444
Area     Size:     4096    Used:      704
.... .... .... .... | __10 ____ ____ ____  C0.2 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | __.2 ____ ____ ____  .4__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ C0__ ____
.... .... .... ..C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | .3__ ____ .4__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .2__ ____ 80.1 ____
.... .... .... .180 | 33__ ____ 44__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ C0.1 ____
.... .... .... .1C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2.. | .2__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ 40.2 ____
.... .... .... .240 | 22__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 80.2 ____
.... .... .... .280 | 80__ ____ 40.1 ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
4444
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :   34
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   17
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    3    4
      Data :   51   68
    end
end
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::put
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $t->put(K(key=>1), K(data=>0x11));
  $t->put(K(key=>2), K(data=>0x22));
  $t->put(K(key=>3), K(data=>0x33));
  $t->put(K(key=>4), K(data=>0x44));
  $t->put(K(key=>5), K(data=>0x55));
  $a->dump("5555",   K depth => 11);

  ok Assemble eq => <<END, avx512=>1;
5555
Area     Size:     4096    Used:      704
.... .... .... .... | __10 ____ ____ ____  C0.2 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | __.2 ____ ____ ____  .5__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ C0__ ____
.... .... .... ..C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | .3__ ____ .4__ ____  .5__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .3__ ____ 80.1 ____
.... .... .... .180 | 33__ ____ 44__ ____  55__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ C0.1 ____
.... .... .... .1C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2.. | .2__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ 40.2 ____
.... .... .... .240 | 22__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 80.2 ____
.... .... .... .280 | 80__ ____ 40.1 ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::put
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $t->put(K(key=>1), K(data=>0x11));
  $t->put(K(key=>2), K(data=>0x22));
  $t->put(K(key=>3), K(data=>0x33));
  $t->put(K(key=>4), K(data=>0x44));
  $t->put(K(key=>5), K(data=>0x55));
  $t->splitNode(K split => 0x140);
  $a->dump("6666",   K depth => 14);

  ok Assemble eq => <<END, avx512=>1;
6666
Area     Size:     4096    Used:      896
.... .... .... .... | __10 ____ ____ ____  80.3 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | __.2 ____ ____ ____  .5__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ C0__ ____
.... .... .... ..C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | .3__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ 80.1 ____
.... .... .... .180 | 33__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ C0.1 ____
.... .... .... .1C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2.. | .2__ ____ .4__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .2__ ____ 40.2 ____
.... .... .... .240 | 22__ ____ 44__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 80.2 ____
.... .... .... .280 | 80__ ____ 40.1 ____  C0.2 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2C0 | .5__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ __.3 ____
.... .... .... .3.. | 55__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ 40.3 ____
.... .... .... .340 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::put
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $t->put(K(key=>1), K(data=>0x11));
  $t->put(K(key=>2), K(data=>0x22));
  $t->put(K(key=>3), K(data=>0x33));
  $t->put(K(key=>4), K(data=>0x44));
  $t->put(K(key=>5), K(data=>0x55));
  $t->put(K(key=>6), K(data=>0x66));
  $a->dump("6666",   K depth => 14);

  ok Assemble eq => <<END, avx512=>1;
6666
Area     Size:     4096    Used:      896
.... .... .... .... | __10 ____ ____ ____  80.3 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | __.2 ____ ____ ____  .6__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ C0__ ____
.... .... .... ..C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | .3__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ 80.1 ____
.... .... .... .180 | 33__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ C0.1 ____
.... .... .... .1C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2.. | .2__ ____ .4__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .2__ ____ 40.2 ____
.... .... .... .240 | 22__ ____ 44__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 80.2 ____
.... .... .... .280 | 80__ ____ 40.1 ____  C0.2 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2C0 | .5__ ____ .6__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .2__ ____ __.3 ____
.... .... .... .3.. | 55__ ____ 66__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ 40.3 ____
.... .... .... .340 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::put
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $t->put(K(key=>1), K(data=>0x11));
  $t->put(K(key=>2), K(data=>0x22));
  $t->put(K(key=>3), K(data=>0x33));
  $t->put(K(key=>4), K(data=>0x44));
  $t->put(K(key=>5), K(data=>0x55));
  $t->put(K(key=>6), K(data=>0x66));
  $t->put(K(key=>7), K(data=>0x77));
  $a->dump("7777",   K depth => 14);

  ok Assemble eq => <<END, avx512=>1;
7777
Area     Size:     4096    Used:      896
.... .... .... .... | __10 ____ ____ ____  80.3 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | __.2 ____ ____ ____  .7__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ C0__ ____
.... .... .... ..C0 | 11__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | .3__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ 80.1 ____
.... .... .... .180 | 33__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ C0.1 ____
.... .... .... .1C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2.. | .2__ ____ .4__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .2__ ____ 40.2 ____
.... .... .... .240 | 22__ ____ 44__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 80.2 ____
.... .... .... .280 | 80__ ____ 40.1 ____  C0.2 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2C0 | .5__ ____ .6__ ____  .7__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .3__ ____ __.3 ____
.... .... .... .3.. | 55__ ____ 66__ ____  77__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ 40.3 ____
.... .... .... .340 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::put
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $t->put(K(key=>1), K(data=>0x11));
  $t->put(K(key=>2), K(data=>0x22));
  $t->put(K(key=>3), K(data=>0x33));
  $t->put(K(key=>4), K(data=>0x44));
  $t->put(K(key=>5), K(data=>0x55));
  $t->put(K(key=>6), K(data=>0x66));
  $t->put(K(key=>7), K(data=>0x77));
  $t->put(K(key=>8), K(data=>0x88));
  $t->dump("8888");

  ok Assemble eq => <<END, avx512=>1;
8888
At:  500                    length:    1,  data:  540,  nodes:  580,  first:   40, root, parent
  Index:    0
  Keys :    4
  Data :   68
  Nodes:  200  440
    At:  200                length:    1,  data:  240,  nodes:  280,  first:   40,  up:  500, parent
      Index:    0
      Keys :    2
      Data :   34
      Nodes:   80  140
        At:   80            length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
          Index:    0
          Keys :    1
          Data :   17
        end
        At:  140            length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
          Index:    0
          Keys :    3
          Data :   51
        end
    end
    At:  440                length:    1,  data:  480,  nodes:  4C0,  first:   40,  up:  500, parent
      Index:    0
      Keys :    6
      Data :  102
      Nodes:  2C0  380
        At:  2C0            length:    1,  data:  300,  nodes:  340,  first:   40,  up:  440, leaf
          Index:    0
          Keys :    5
          Data :   85
        end
        At:  380            length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  440, leaf
          Index:    0    1
          Keys :    7    8
          Data :  119  136
        end
    end
end
END
 }

#latest:
if (1) {
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $t->put(K(key=>2), K(data=>0x22));
  $t->put(K(key=>1), K(data=>0x11));
  $t->dump("2222");

  ok Assemble eq => <<END, avx512=>1;
2222
At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0    1
  Keys :    1    2
  Data :   17   34
end
END
 }

#latest:
if (1) {
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $t->put(K(key=>8), K(data=>0x88));
  $t->put(K(key=>7), K(data=>0x77));
  $t->put(K(key=>6), K(data=>0x66));
  $t->put(K(key=>5), K(data=>0x55));
  $t->put(K(key=>4), K(data=>0x44));
  $t->put(K(key=>3), K(data=>0x33));
  $t->put(K(key=>2), K(data=>0x22));
  $t->put(K(key=>1), K(data=>0x11));
  $t->dump("8888");

  ok Assemble eq => <<END, avx512=>1;
8888
At:  500                    length:    1,  data:  540,  nodes:  580,  first:   40, root, parent
  Index:    0
  Keys :    5
  Data :   85
  Nodes:  200  440
    At:  200                length:    1,  data:  240,  nodes:  280,  first:   40,  up:  500, parent
      Index:    0
      Keys :    3
      Data :   51
      Nodes:   80  380
        At:   80            length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
          Index:    0    1
          Keys :    1    2
          Data :   17   34
        end
        At:  380            length:    1,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
          Index:    0
          Keys :    4
          Data :   68
        end
    end
    At:  440                length:    1,  data:  480,  nodes:  4C0,  first:   40,  up:  500, parent
      Index:    0
      Keys :    7
      Data :  119
      Nodes:  2C0  140
        At:  2C0            length:    1,  data:  300,  nodes:  340,  first:   40,  up:  440, leaf
          Index:    0
          Keys :    6
          Data :  102
        end
        At:  140            length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  440, leaf
          Index:    0
          Keys :    8
          Data :  136
        end
    end
end
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::put #TNasm::X86::Tree::find
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K count => 128;

  $N->for(sub
   {my ($index, $start, $next, $end) = @_;
    my $l = $N-$index;
    $t->put($l, $l * 2);
    my $h = $N+$index;
    $t->put($h, $h * 2);
   });
  $t->put(K(zero=>0), K(zero=>0));
  $t->printInOrder("AAAA");

  PrintOutStringNL 'Indx   Found  Offset  Double   Found  Offset    Quad   Found  Offset    Octo   Found  Offset     *16   Found  Offset     *32   Found  Offset     *64   Found  Offset    *128   Found  Offset    *256   Found  Offset    *512';
  $N->for(sub
   {my ($index, $start, $next, $end) = @_;
    my $i = $index;
    my $j = $i * 2;
    my $k = $j * 2;
    my $l = $k * 2;
    my $m = $l * 2;
    my $n = $m * 2;
    my $o = $n * 2;
    my $p = $o * 2;
    my $q = $p * 2;
    $t->find($i); $i->outRightInDec(K width => 4); $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
    $t->find($j);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
    $t->find($k);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
    $t->find($l);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
    $t->find($m);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
    $t->find($n);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
    $t->find($o);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
    $t->find($p);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDec  (K width => 8);
    $t->find($q);                                  $t->found->outRightInBin(K width => 8); $t->offset->outRightInHex(K width => 8);  $t->data->outRightInDecNL(K width => 8);
   });

  ok Assemble eq => <<END, avx512=>1;
AAAA 256:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F  40  41  42  43  44  45  46  47  48  49  4A  4B  4C  4D  4E  4F  50  51  52  53  54  55  56  57  58  59  5A  5B  5C  5D  5E  5F  60  61  62  63  64  65  66  67  68  69  6A  6B  6C  6D  6E  6F  70  71  72  73  74  75  76  77  78  79  7A  7B  7C  7D  7E  7F  80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF
Indx   Found  Offset  Double   Found  Offset    Quad   Found  Offset    Octo   Found  Offset     *16   Found  Offset     *32   Found  Offset     *64   Found  Offset    *128   Found  Offset    *256   Found  Offset    *512
   0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0       1      80       0
   1      10      80       2       1     200       4       1     500       8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0
   2       1     200       4       1     500       8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0
   3       1    B540       6       1    B600      12       1    B6C0      24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0
   4       1     500       8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0
   5       1    B3C0      10       1    B180      20       1    AC40      40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0
   6       1    B600      12       1    B6C0      24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0
   7       1    B0C0      14       1    AB80      28       1    A040      56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0
   8       1     B00      16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0
   9       1    AF40      18       1    A700      36       1    95C0      72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0
  10       1    B180      20       1    AC40      40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0
  11       1    AAC0      22       1    9F80      44       1    8840      88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0
  12       1    B6C0      24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0
  13       1    A940      26       1    9B00      52       1    7DC0     104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0
  14       1    AB80      28       1    A040      56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0
  15       1    A640      30       1    9500      60       1    71C0     120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0
  16       1    1700      32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0               0       0
  17       1    A4C0      34       1    9080      68       1    6740     136       1    1640     272               0       0               0       0               0       0               0       0               0       0
  18       1    A700      36       1    95C0      72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0               0       0
  19       1    9EC0      38       1    8780      76       1    5840     152       1    2D80     304               0       0               0       0               0       0               0       0               0       0
  20       1    AC40      40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0               0       0
  21       1    9D40      42       1    8300      84       1    4DC0     168       1    4580     336               0       0               0       0               0       0               0       0               0       0
  22       1    9F80      44       1    8840      88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0               0       0
  23       1    9A40      46       1    7D00      92       1    41C0     184       1    5CC0     368               0       0               0       0               0       0               0       0               0       0
  24       1    B780      48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0               0       0
  25       1    98C0      50       1    7880     100       1    3740     200       1    7580     400               0       0               0       0               0       0               0       0               0       0
  26       1    9B00      52       1    7DC0     104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0               0       0
  27       1    9440      54       1    7100     108       1    29C0     216       1    8CC0     432               0       0               0       0               0       0               0       0               0       0
  28       1    A040      56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0               0       0
  29       1    92C0      58       1    6C80     116       1    1F40     232       1    A400     464               0       0               0       0               0       0               0       0               0       0
  30       1    9500      60       1    71C0     120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0               0       0
  31       1    8FC0      62       1    6680     124       1    1340     248      10    AE80     496               0       0               0       0               0       0               0       0               0       0
  32       1    2F00      64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0               0       0               0       0
  33       1    8E40      66       1    6200     132       1     A40     264               0       0               0       0               0       0               0       0               0       0               0       0
  34       1    9080      68       1    6740     136       1    1640     272               0       0               0       0               0       0               0       0               0       0               0       0
  35       1    86C0      70       1    5780     140       1    1580     280               0       0               0       0               0       0               0       0               0       0               0       0
  36       1    95C0      72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0               0       0               0       0
  37       1    8540      74       1    5300     148       1    2180     296               0       0               0       0               0       0               0       0               0       0               0       0
  38       1    8780      76       1    5840     152       1    2D80     304               0       0               0       0               0       0               0       0               0       0               0       0
  39       1    8240      78       1    4D00     156       1    2CC0     312               0       0               0       0               0       0               0       0               0       0               0       0
  40       1    A100      80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0               0       0               0       0
  41       1    80C0      82       1    4880     164       1    3980     328               0       0               0       0               0       0               0       0               0       0               0       0
  42       1    8300      84       1    4DC0     168       1    4580     336               0       0               0       0               0       0               0       0               0       0               0       0
  43       1    7C40      86       1    4100     172       1    44C0     344               0       0               0       0               0       0               0       0               0       0               0       0
  44       1    8840      88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0               0       0               0       0
  45       1    7AC0      90       1    3C80     180       1    5000     360               0       0               0       0               0       0               0       0               0       0               0       0
  46       1    7D00      92       1    41C0     184       1    5CC0     368               0       0               0       0               0       0               0       0               0       0               0       0
  47       1    77C0      94       1    3680     188       1    5C00     376               0       0               0       0               0       0               0       0               0       0               0       0
  48       1    B840      96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0               0       0               0       0
  49       1    7640      98       1    3200     196       1    6980     392               0       0               0       0               0       0               0       0               0       0               0       0
  50       1    7880     100       1    3740     200       1    7580     400               0       0               0       0               0       0               0       0               0       0               0       0
  51       1    7040     102       1    2900     204       1    74C0     408               0       0               0       0               0       0               0       0               0       0               0       0
  52       1    7DC0     104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0               0       0               0       0
  53       1    6EC0     106       1    2480     212       1    8000     424               0       0               0       0               0       0               0       0               0       0               0       0
  54       1    7100     108       1    29C0     216       1    8CC0     432               0       0               0       0               0       0               0       0               0       0               0       0
  55       1    6BC0     110       1    1E80     220       1    8C00     440               0       0               0       0               0       0               0       0               0       0               0       0
  56       1    8900     112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0               0       0               0       0
  57       1    6A40     114       1    1A00     228       1    9800     456               0       0               0       0               0       0               0       0               0       0               0       0
  58       1    6C80     116       1    1F40     232       1    A400     464               0       0               0       0               0       0               0       0               0       0               0       0
  59       1    65C0     118       1    1280     236       1    A340     472               0       0               0       0               0       0               0       0               0       0               0       0
  60       1    71C0     120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0               0       0               0       0
  61       1    6440     122       1     E00     244       1    AE80     488               0       0               0       0               0       0               0       0               0       0               0       0
  62       1    6680     124       1    1340     248      10    AE80     496               0       0               0       0               0       0               0       0               0       0               0       0
  63       1    6140     126       1     800     252      10    B300     504               0       0               0       0               0       0               0       0               0       0               0       0
  64       1    5F00     128      10    5F00     256               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  65       1    5FC0     130       1     440     260               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  66       1    6200     132       1     A40     264               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  67       1    56C0     134       1     980     268               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  68       1    6740     136       1    1640     272               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  69       1    5540     138       1     F80     276               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  70       1    5780     140       1    1580     280               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  71       1    5240     142       1    14C0     284               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  72       1    7280     144       1    2E40     288               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  73       1    50C0     146       1    1B80     292               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  74       1    5300     148       1    2180     296               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  75       1    4C40     150       1    20C0     300               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  76       1    5840     152       1    2D80     304               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  77       1    4AC0     154       1    2600     308               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  78       1    4D00     156       1    2CC0     312               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  79       1    47C0     158       1    2C00     316               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  80       1    89C0     160       1    5E40     320               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  81       1    4640     162       1    3380     324               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  82       1    4880     164       1    3980     328               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  83       1    4040     166       1    38C0     332               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  84       1    4DC0     168       1    4580     336               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  85       1    3EC0     170       1    3E00     340               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  86       1    4100     172       1    44C0     344               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  87       1    3BC0     174       1    4400     348               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  88       1    5900     176       1    5D80     352               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  89       1    3A40     178       1    4A00     356               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  90       1    3C80     180       1    5000     360               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  91       1    35C0     182       1    4F40     364               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  92       1    41C0     184       1    5CC0     368               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  93       1    3440     186       1    5480     372               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  94       1    3680     188       1    5C00     376               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  95       1    3140     190       1    5B40     380               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  96       1    B900     192      10    5E40     384               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  97       1    2FC0     194       1    6380     388               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  98       1    3200     196       1    6980     392               0       0               0       0               0       0               0       0               0       0               0       0               0       0
  99       1    2840     198       1    68C0     396               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 100       1    3740     200       1    7580     400               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 101       1    26C0     202       1    6E00     404               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 102       1    2900     204       1    74C0     408               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 103       1    23C0     206       1    7400     412               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 104       1    4280     208       1    8D80     416               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 105       1    2240     210       1    7A00     420               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 106       1    2480     212       1    8000     424               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 107       1    1DC0     214       1    7F40     428               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 108       1    29C0     216       1    8CC0     432               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 109       1    1C40     218       1    8480     436               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 110       1    1E80     220       1    8C00     440               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 111       1    1940     222       1    8B40     444               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 112       1    59C0     224      10    8D80     448               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 113       1    17C0     226       1    9200     452               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 114       1    1A00     228       1    9800     456               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 115       1    11C0     230       1    9740     460               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 116       1    1F40     232       1    A400     464               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 117       1    1040     234       1    9C80     468               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 118       1    1280     236       1    A340     472               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 119       1     D40     238       1    A280     476               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 120       1    2A80     240      10    A400     480               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 121       1     BC0     242       1    A880     484               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 122       1     E00     244       1    AE80     488               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 123       1     740     246       1    ADC0     492               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 124       1    1340     248      10    AE80     496               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 125       1     5C0     250       1    B300     500               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 126       1     800     252      10    B300     504               0       0               0       0               0       0               0       0               0       0               0       0               0       0
 127       1     2C0     254      10    B480     508               0       0               0       0               0       0               0       0               0       0               0       0               0       0
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::printInOrder
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K count => 128;

  $N->for(sub
   {my ($index, $start, $next, $end) = @_;
    my $l0 = ($N-$index) / 2;
    my $l1 = ($N+$index) / 2;
    my $h0 =  $N-$index;
    my $h1 =  $N+$index;
    $t->put($l0, $l0 * 2);
    $t->put($h1, $h1 * 2);
    $t->put($l1, $l1 * 2);
    $t->put($h0, $h0 * 2);
   });
  $t->printInOrder("AAAA");

  ok Assemble eq => <<END, avx512=>1;
AAAA 256:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F  40  41  42  43  44  45  46  47  48  49  4A  4B  4C  4D  4E  4F  50  51  52  53  54  55  56  57  58  59  5A  5B  5C  5D  5E  5F  60  61  62  63  64  65  66  67  68  69  6A  6B  6C  6D  6E  6F  70  71  72  73  74  75  76  77  78  79  7A  7B  7C  7D  7E  7F  80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF
END
 }

#latest:
if (1) {
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K count => 128;

  $N->for(sub
   {my ($index, $start, $next, $end) = @_;
    my $l00 = ($N-$index) / 4;
    my $l01 = ($N+$index) / 4;
    my $h00 =  $N-$index  / 2;
    my $h01 =  $N+$index  / 2;
    my $l10 = ($N-$index) / 4 * 3;
    my $l11 = ($N+$index) / 4 * 3;
    my $h10 =  $N-$index ;
    my $h11 =  $N+$index ;
    $t->put($l00, $l00 * 2);
    $t->put($h01, $h01 * 2);
    $t->put($l01, $l01 * 2);
    $t->put($h00, $h00 * 2);
    $t->put($l10, $l10 * 2);
    $t->put($h11, $h11 * 2);
    $t->put($l11, $l11 * 2);
    $t->put($h10, $h10 * 2);
   });
  $t->printInOrder("AAAA");

  ok Assemble eq => <<END, avx512=>1;
AAAA 256:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F  40  41  42  43  44  45  46  47  48  49  4A  4B  4C  4D  4E  4F  50  51  52  53  54  55  56  57  58  59  5A  5B  5C  5D  5E  5F  60  61  62  63  64  65  66  67  68  69  6A  6B  6C  6D  6E  6F  70  71  72  73  74  75  76  77  78  79  7A  7B  7C  7D  7E  7F  80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF
END
 }

#latest:
if (1) {
  my $N = 13;
  my $a = CreateArea;
  my $t = $a->CreateTree(length => $N);

  my ($K, $D) = (31, 30);

  K(K => Rd( 1..16))->loadZmm($K);
  K(D => Rd(17..32))->loadZmm($D);

  $t->lengthIntoKeys($K, K length => $t->length);

  Mov r15, 0b11001100110011;
  $t->setTreeBits($K, r15);

  PrintOutStringNL "Start";
  PrintOutRegisterInHex $K, $D;

  K(loop => $N)->for(sub
   {my ($index) = @_;                                                           # Parameters
    $t->deleteFirstKeyAndData($K, $D);

    PrintOutNL;
    $index->outNL;
    PrintOutNL;
    PrintOutRegisterInHex $K, $D;
    PrintOutNL;
    $t->key    ->out("k: ", "   "); $t->data->out("d: ", "   ");
    $t->subTree->out("s: ", "   "); $t->found->outNL;
   });

  ok Assemble eq => <<END, avx512=>1;
Start
 zmm31: .... ..10 3333 ...D  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1C .... ..1B  .... ..1A .... ..19 + .... ..18 .... ..17  .... ..16 .... ..15 - .... ..14 .... ..13  .... ..12 .... ..11

index: .... .... .... ....

 zmm31: .... ..10 1999 ...C  .... ...E .... ...D - .... ...D .... ...C  .... ...B .... ...A + .... ...9 .... ...8  .... ...7 .... ...6 - .... ...5 .... ...4  .... ...3 .... ...2
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1C  .... ..1B .... ..1A + .... ..19 .... ..18  .... ..17 .... ..16 - .... ..15 .... ..14  .... ..13 .... ..12

k: .... .... .... ...1   d: .... .... .... ..11   s: .... .... .... ...1   found: .... .... .... ...1

index: .... .... .... ...1

 zmm31: .... ..10 .CCC ...B  .... ...E .... ...D - .... ...D .... ...D  .... ...C .... ...B + .... ...A .... ...9  .... ...8 .... ...7 - .... ...6 .... ...5  .... ...4 .... ...3
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1C .... ..1B + .... ..1A .... ..19  .... ..18 .... ..17 - .... ..16 .... ..15  .... ..14 .... ..13

k: .... .... .... ...2   d: .... .... .... ..12   s: .... .... .... ...1   found: .... .... .... ...1

index: .... .... .... ...2

 zmm31: .... ..10 .666 ...A  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...C + .... ...B .... ...A  .... ...9 .... ...8 - .... ...7 .... ...6  .... ...5 .... ...4
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1C + .... ..1B .... ..1A  .... ..19 .... ..18 - .... ..17 .... ..16  .... ..15 .... ..14

k: .... .... .... ...3   d: .... .... .... ..13   s: .... .... .... ....   found: .... .... .... ...1

index: .... .... .... ...3

 zmm31: .... ..10 .333 ...9  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...C .... ...B  .... ...A .... ...9 - .... ...8 .... ...7  .... ...6 .... ...5
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1C .... ..1B  .... ..1A .... ..19 - .... ..18 .... ..17  .... ..16 .... ..15

k: .... .... .... ...4   d: .... .... .... ..14   s: .... .... .... ....   found: .... .... .... ...1

index: .... .... .... ...4

 zmm31: .... ..10 .199 ...8  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...D .... ...C  .... ...B .... ...A - .... ...9 .... ...8  .... ...7 .... ...6
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1D .... ..1C  .... ..1B .... ..1A - .... ..19 .... ..18  .... ..17 .... ..16

k: .... .... .... ...5   d: .... .... .... ..15   s: .... .... .... ...1   found: .... .... .... ...1

index: .... .... .... ...5

 zmm31: .... ..10 ..CC ...7  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...D .... ...D  .... ...C .... ...B - .... ...A .... ...9  .... ...8 .... ...7
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1D .... ..1D  .... ..1C .... ..1B - .... ..1A .... ..19  .... ..18 .... ..17

k: .... .... .... ...6   d: .... .... .... ..16   s: .... .... .... ...1   found: .... .... .... ...1

index: .... .... .... ...6

 zmm31: .... ..10 ..66 ...6  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...D .... ...D  .... ...D .... ...C - .... ...B .... ...A  .... ...9 .... ...8
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1D .... ..1D  .... ..1D .... ..1C - .... ..1B .... ..1A  .... ..19 .... ..18

k: .... .... .... ...7   d: .... .... .... ..17   s: .... .... .... ....   found: .... .... .... ...1

index: .... .... .... ...7

 zmm31: .... ..10 ..33 ...5  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...D .... ...D  .... ...D .... ...D - .... ...C .... ...B  .... ...A .... ...9
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1D .... ..1D  .... ..1D .... ..1D - .... ..1C .... ..1B  .... ..1A .... ..19

k: .... .... .... ...8   d: .... .... .... ..18   s: .... .... .... ....   found: .... .... .... ...1

index: .... .... .... ...8

 zmm31: .... ..10 ..19 ...4  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...D .... ...D  .... ...D .... ...D - .... ...D .... ...C  .... ...B .... ...A
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1D .... ..1D  .... ..1D .... ..1D - .... ..1D .... ..1C  .... ..1B .... ..1A

k: .... .... .... ...9   d: .... .... .... ..19   s: .... .... .... ...1   found: .... .... .... ...1

index: .... .... .... ...9

 zmm31: .... ..10 ...C ...3  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...D .... ...D  .... ...D .... ...D - .... ...D .... ...D  .... ...C .... ...B
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1D .... ..1D  .... ..1D .... ..1D - .... ..1D .... ..1D  .... ..1C .... ..1B

k: .... .... .... ...A   d: .... .... .... ..1A   s: .... .... .... ...1   found: .... .... .... ...1

index: .... .... .... ...A

 zmm31: .... ..10 ...6 ...2  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...D .... ...D  .... ...D .... ...D - .... ...D .... ...D  .... ...D .... ...C
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1D .... ..1D  .... ..1D .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1C

k: .... .... .... ...B   d: .... .... .... ..1B   s: .... .... .... ....   found: .... .... .... ...1

index: .... .... .... ...B

 zmm31: .... ..10 ...3 ...1  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...D .... ...D  .... ...D .... ...D - .... ...D .... ...D  .... ...D .... ...D
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1D .... ..1D  .... ..1D .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D

k: .... .... .... ...C   d: .... .... .... ..1C   s: .... .... .... ....   found: .... .... .... ...1

index: .... .... .... ...C

 zmm31: .... ..10 ...1 ....  .... ...E .... ...D - .... ...D .... ...D  .... ...D .... ...D + .... ...D .... ...D  .... ...D .... ...D - .... ...D .... ...D  .... ...D .... ...D
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D + .... ..1D .... ..1D  .... ..1D .... ..1D - .... ..1D .... ..1D  .... ..1D .... ..1D

k: .... .... .... ...D   d: .... .... .... ..1D   s: .... .... .... ...1   found: .... .... .... ...1
END
 }

#latest:
if (1) {                                                                        #Nasm::X86::Variable::shiftLeft #Nasm::X86::Variable::shiftRight
  K(loop=>16)->for(sub
   {my ($index, $start, $next, $end) = @_;
   (K(one => 1)     << $index)->outRightInBinNL(K width => 16);
   (K(one => 1<<15) >> $index)->outRightInBinNL(K width => 16);
   });

  ok Assemble eq => <<END, avx512=>1;
               1
1000000000000000
              10
 100000000000000
             100
  10000000000000
            1000
   1000000000000
           10000
    100000000000
          100000
     10000000000
         1000000
      1000000000
        10000000
       100000000
       100000000
        10000000
      1000000000
         1000000
     10000000000
          100000
    100000000000
           10000
   1000000000000
            1000
  10000000000000
             100
 100000000000000
              10
1000000000000000
               1
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::firstNode #TNasm::X86::Tree::lastNode
  my $L = 13;
  my $a = CreateArea;
  my $t = $a->CreateTree(length => $L);

  my ($K, $D, $N) = (31, 30, 29);

  K(K => Rd( 1..16))->loadZmm($K);
  K(K => Rd( 1..16))->loadZmm($N);

  $t->lengthIntoKeys($K, K length => $t->length);

  PrintOutRegisterInHex 31, 29;
  my $f = $t->firstNode($K, $D, $N);
  my $l = $t-> lastNode($K, $D, $N);
  $f->outNL;
  $l->outNL;

  ok Assemble eq => <<END, avx512=>1;
 zmm31: .... ..10 .... ...D  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm29: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
d at offset 0 in zmm29: .... .... .... ...1
d at offset (b at offset 56 in zmm31 times 4) in zmm29: .... .... .... ...E
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::firstNode #TNasm::X86::Tree::lastNode
  my $L = 13;
  my $a = CreateArea;
  my $t = $a->CreateTree(length => $L);

  my ($K, $D, $N) = (31, 30, 29);

  K(K => Rd( 1..16))->loadZmm($K);
  K(K => Rd( 1..16))->loadZmm($N);

  $t->lengthIntoKeys($K, K length => $t->length);

  PrintOutRegisterInHex 31, 29;
  my $f = $t->firstNode($K, $D, $N);
  my $l = $t-> lastNode($K, $D, $N);
  $f->outNL;
  $l->outNL;

  ok Assemble eq => <<END, avx512=>1;
 zmm31: .... ..10 .... ...D  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm29: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
d at offset 0 in zmm29: .... .... .... ...1
d at offset (b at offset 56 in zmm31 times 4) in zmm29: .... .... .... ...E
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::expand
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  my ($PK, $PD, $PN) = (31, 30, 29);
  my ($LK, $LD, $LN) = (28, 27, 26);
  my ($RK, $RD, $RN) = (25, 24, 23);
  my ($lK, $lD, $lN) = (22, 21, 20);
  my ($rK, $rD, $rN) = (19, 18, 17);
  my $F = 16;

  my $P  = $t->allocBlock($PK, $PD, $PN);
  my $L  = $t->allocBlock($LK, $LD, $LN);
  my $R  = $t->allocBlock($RK, $RD, $RN);
  my $l  = $t->allocBlock($lK, $lD, $lN);
  my $r  = $t->allocBlock($rK, $rD, $rN);

  $t->lengthIntoKeys($PK, K length => 1);
  $t->lengthIntoKeys($LK, K length => 1);
  $t->lengthIntoKeys($RK, K length => 1);

  K(key=>1)->dIntoZ($LK, 0);  K(key=>1)->dIntoZ($LD, 0);
  K(key=>2)->dIntoZ($PK, 0);  K(key=>2)->dIntoZ($PD, 0);
  K(key=>3)->dIntoZ($RK, 0);  K(key=>3)->dIntoZ($RD, 0);

  $L->dIntoZ($PN, 0);
  $R->dIntoZ($PN, 4);
  $l->dIntoZ($LN, 0); $l->dIntoZ($LN, 4);
  $r->dIntoZ($RN, 0); $r->dIntoZ($RN, 4);

  $t->upIntoData($P, $LD);
  $t->upIntoData($P, $RD);
  $t->upIntoData($L, $lD);
  $t->upIntoData($R, $rD);

  $t->firstFromMemory($F);
  $t->rootIntoFirst($F, $P);
  $t->sizeIntoFirst($F, K size => 3);

  $t->firstIntoMemory($F);
  $t->putBlock($P, $PK, $PD, $PN);
  $t->putBlock($L, $LK, $LD, $LN);
  $t->putBlock($R, $RK, $RD, $RN);
  $t->putBlock($l, $lK, $lD, $lN);
  $t->putBlock($r, $rK, $rD, $rN);

  PrintOutStringNL "Start";
  PrintOutRegisterInHex reverse $F..$PK;

  $t->expand($L);

  $t->firstFromMemory($F);
  $t->getBlock($P, $PK, $PD, $PN);
  $t->getBlock($L, $LK, $LD, $LN);
  $t->getBlock($R, $RK, $RD, $RN);

  PrintOutStringNL "Finish";
  PrintOutRegisterInHex reverse $LN..$LK;

  PrintOutStringNL "Children";
  PrintOutRegisterInHex reverse $LN..$LK;

  ok Assemble eq => <<END, avx512=>1;
Start
 zmm31: .... ..C0 .... ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ...2
 zmm30: .... .1.. .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ...2
 zmm29: .... ..40 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .2.. .... .140
 zmm28: .... .180 .... ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ...1
 zmm27: .... .1C0 .... ..80  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ...1
 zmm26: .... ..40 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .2C0 .... .2C0
 zmm25: .... .240 .... ...1  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ...3
 zmm24: .... .280 .... ..80  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ...3
 zmm23: .... ..40 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .380 .... .380
 zmm22: .... .3.. .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm21: .... .340 .... .140  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm20: .... ..40 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm19: .... .3C0 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm18: .... .4.. .... .2..  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm17: .... ..40 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
 zmm16: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ...3  .... .... .... ..80
Finish
 zmm28: .... .180 .... ...3  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ...3  .... ...2 .... ...1
 zmm27: .... .1C0 .... ..80  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ...3  .... ...2 .... ...1
 zmm26: .... ..40 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .380 .... .380  .... .2C0 .... .2C0
Children
 zmm28: .... .180 .... ...3  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ...3  .... ...2 .... ...1
 zmm27: .... .1C0 .... ..80  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ...3  .... ...2 .... ...1
 zmm26: .... ..40 .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .380 .... .380  .... .2C0 .... .2C0
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::replace
  my ($K, $D) = (31, 30);

  K(K => Rd(reverse 1..16))->loadZmm($K);
  K(K => Rd(reverse 1..16))->loadZmm($D);
  PrintOutStringNL "Start";
  PrintOutRegisterInHex $K, $D;

  my $a = CreateArea;
  my $t = $a->CreateTree(length => 13);

  K(loop => 14)->for(sub
   {my ($index, $start, $next, $end) = @_;

    $t->key    ->copy($index);
    $t->data   ->copy($index * 2);
    $t->subTree->copy($index % 2);

    $t->replace(K(one=>1)<<$index, $K, $D);

    $index->outNL;
    PrintOutRegisterInHex $K, $D;
   });

  ok Assemble eq => <<END, avx512=>1;
Start
 zmm31: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...D .... ...E  .... ...F .... ..10
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...D .... ...E  .... ...F .... ..10
index: .... .... .... ....
 zmm31: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...D .... ...E  .... ...F .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...D .... ...E  .... ...F .... ....
index: .... .... .... ...1
 zmm31: .... ...1 ...2 ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...D .... ...E  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...D .... ...E  .... ...2 .... ....
index: .... .... .... ...2
 zmm31: .... ...1 ...2 ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...D .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...D .... ...4  .... ...2 .... ....
index: .... .... .... ...3
 zmm31: .... ...1 ...A ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...C - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...4
 zmm31: .... ...1 ...A ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...B .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...5
 zmm31: .... ...1 ..2A ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...A  .... ...A .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...6
 zmm31: .... ...1 ..2A ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...9 .... ...C  .... ...A .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...7
 zmm31: .... ...1 ..AA ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...E .... ...C  .... ...A .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...8
 zmm31: .... ...1 ..AA ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...7 .... ..10 + .... ...E .... ...C  .... ...A .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...9
 zmm31: .... ...1 .2AA ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ...6  .... ..12 .... ..10 + .... ...E .... ...C  .... ...A .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...A
 zmm31: .... ...1 .2AA ...2  .... ...3 .... ...4 - .... ...5 .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ...5 .... ..14  .... ..12 .... ..10 + .... ...E .... ...C  .... ...A .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...B
 zmm31: .... ...1 .AAA ...2  .... ...3 .... ...4 - .... ...B .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ...4 - .... ..16 .... ..14  .... ..12 .... ..10 + .... ...E .... ...C  .... ...A .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...C
 zmm31: .... ...1 .AAA ...2  .... ...3 .... ...C - .... ...B .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ...3 .... ..18 - .... ..16 .... ..14  .... ..12 .... ..10 + .... ...E .... ...C  .... ...A .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
index: .... .... .... ...D
 zmm31: .... ...1 2AAA ...2  .... ...D .... ...C - .... ...B .... ...A  .... ...9 .... ...8 + .... ...7 .... ...6  .... ...5 .... ...4 - .... ...3 .... ...2  .... ...1 .... ....
 zmm30: .... ...1 .... ...2  .... ..1A .... ..18 - .... ..16 .... ..14  .... ..12 .... ..10 + .... ...E .... ...C  .... ...A .... ...8 - .... ...6 .... ...4  .... ...2 .... ....
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::extractFirst
  my ($K, $D, $N) = (31, 30, 29);

  K(K => Rd( 1..16))       ->loadZmm($K);
  K(K => Rd( 1..16))       ->loadZmm($D);
  K(K => Rd(map {0} 1..16))->loadZmm($N);

  my $a = CreateArea;
  my $t = $a->CreateTree(length => 13);

  my $p = K(one => 1) << K three => 3;
  Mov r15, 0xAAAA;
  $t->setTreeBits($K, r15);

  PrintOutStringNL "Start";
  PrintOutRegisterInHex 31, 30, 29;

  K(n=>4)->for(sub
   {my ($index, $start, $next, $end) = @_;

    $t->extractFirst($K, $D, $N);

    PrintOutStringNL "-------------";
    $index->outNL;
    PrintOutRegisterInHex 31, 30, 29;

    $t->data->outNL;
    $t->subTree->outNL;
    $t->lengthFromKeys($K)->outNL;
   });

  ok Assemble eq => <<END, avx512=>1;
Start
 zmm31: .... ..10 2AAA ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm30: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm29: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
-------------
index: .... .... .... ....
 zmm31: .... ..10 1555 ...E  .... ...E .... ...E - .... ...D .... ...C  .... ...B .... ...A + .... ...9 .... ...8  .... ...7 .... ...6 - .... ...5 .... ...4  .... ...3 .... ...2
 zmm30: .... ..10 .... ...F  .... ...E .... ...E - .... ...D .... ...C  .... ...B .... ...A + .... ...9 .... ...8  .... ...7 .... ...6 - .... ...5 .... ...4  .... ...3 .... ...2
 zmm29: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
data: .... .... .... ...1
subTree: .... .... .... ....
b at offset 56 in zmm31: .... .... .... ...E
-------------
index: .... .... .... ...1
 zmm31: .... ..10 .AAA ...D  .... ...E .... ...E - .... ...E .... ...D  .... ...C .... ...B + .... ...A .... ...9  .... ...8 .... ...7 - .... ...6 .... ...5  .... ...4 .... ...3
 zmm30: .... ..10 .... ...F  .... ...E .... ...E - .... ...E .... ...D  .... ...C .... ...B + .... ...A .... ...9  .... ...8 .... ...7 - .... ...6 .... ...5  .... ...4 .... ...3
 zmm29: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
data: .... .... .... ...2
subTree: .... .... .... ...1
b at offset 56 in zmm31: .... .... .... ...D
-------------
index: .... .... .... ...2
 zmm31: .... ..10 .555 ...C  .... ...E .... ...E - .... ...E .... ...E  .... ...D .... ...C + .... ...B .... ...A  .... ...9 .... ...8 - .... ...7 .... ...6  .... ...5 .... ...4
 zmm30: .... ..10 .... ...F  .... ...E .... ...E - .... ...E .... ...E  .... ...D .... ...C + .... ...B .... ...A  .... ...9 .... ...8 - .... ...7 .... ...6  .... ...5 .... ...4
 zmm29: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
data: .... .... .... ...3
subTree: .... .... .... ....
b at offset 56 in zmm31: .... .... .... ...C
-------------
index: .... .... .... ...3
 zmm31: .... ..10 .2AA ...B  .... ...E .... ...E - .... ...E .... ...E  .... ...E .... ...D + .... ...C .... ...B  .... ...A .... ...9 - .... ...8 .... ...7  .... ...6 .... ...5
 zmm30: .... ..10 .... ...F  .... ...E .... ...E - .... ...E .... ...E  .... ...E .... ...D + .... ...C .... ...B  .... ...A .... ...9 - .... ...8 .... ...7  .... ...6 .... ...5
 zmm29: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
data: .... .... .... ...4
subTree: .... .... .... ...1
b at offset 56 in zmm31: .... .... .... ...B
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::extract
  my ($K, $D, $N) = (31, 30, 29);

  K(K => Rd( 1..16))->loadZmm($K);
  K(K => Rd( 1..16))->loadZmm($D);
  K(K => Rd(map {0} 1..16))->loadZmm($N);

  my $a = CreateArea;
  my $t = $a->CreateTree(length => 13);

  my $p = K(one => 1) << K three => 3;
  Mov r15, 0xAAAA;
  $t->setTreeBits($K, r15);

  PrintOutStringNL "Start";
  PrintOutRegisterInHex 31, 30, 29;

  $t->extract($p, $K, $D, $N);

  PrintOutStringNL "Finish";
  PrintOutRegisterInHex 31, 30, 29;

  ok Assemble eq => <<END, avx512=>1;
Start
 zmm31: .... ..10 2AAA ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm30: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm29: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
Finish
 zmm31: .... ..10 2AAA ...E  .... ...E .... ...E - .... ...D .... ...C  .... ...B .... ...A + .... ...9 .... ...8  .... ...7 .... ...6 - .... ...5 .... ...3  .... ...2 .... ...1
 zmm30: .... ..10 .... ...F  .... ...E .... ...E - .... ...D .... ...C  .... ...B .... ...A + .... ...9 .... ...8  .... ...7 .... ...6 - .... ...5 .... ...3  .... ...2 .... ...1
 zmm29: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::mergeOrSteal
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  $t->put(   K(k=>1), K(d=>11));
  $t->put(   K(k=>2), K(d=>22));
  $t->put(   K(k=>3), K(d=>33));
  $t->put(   K(k=>4), K(d=>44));
  $t->put(   K(k=>5), K(d=>55));
  $t->put(   K(k=>6), K(d=>56));

  $t->getBlock(K(o=>0x2C0), 31, 30, 29);
  $t->lengthIntoKeys(31, K 1 => 1);
  $t->putBlock(K(o=>0x2C0), 31, 30, 29);
  $t->dump("6");

  $t->key->copy(K k => 4);
  $t->mergeOrSteal(K o => 0x140);
  $t->dump("5");

  ok Assemble eq => <<END, avx512=>1;
6
At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0    1
  Keys :    2    4
  Data :   22   44
  Nodes:   80  140  2C0
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   11
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    3
      Data :   33
    end
    At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    5
      Data :   55
    end
end
5
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :   22
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   11
    end
    At:  140                length:    3,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1    2
      Keys :    3    4    5
      Data :   33   44   55
    end
end
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::nextNode #TNasm::X86::Tree::prevNode
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 13);

  K(loop => 66)->for(sub
   {my ($index, $start, $next, $end) = @_;
    $t->put($index, 2 * $index);
   });
  $t->getBlock(K(offset=>0x200), 31, 30, 29);
  $t->nextNode(K(offset=>0x440), 31, 29)->outRightInHexNL(K width => 3);
  $t->prevNode(K(offset=>0x440), 31, 29)->outRightInHexNL(K width => 3);

  ok Assemble eq => <<END, avx512=>1;
500
380
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::mergeOrSteal
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  $t->put(   K(k=>1), K(d=>11));
  $t->put(   K(k=>2), K(d=>22));
  $t->put(   K(k=>3), K(d=>33));
  $t->put(   K(k=>4), K(d=>44));
  $t->put(   K(k=>5), K(d=>55));
  $t->put(   K(k=>6), K(d=>56));

  $t->getBlock(K(o=>0x2C0), 31, 30, 29);
  $t->lengthIntoKeys(31, K 1 => 1);
  $t->putBlock(K(o=>0x2C0), 31, 30, 29);
  $t->dump("6");

  $t->key->copy(K k => 4);
  $t->mergeOrSteal(K o => 0x140);
  $t->dump("5");

  ok Assemble eq => <<END, avx512=>1;
6
At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0    1
  Keys :    2    4
  Data :   22   44
  Nodes:   80  140  2C0
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   11
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    3
      Data :   33
    end
    At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    5
      Data :   55
    end
end
5
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :   22
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   11
    end
    At:  140                length:    3,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1    2
      Keys :    3    4    5
      Data :   33   44   55
    end
end
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::mergeOrSteal
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  $t->put(   K(k=>1), K(d=>11));
  $t->put(   K(k=>2), K(d=>22));
  $t->put(   K(k=>3), K(d=>33));
  $t->put(   K(k=>4), K(d=>44));
  $t->put(   K(k=>5), K(d=>55));
  $t->put(   K(k=>6), K(d=>56));

  $t->getBlock(K(o=>0x2C0), 31, 30, 29);
  $t->lengthIntoKeys(31, K 1 => 1);
  $t->putBlock(K(o=>0x2C0), 31, 30, 29);
  $t->dump("6");

  $t->key->copy(K k => 2);
  $t->mergeOrSteal(K o => 0x80);
  $t->dump("5");

  ok Assemble eq => <<END, avx512=>1;
6
At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0    1
  Keys :    2    4
  Data :   22   44
  Nodes:   80  140  2C0
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   11
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    3
      Data :   33
    end
    At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    5
      Data :   55
    end
end
5
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    4
  Data :   44
  Nodes:   80  2C0
    At:   80                length:    3,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0    1    2
      Keys :    1    2    3
      Data :   11   22   33
    end
    At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    5
      Data :   55
    end
end
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::findFirst
  my $N = K(key => 32);
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $N->for(sub
   {my ($i, $start, $next, $end) = @_;
    $t->put($i, $i);
   });

  $N->for(sub
   {my ($i, $start, $next, $end) = @_;
    $t->put($N + $i, $N + $i);
    $t->findFirst;

    If $t->key != $i,
    Then
     {PrintOutTraceBack "Reverse queue first failed at: "; $i->outNL;
     };
    $t->delete($i);
    If $t->size != $N,
    Then
     {PrintOutTraceBack "Reverse queue size failed at: "; $i->outNL;
     };
    $t->printInOrder("A");
   });

  ok Assemble eq => <<END, avx512=>1;
A  32:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20
A  32:    2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21
A  32:    3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22
A  32:    4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
A  32:    5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24
A  32:    6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25
A  32:    7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26
A  32:    8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27
A  32:    9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28
A  32:    A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29
A  32:    B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A
A  32:    C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B
A  32:    D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C
A  32:    E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D
A  32:    F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E
A  32:   10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F
A  32:   11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30
A  32:   12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31
A  32:   13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32
A  32:   14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33
A  32:   15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34
A  32:   16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35
A  32:   17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36
A  32:   18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37
A  32:   19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38
A  32:   1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39
A  32:   1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A
A  32:   1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B
A  32:   1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C
A  32:   1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D
A  32:   1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E
A  32:   20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F
END
 }


#latest:
if (1) {                                                                        #TNasm::X86::Tree::findLast
  my $N = K(key => 32);
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $N->for(sub
   {my ($i, $start, $next, $end) = @_;
    $t->put($N + $i, $N + $i);
   });

  $N->for(sub
   {my ($i, $start, $next, $end) = @_;
    $t->put($N - $i, $N - $i);
    $t->findLast;

    $t->delete($t->key);
     If $t->size != $N - 1,
     Then
      {PrintOutTraceBack "Queued size failed at: "; $i->outNL;
      };
    $t->printInOrder("A");
   });

  ok Assemble eq => <<END, avx512=>1;
A  31:   20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E
A  31:   1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D
A  31:   1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C
A  31:   1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B
A  31:   1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A
A  31:   1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39
A  31:   1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38
A  31:   19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37
A  31:   18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36
A  31:   17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35
A  31:   16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34
A  31:   15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33
A  31:   14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32
A  31:   13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31
A  31:   12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30
A  31:   11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F
A  31:   10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E
A  31:    F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D
A  31:    E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C
A  31:    D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B
A  31:    C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A
A  31:    B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29
A  31:    A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28
A  31:    9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27
A  31:    8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26
A  31:    7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25
A  31:    6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24
A  31:    5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
A  31:    4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22
A  31:    3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21
A  31:    2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20
A  31:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $i2 = V  k => 2; $t->put($i2, $i2);
  my $i3 = V  k => 3; $t->put($i3, $i3);
  my $i4 = V  k => 4; $t->put($i4, $i4);
  my $i1 = V  k => 1; $t->put($i1, $i1);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("4"); $t->delete($i4);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

  ok Assemble eq => <<END, avx512=>1;
   4
4
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    3
  Data :    3
  Nodes:   80  140
    At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    1    2
      Data :    1    2
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    4
      Data :    4
    end
end
   3
X
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :    2
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    3
      Data :    3
    end
end
X   3:    1   2   3
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $i20 = V  k => 20; $t->put($i20, $i20);
  my $i30 = V  k => 30; $t->put($i30, $i30);
  my $i40 = V  k => 40; $t->put($i40, $i40);
  my $i10 = V  k => 10; $t->put($i10, $i10);
  my $i31 = V  k => 31; $t->put($i31, $i31);
  my $i32 = V  k => 32; $t->put($i32, $i32);
  my $i33 = V  k => 33; $t->put($i33, $i33);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("33"); $t->delete($i33);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("40"); $t->delete($i40);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

  ok Assemble eq => <<END, avx512=>1;
   7
33
At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0    1
  Keys :   1E   20
  Data :   30   32
  Nodes:   80  140  2C0
    At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    A   14
      Data :   10   20
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :   1F
      Data :   31
    end
    At:  2C0                length:    2,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :   21   28
      Data :   33   40
    end
end
   6
40
At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0    1
  Keys :   1E   20
  Data :   30   32
  Nodes:   80  140  2C0
    At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    A   14
      Data :   10   20
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :   1F
      Data :   31
    end
    At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
      Index:    0
      Keys :   28
      Data :   40
    end
end
   5
X
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :   1E
  Data :   30
  Nodes:   80  140
    At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    A   14
      Data :   10   20
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :   1F   20
      Data :   31   32
    end
end
X   5:    A  14  1E  1F  20
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $i1 = V  k =>  0; $t->put($i1, $i1);
  my $i2 = V  k => 11; $t->put($i2, $i2);
  my $i3 = V  k => 13; $t->put($i3, $i3);
  my $i4 = V  k => 15; $t->put($i4, $i4);
  $t->size->outRightInDecNL(K width => 4);
  $t->dump("1");
  $a->dump("AAA", K blocks => 12);
  $t->delete($i2);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

  ok Assemble eq => <<END, avx512=>1;
   4
1
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    B
  Data :   11
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    0
      Data :    0
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    D    F
      Data :   13   15
    end
end
AAA
Area     Size:     4096    Used:      704
.... .... .... .... | __10 ____ ____ ____  C0.2 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | __.2 ____ ____ ____  .4__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ C0__ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | .D__ ____ .F__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .2__ ____ 80.1 ____
.... .... .... .180 | .D__ ____ .F__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ C0.1 ____
.... .... .... .1C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2.. | .B__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ 40.2 ____
.... .... .... .240 | .B__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 80.2 ____
.... .... .... .280 | 80__ ____ 40.1 ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   3
X
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    D
  Data :   13
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    0
      Data :    0
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    F
      Data :   15
    end
end
X   3:    0   D   F
END
 }


#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $i1 = V  k => 1; $t->put($i1, $i1);
  my $i2 = V  k => 2; $t->put($i2, $i2);
  my $i3 = V  k => 3; $t->put($i3, $i3);
  my $i4 = V  k => 4; $t->put($i4, $i4);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("1"); $a->dump("AAA", K blocks => 12); $t->delete($i1);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

  ok Assemble eq => <<END, avx512=>1;
   4
1
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :    2
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    3    4
      Data :    3    4
    end
end
AAA
Area     Size:     4096    Used:      704
.... .... .... .... | __10 ____ ____ ____  C0.2 ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | __.2 ____ ____ ____  .4__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ C0__ ____
.... .... .... ..C0 | .1__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ __.1 ____
.... .... .... .1.. | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .140 | .3__ ____ .4__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .2__ ____ 80.1 ____
.... .... .... .180 | .3__ ____ .4__ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  __.2 ____ C0.1 ____
.... .... .... .1C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2.. | .2__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  .1__ ____ 40.2 ____
.... .... .... .240 | .2__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 80.2 ____
.... .... .... .280 | 80__ ____ 40.1 ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ 40__ ____
.... .... .... .2C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
   3
X
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    3
  Data :    3
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    2
      Data :    2
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    4
      Data :    4
    end
end
X   3:    2   3   4
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $i1 = V  k => 1; $t->put($i1, $i1);
  my $i2 = V  k => 2; $t->put($i2, $i2);
  my $i3 = V  k => 3; $t->put($i3, $i3);
  my $i4 = V  k => 4; $t->put($i4, $i4);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("2"); $t->delete($i2);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

  ok Assemble eq => <<END, avx512=>1;
   4
2
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :    2
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    3    4
      Data :    3    4
    end
end
   3
X
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    3
  Data :    3
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    4
      Data :    4
    end
end
X   3:    1   3   4
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $i1 = V  k => 1; $t->put($i1, $i1);
  my $i2 = V  k => 2; $t->put($i2, $i2);
  my $i3 = V  k => 3; $t->put($i3, $i3);
  my $i4 = V  k => 4; $t->put($i4, $i4);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("3"); $t->delete($i3);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

  ok Assemble eq => <<END, avx512=>1;
   4
3
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :    2
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    3    4
      Data :    3    4
    end
end
   3
X
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :    2
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    4
      Data :    4
    end
end
X   3:    1   2   4
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $i1 = V  k => 1; $t->put($i1, $i1);
  my $i2 = V  k => 2; $t->put($i2, $i2);
  my $i3 = V  k => 3; $t->put($i3, $i3);
  my $i4 = V  k => 4; $t->put($i4, $i4);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("4"); $t->delete($i4);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("X"); $t->printInOrder("X");

  ok Assemble eq => <<END, avx512=>1;
   4
4
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :    2
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    3    4
      Data :    3    4
    end
end
   3
X
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :    2
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    3
      Data :    3
    end
end
X   3:    1   2   3
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $i2 = V  k => 2; $t->put($i2, $i2);
  my $i1 = V  k => 1; $t->put($i1, $i1);
  my $i3 = V  k => 3; $t->put($i3, $i3);
  my $i4 = V  k => 4; $t->put($i4, $i4);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("0"); $t->delete($i2);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("2"); $t->delete($i3);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("3"); $t->delete($i4);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("4"); $t->delete($i1);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("1");

  ok Assemble eq => <<END, avx512=>1;
   4
0
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :    2
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    3    4
      Data :    3    4
    end
end
   3
2
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    3
  Data :    3
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :    1
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    4
      Data :    4
    end
end
   2
3
At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0    1
  Keys :    1    4
  Data :    1    4
end
   1
4
At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0
  Keys :    1
  Data :    1
end
   0
1
- empty
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  $t->put(   K(k=>1), K(d=>11));
  $t->put(   K(k=>2), K(d=>22));
  $t->put(   K(k=>3), K(d=>33));
  $t->delete(K k=>1);  $t->dump("1");
  $t->delete(K k=>3);  $t->dump("3");
  $t->delete(K k=>2);  $t->dump("2");
  ok Assemble eq => <<END, avx512=>1;
1
At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0    1
  Keys :    2    3
  Data :   22   33
end
3
At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0
  Keys :    2
  Data :   22
end
2
- empty
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  $t->put(   K(k=>1), K(d=>11));
  $t->put(   K(k=>2), K(d=>22));
  $t->put(   K(k=>3), K(d=>33));
  $t->put(   K(k=>4), K(d=>44));
  $t->dump("0");
  $t->delete(K k=>1);
  $t->dump("1");
  $t->delete(K k=>2);
  $t->dump("2");
  $t->delete(K k=>3);
  $t->dump("3");
  $t->delete(K k=>4);
  $t->dump("4");
  ok Assemble eq => <<END, avx512=>1;
0
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :   22
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   11
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    3    4
      Data :   33   44
    end
end
1
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    3
  Data :   33
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    2
      Data :   22
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    4
      Data :   44
    end
end
2
At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0    1
  Keys :    3    4
  Data :   33   44
end
3
At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0
  Keys :    4
  Data :   44
end
4
- empty
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  $t->put(   K(k=>1), K(d=>11));
  $t->put(   K(k=>2), K(d=>22));
  $t->put(   K(k=>3), K(d=>33));
  $t->put(   K(k=>4), K(d=>44));
  $t->dump("0");
  $t->delete(K k=>3);
  $t->dump("3");
  $t->delete(K k=>4);
  $t->dump("4");
  $t->delete(K k=>2);
  $t->dump("2");
  $t->delete(K k=>1);
  $t->dump("1");
  ok Assemble eq => <<END, avx512=>1;
0
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :   22
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   11
    end
    At:  140                length:    2,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    3    4
      Data :   33   44
    end
end
3
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    2
  Data :   22
  Nodes:   80  140
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    1
      Data :   11
    end
    At:  140                length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    4
      Data :   44
    end
end
4
At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0    1
  Keys :    1    2
  Data :   11   22
end
2
At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0
  Keys :    1
  Data :   11
end
1
- empty
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $i1 = V  k => 1; $t->put($i1, $i1);
  my $i2 = V  k => 2; $t->put($i2, $i2);
  my $i3 = V  k => 3; $t->put($i3, $i3);
  my $i4 = V  k => 4; $t->put($i4, $i4);
  my $i5 = V  k => 5; $t->put($i5, $i5);
  my $i6 = V  k => 6; $t->put($i6, $i6);
  my $i7 = V  k => 7; $t->put($i7, $i7);
  my $i8 = V  k => 8; $t->put($i8, $i8);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("1"); $t->delete($i1);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("2"); $t->delete($i2);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("3"); $t->delete($i3);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("4"); $t->delete($i4);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("5"); $t->delete($i5);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("6"); $t->delete($i6);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("7"); $t->delete($i7);
  $t->size->outRightInDecNL(K width => 4);  $t->dump("8"); $t->delete($i8);
  $t->size->outRightInDecNL(K width => 4);
  $t->dump("X");

  ok Assemble eq => <<END, avx512=>1;
   8
1
At:  500                    length:    1,  data:  540,  nodes:  580,  first:   40, root, parent
  Index:    0
  Keys :    4
  Data :    4
  Nodes:  200  440
    At:  200                length:    1,  data:  240,  nodes:  280,  first:   40,  up:  500, parent
      Index:    0
      Keys :    2
      Data :    2
      Nodes:   80  140
        At:   80            length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
          Index:    0
          Keys :    1
          Data :    1
        end
        At:  140            length:    1,  data:  180,  nodes:  1C0,  first:   40,  up:  200, leaf
          Index:    0
          Keys :    3
          Data :    3
        end
    end
    At:  440                length:    1,  data:  480,  nodes:  4C0,  first:   40,  up:  500, parent
      Index:    0
      Keys :    6
      Data :    6
      Nodes:  2C0  380
        At:  2C0            length:    1,  data:  300,  nodes:  340,  first:   40,  up:  440, leaf
          Index:    0
          Keys :    5
          Data :    5
        end
        At:  380            length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  440, leaf
          Index:    0    1
          Keys :    7    8
          Data :    7    8
        end
    end
end
   7
2
At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0    1
  Keys :    4    6
  Data :    4    6
  Nodes:   80  2C0  380
    At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    2    3
      Data :    2    3
    end
    At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    5
      Data :    5
    end
    At:  380                length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    7    8
      Data :    7    8
    end
end
   6
3
At:  200                    length:    2,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0    1
  Keys :    4    6
  Data :    4    6
  Nodes:   80  2C0  380
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    3
      Data :    3
    end
    At:  2C0                length:    1,  data:  300,  nodes:  340,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    5
      Data :    5
    end
    At:  380                length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    7    8
      Data :    7    8
    end
end
   5
4
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    6
  Data :    6
  Nodes:   80  380
    At:   80                length:    2,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    4    5
      Data :    4    5
    end
    At:  380                length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    7    8
      Data :    7    8
    end
end
   4
5
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    6
  Data :    6
  Nodes:   80  380
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    5
      Data :    5
    end
    At:  380                length:    2,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
      Index:    0    1
      Keys :    7    8
      Data :    7    8
    end
end
   3
6
At:  200                    length:    1,  data:  240,  nodes:  280,  first:   40, root, parent
  Index:    0
  Keys :    7
  Data :    7
  Nodes:   80  380
    At:   80                length:    1,  data:   C0,  nodes:  100,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    6
      Data :    6
    end
    At:  380                length:    1,  data:  3C0,  nodes:  400,  first:   40,  up:  200, leaf
      Index:    0
      Keys :    8
      Data :    8
    end
end
   2
7
At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0    1
  Keys :    7    8
  Data :    7    8
end
   1
8
At:   80                    length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0
  Keys :    8
  Data :    8
end
   0
X
- empty
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 20;
  $N->for(sub                                                                   # Load tree
   {my ($i) = @_;
    $t->put($i, $i);
   });
  $t->size->outNL;        $t->printInOrder("AA");
  $t->delete(K k =>  0);  $t->printInOrder(" 0");
  $t->delete(K k =>  9);  $t->printInOrder(" 9");
  $t->delete(K k =>  1);  $t->printInOrder(" 1");
  $t->delete(K k =>  8);  $t->printInOrder(" 8");
  $t->delete(K k =>  2);  $t->printInOrder(" 2");
  $t->delete(K k =>  7);  $t->printInOrder(" 7");
  $t->delete(K k =>  3);  $t->printInOrder(" 3");
  $t->delete(K k =>  6);  $t->printInOrder(" 6");
  $t->delete(K k =>  4);  $t->printInOrder(" 4");
  $t->delete(K k =>  5);  $t->printInOrder(" 5");
  $t->delete(K k => 10);  $t->printInOrder("10");
  $t->delete(K k => 19);  $t->printInOrder("19");
  $t->delete(K k => 11);  $t->printInOrder("11");
  $t->delete(K k => 18);  $t->printInOrder("18");
  $t->delete(K k => 12);  $t->printInOrder("12");
  $t->delete(K k => 17);  $t->printInOrder("17");
  $t->delete(K k => 13);  $t->printInOrder("13");
  $t->delete(K k => 16);  $t->printInOrder("16");
  $t->delete(K k => 14);  $t->printInOrder("14");
  $t->delete(K k => 15);  $t->printInOrder("15");

  ok Assemble eq => <<END, avx512=>1;
size of tree: .... .... .... ..14
AA  20:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13
 0  19:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13
 9  18:    1   2   3   4   5   6   7   8   A   B   C   D   E   F  10  11  12  13
 1  17:    2   3   4   5   6   7   8   A   B   C   D   E   F  10  11  12  13
 8  16:    2   3   4   5   6   7   A   B   C   D   E   F  10  11  12  13
 2  15:    3   4   5   6   7   A   B   C   D   E   F  10  11  12  13
 7  14:    3   4   5   6   A   B   C   D   E   F  10  11  12  13
 3  13:    4   5   6   A   B   C   D   E   F  10  11  12  13
 6  12:    4   5   A   B   C   D   E   F  10  11  12  13
 4  11:    5   A   B   C   D   E   F  10  11  12  13
 5  10:    A   B   C   D   E   F  10  11  12  13
10   9:    B   C   D   E   F  10  11  12  13
19   8:    B   C   D   E   F  10  11  12
11   7:    C   D   E   F  10  11  12
18   6:    C   D   E   F  10  11
12   5:    D   E   F  10  11
17   4:    D   E   F  10
13   3:    E   F  10
16   2:    E   F
14   1:    F
15- empty
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 16;
  $N->for(sub
   {my ($i) = @_;
    $t->put($i, $i);
   });
  $t->printInOrder(" 0"); $t->delete(K k =>  0);
  $t->printInOrder(" 2"); $t->delete(K k =>  2);
  $t->printInOrder(" 4"); $t->delete(K k =>  4);
  $t->printInOrder(" 6"); $t->delete(K k =>  6);
  $t->printInOrder(" 8"); $t->delete(K k =>  8);
  $t->printInOrder("10"); $t->delete(K k => 10);
  $t->printInOrder("12"); $t->delete(K k => 12);
  $t->printInOrder("14"); $t->delete(K k => 14);
  $t->printInOrder(" 1"); $t->delete(K k =>  1);
  $t->printInOrder(" 3"); $t->delete(K k =>  3);
  $t->printInOrder(" 5"); $t->delete(K k =>  5);
  $t->printInOrder(" 7"); $t->delete(K k =>  7);
  $t->printInOrder(" 9"); $t->delete(K k =>  9);
  $t->printInOrder("11"); $t->delete(K k => 11);
  $t->printInOrder("13"); $t->delete(K k => 13);
  $t->printInOrder("15"); $t->delete(K k => 15);
  $t->printInOrder("XX");

  ok Assemble eq => <<END, avx512=>1;
 0  16:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
 2  15:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
 4  14:    1   3   4   5   6   7   8   9   A   B   C   D   E   F
 6  13:    1   3   5   6   7   8   9   A   B   C   D   E   F
 8  12:    1   3   5   7   8   9   A   B   C   D   E   F
10  11:    1   3   5   7   9   A   B   C   D   E   F
12  10:    1   3   5   7   9   B   C   D   E   F
14   9:    1   3   5   7   9   B   D   E   F
 1   8:    1   3   5   7   9   B   D   F
 3   7:    3   5   7   9   B   D   F
 5   6:    5   7   9   B   D   F
 7   5:    7   9   B   D   F
 9   4:    9   B   D   F
11   3:    B   D   F
13   2:    D   F
15   1:    F
XX- empty
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K max => 8;

  $N->for(sub                                                                   # Load tree
   {my ($i) = @_;
    $t->put(         $i,     2 *        $i);
    $t->put(2 * $N - $i - 1, 2 * ($N -  $i));
   });
#  $t->printInOrder("Full");

  ($N-1)->for(sub                                                               # Delete elements
   {my ($i) = @_;
    my $n1 = ($N + $i)->clone("1111"); my $n2 = ($N - $i - 1)->clone("2222");

    $n1->outNL;
    $t->delete($n1);
    $t->printInOrder("1111");

    $n2->outNL;
    $t->delete($n2);
    $t->printInOrder("2222");
   });
  $t->dump("Two:");
  $t->size->outRightInDecNL(K width => 4);

  ok Assemble eq => <<END, avx512=>1;
1111: .... .... .... ...8
1111  15:    0   1   2   3   4   5   6   7   9   A   B   C   D   E   F
2222: .... .... .... ...7
2222  14:    0   1   2   3   4   5   6   9   A   B   C   D   E   F
1111: .... .... .... ...9
1111  13:    0   1   2   3   4   5   6   A   B   C   D   E   F
2222: .... .... .... ...6
2222  12:    0   1   2   3   4   5   A   B   C   D   E   F
1111: .... .... .... ...A
1111  11:    0   1   2   3   4   5   B   C   D   E   F
2222: .... .... .... ...5
2222  10:    0   1   2   3   4   B   C   D   E   F
1111: .... .... .... ...B
1111   9:    0   1   2   3   4   C   D   E   F
2222: .... .... .... ...4
2222   8:    0   1   2   3   C   D   E   F
1111: .... .... .... ...C
1111   7:    0   1   2   3   D   E   F
2222: .... .... .... ...3
2222   6:    0   1   2   D   E   F
1111: .... .... .... ...D
1111   5:    0   1   2   E   F
2222: .... .... .... ...2
2222   4:    0   1   E   F
1111: .... .... .... ...E
1111   3:    0   1   F
2222: .... .... .... ...1
2222   2:    0   F
Two:
At:   80                    length:    2,  data:   C0,  nodes:  100,  first:   40, root, leaf
  Index:    0    1
  Keys :    0    F
  Data :    0   16
end
   2
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K max => 100;

  $N->for(sub                                                                   # Load tree
   {my ($index, $start, $next, $end) = @_;
    $t->put($index, 2 * $index);
    If $t->size != $index + 1,
    Then
     {PrintOutStringNL "SSSS"; $index->outNL; Exit(0);
     };
   });

  $N->for(sub                                                                   # Check elements
   {my ($i) = @_;
    $t->find($i);
    If $t->found == 0,
    Then
     {PrintOutStringNL "AAAA"; $i->outNL; Exit(0);
     };
   });

  $N->for(sub                                                                   # Delete elements
   {my ($i) = @_;
    $t->delete($i);

    If $t->size != $N - $i - 1,
    Then
     {PrintOutStringNL "TTTT"; $i->outNL; Exit(0);
     };

    $N->for(sub                                                                 # Check elements
     {my ($j) = @_;
      $t->find($j);
      If $t->found == 0,
      Then
       {If $j > $i,
        Then
         {PrintOutStringNL "BBBBB"; $j->outNL; Exit(0);                         # Not deleted yet so it should be findable
         };
       },
      Else
       {If $j <= $i,
        Then
         {PrintOutStringNL "CCCCC"; $j->outNL; Exit(0);                         # Deleted so should not be findable
         };
       };
     });
   });

  ok Assemble eq => <<END, avx512=>1;
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 16;
  $N->for(sub
   {my ($i) = @_;
    $t->put($i, $i);
   });
  ($N/2)->for(sub
   {my ($i) = @_;
    $t->printInOrder("AAAA");
    $t->delete($i * 2);
   });
  ($N/2)->for(sub
   {my ($i) = @_;
    $t->printInOrder("BBBB");
    $t->delete($i * 2 + 1);
   });
  $t->printInOrder("CCCC");

  ok Assemble eq => <<END, avx512=>1;
AAAA  16:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
AAAA  15:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
AAAA  14:    1   3   4   5   6   7   8   9   A   B   C   D   E   F
AAAA  13:    1   3   5   6   7   8   9   A   B   C   D   E   F
AAAA  12:    1   3   5   7   8   9   A   B   C   D   E   F
AAAA  11:    1   3   5   7   9   A   B   C   D   E   F
AAAA  10:    1   3   5   7   9   B   C   D   E   F
AAAA   9:    1   3   5   7   9   B   D   E   F
BBBB   8:    1   3   5   7   9   B   D   F
BBBB   7:    3   5   7   9   B   D   F
BBBB   6:    5   7   9   B   D   F
BBBB   5:    7   9   B   D   F
BBBB   4:    9   B   D   F
BBBB   3:    B   D   F
BBBB   2:    D   F
BBBB   1:    F
CCCC- empty
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::delete
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 36;
  $N->for(sub
   {my ($i) = @_;
    $t->put($i, $i);
   });
  $t->delete(K 1 =>  0); $t->printInOrder(" 0");
  $t->delete(K 1 =>  5); $t->printInOrder(" 5");
  $t->delete(K 1 => 10); $t->printInOrder("10");
  $t->delete(K 1 => 15); $t->printInOrder("15");
  $t->delete(K 1 => 20); $t->printInOrder("20");
  $t->delete(K 1 => 25); $t->printInOrder("25");
  $t->delete(K 1 => 30); $t->printInOrder("30");
  $t->delete(K 1 => 35); $t->printInOrder("35");

  $t->delete(K 1 =>  1); $t->printInOrder(" 1");
  $t->delete(K 1 =>  6); $t->printInOrder(" 6");
  $t->delete(K 1 => 11); $t->printInOrder("11");
  $t->delete(K 1 => 16); $t->printInOrder("16");
  $t->delete(K 1 => 21); $t->printInOrder("21");
  $t->delete(K 1 => 26); $t->printInOrder("26");
  $t->delete(K 1 => 31); $t->printInOrder("31");

  $t->delete(K 1 =>  2); $t->printInOrder(" 2");
  $t->delete(K 1 =>  7); $t->printInOrder(" 7");
  $t->delete(K 1 => 12); $t->printInOrder("12");
  $t->delete(K 1 => 17); $t->printInOrder("17");
  $t->delete(K 1 => 22); $t->printInOrder("22");
  $t->delete(K 1 => 27); $t->printInOrder("27");
  $t->delete(K 1 => 32); $t->printInOrder("32");

  $t->delete(K 1 =>  3); $t->printInOrder(" 3");
  $t->delete(K 1 =>  8); $t->printInOrder(" 8");
  $t->delete(K 1 => 13); $t->printInOrder("13");
  $t->delete(K 1 => 18); $t->printInOrder("18");
  $t->delete(K 1 => 23); $t->printInOrder("23");
  $t->delete(K 1 => 28); $t->printInOrder("28");
  $t->delete(K 1 => 33); $t->printInOrder("33");

  $t->delete(K 1 =>  4); $t->printInOrder(" 4");
  $t->delete(K 1 =>  9); $t->printInOrder(" 9");
  $t->delete(K 1 => 14); $t->printInOrder("14");
  $t->delete(K 1 => 19); $t->printInOrder("19");
  $t->delete(K 1 => 24); $t->printInOrder("24");
  $t->delete(K 1 => 29); $t->printInOrder("29");
  $t->delete(K 1 => 34); $t->printInOrder("34");

  ok Assemble eq => <<END, avx512=>1;
 0  35:    1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
 5  34:    1   2   3   4   6   7   8   9   A   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
10  33:    1   2   3   4   6   7   8   9   B   C   D   E   F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
15  32:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
20  31:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23
25  30:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1E  1F  20  21  22  23
30  29:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22  23
35  28:    1   2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
 1  27:    2   3   4   6   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
 6  26:    2   3   4   7   8   9   B   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
11  25:    2   3   4   7   8   9   C   D   E  10  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
16  24:    2   3   4   7   8   9   C   D   E  11  12  13  15  16  17  18  1A  1B  1C  1D  1F  20  21  22
21  23:    2   3   4   7   8   9   C   D   E  11  12  13  16  17  18  1A  1B  1C  1D  1F  20  21  22
26  22:    2   3   4   7   8   9   C   D   E  11  12  13  16  17  18  1B  1C  1D  1F  20  21  22
31  21:    2   3   4   7   8   9   C   D   E  11  12  13  16  17  18  1B  1C  1D  20  21  22
 2  20:    3   4   7   8   9   C   D   E  11  12  13  16  17  18  1B  1C  1D  20  21  22
 7  19:    3   4   8   9   C   D   E  11  12  13  16  17  18  1B  1C  1D  20  21  22
12  18:    3   4   8   9   D   E  11  12  13  16  17  18  1B  1C  1D  20  21  22
17  17:    3   4   8   9   D   E  12  13  16  17  18  1B  1C  1D  20  21  22
22  16:    3   4   8   9   D   E  12  13  17  18  1B  1C  1D  20  21  22
27  15:    3   4   8   9   D   E  12  13  17  18  1C  1D  20  21  22
32  14:    3   4   8   9   D   E  12  13  17  18  1C  1D  21  22
 3  13:    4   8   9   D   E  12  13  17  18  1C  1D  21  22
 8  12:    4   9   D   E  12  13  17  18  1C  1D  21  22
13  11:    4   9   E  12  13  17  18  1C  1D  21  22
18  10:    4   9   E  13  17  18  1C  1D  21  22
23   9:    4   9   E  13  18  1C  1D  21  22
28   8:    4   9   E  13  18  1D  21  22
33   7:    4   9   E  13  18  1D  22
 4   6:    9   E  13  18  1D  22
 9   5:    E  13  18  1D  22
14   4:   13  18  1D  22
19   3:   18  1D  22
24   2:   1D  22
29   1:   22
34- empty
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::findNext
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 8;
  $N->for(sub
   {my ($i) = @_;
    $t->put(2*$i, 2*$i);
   });

  (2*$N)->for(sub
   {my ($i) = @_;
    $i->outRightInDec(K(key => 4)); PrintOutString " -> ";
    $t->findNext($i);
    $t->found->out("f: ", " ");
    If $t->found > 0, Then {$t->key->out};
    PrintOutStringNL '.';
   });

  ok Assemble eq => <<END, avx512=>1;
   0 -> f: .... .... .... ...1 key: .... .... .... ...2.
   1 -> f: .... .... .... ...1 key: .... .... .... ...2.
   2 -> f: .... .... .... ...1 key: .... .... .... ...4.
   3 -> f: .... .... .... ...1 key: .... .... .... ...4.
   4 -> f: .... .... .... ...1 key: .... .... .... ...6.
   5 -> f: .... .... .... ...1 key: .... .... .... ...6.
   6 -> f: .... .... .... ...1 key: .... .... .... ...8.
   7 -> f: .... .... .... ...1 key: .... .... .... ...8.
   8 -> f: .... .... .... ...1 key: .... .... .... ...A.
   9 -> f: .... .... .... ...1 key: .... .... .... ...A.
  10 -> f: .... .... .... ...1 key: .... .... .... ...C.
  11 -> f: .... .... .... ...1 key: .... .... .... ...C.
  12 -> f: .... .... .... ...2 key: .... .... .... ...E.
  13 -> f: .... .... .... ...2 key: .... .... .... ...E.
  14 -> f: .... .... .... .... .
  15 -> f: .... .... .... .... .
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::findPrev
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 8;
  $N->for(sub
   {my ($i) = @_;
    $t->put(2*$i, 2*$i);
   });

  (2*$N)->for(sub
   {my ($i) = @_;
    $i->outRightInDec(K(key => 4)); PrintOutString " -> ";
    $t->findPrev($i);
    $t->found->out("f: ", " ");
    If $t->found > 0, Then {$t->key->out};
    PrintOutStringNL '.';
   });

  ok Assemble eq => <<END, avx512=>1;
   0 -> f: .... .... .... .... .
   1 -> f: .... .... .... ...1 key: .... .... .... .....
   2 -> f: .... .... .... ...1 key: .... .... .... .....
   3 -> f: .... .... .... ...1 key: .... .... .... ...2.
   4 -> f: .... .... .... ...1 key: .... .... .... ...2.
   5 -> f: .... .... .... ...1 key: .... .... .... ...4.
   6 -> f: .... .... .... ...1 key: .... .... .... ...4.
   7 -> f: .... .... .... ...1 key: .... .... .... ...6.
   8 -> f: .... .... .... ...1 key: .... .... .... ...6.
   9 -> f: .... .... .... ...1 key: .... .... .... ...8.
  10 -> f: .... .... .... ...1 key: .... .... .... ...8.
  11 -> f: .... .... .... ...1 key: .... .... .... ...A.
  12 -> f: .... .... .... ...1 key: .... .... .... ...A.
  13 -> f: .... .... .... ...1 key: .... .... .... ...C.
  14 -> f: .... .... .... ...1 key: .... .... .... ...C.
  15 -> f: .... .... .... ...2 key: .... .... .... ...E.
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::by
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 16;
  $N->for(sub
   {my ($i) = @_;
    $t->put($i, 2 * $i);
   });

  $t->by(sub
   {my ($tree, $start, $next, $end) = @_;
    $tree->key->out("");  $tree->data->outNL(" ");
   });

  ok Assemble eq => <<END, avx512=>1;
.... .... .... .... .... .... .... ....
.... .... .... ...1 .... .... .... ...2
.... .... .... ...2 .... .... .... ...4
.... .... .... ...3 .... .... .... ...6
.... .... .... ...4 .... .... .... ...8
.... .... .... ...5 .... .... .... ...A
.... .... .... ...6 .... .... .... ...C
.... .... .... ...7 .... .... .... ...E
.... .... .... ...8 .... .... .... ..10
.... .... .... ...9 .... .... .... ..12
.... .... .... ...A .... .... .... ..14
.... .... .... ...B .... .... .... ..16
.... .... .... ...C .... .... .... ..18
.... .... .... ...D .... .... .... ..1A
.... .... .... ...E .... .... .... ..1C
.... .... .... ...F .... .... .... ..1E
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::yb
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 16;
  $N->for(sub
   {my ($i) = @_;
    $t->put($i, 2* $i);
   });

  $t->yb(sub
   {my ($tree, $start, $prev, $end) = @_;
    $tree->key->out("");  $tree->data->outNL(" ");
   });

  ok Assemble eq => <<END, avx512=>1;
.... .... .... ...F .... .... .... ..1E
.... .... .... ...E .... .... .... ..1C
.... .... .... ...D .... .... .... ..1A
.... .... .... ...C .... .... .... ..18
.... .... .... ...B .... .... .... ..16
.... .... .... ...A .... .... .... ..14
.... .... .... ...9 .... .... .... ..12
.... .... .... ...8 .... .... .... ..10
.... .... .... ...7 .... .... .... ...E
.... .... .... ...6 .... .... .... ...C
.... .... .... ...5 .... .... .... ...A
.... .... .... ...4 .... .... .... ...8
.... .... .... ...3 .... .... .... ...6
.... .... .... ...2 .... .... .... ...4
.... .... .... ...1 .... .... .... ...2
.... .... .... .... .... .... .... ....
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::push #TNasm::X86::Tree::pop #TNasm::X86::Tree::get
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 16;
  $N->for(sub
   {my ($i) = @_;
    $t->push($i);
   });

  $t->size->outNL;
  $t->get(K(key => 8)); $t->found->out("f: ", " ");  $t->key->out("i: ", " "); $t->data->outNL;

  $N->for(sub
   {my ($i) = @_;
    $t->pop; $t->found->out("f: ", " ");  $t->key->out("i: ", " "); $t->data->outNL;
   });
  $t->pop; $t->found->outNL("f: ");

  ok Assemble eq => <<END, avx512=>1;
size of tree: .... .... .... ..10
f: .... .... .... ...1 i: .... .... .... ...8 data: .... .... .... ...8
f: .... .... .... ...1 i: .... .... .... ...F data: .... .... .... ...F
f: .... .... .... ...1 i: .... .... .... ...E data: .... .... .... ...E
f: .... .... .... ...1 i: .... .... .... ...D data: .... .... .... ...D
f: .... .... .... ...1 i: .... .... .... ...C data: .... .... .... ...C
f: .... .... .... ...1 i: .... .... .... ...B data: .... .... .... ...B
f: .... .... .... ...1 i: .... .... .... ...A data: .... .... .... ...A
f: .... .... .... ...1 i: .... .... .... ...9 data: .... .... .... ...9
f: .... .... .... ...1 i: .... .... .... ...8 data: .... .... .... ...8
f: .... .... .... ...1 i: .... .... .... ...7 data: .... .... .... ...7
f: .... .... .... ...1 i: .... .... .... ...6 data: .... .... .... ...6
f: .... .... .... ...1 i: .... .... .... ...5 data: .... .... .... ...5
f: .... .... .... ...1 i: .... .... .... ...4 data: .... .... .... ...4
f: .... .... .... ...1 i: .... .... .... ...3 data: .... .... .... ...3
f: .... .... .... ...1 i: .... .... .... ...2 data: .... .... .... ...2
f: .... .... .... ...1 i: .... .... .... ...1 data: .... .... .... ...1
f: .... .... .... ...1 i: .... .... .... .... data: .... .... .... ....
f: .... .... .... ....
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::clear #TNasm::X86::Tree::free #TNasm::X86::Area::freeChainSpace  #TNasm::X86::Area::clear
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $N = K loop => 16;

  $N->for(sub {my ($i) = @_; $t->push($i+1)});
  $t->size->out("t: ", " ");
  $a->used->out("u: ", " ");
  $a->freeChainSpace->out("f: ", " ");
  $a->size->outNL;
  $t->clear;
  $t->size->out("t: ", " ");
  $a->used->out("u: ", " ");
  $a->freeChainSpace->out("f: ", " ");
  $a->size->outNL;

  $N->for(sub {my ($i) = @_; $t->push($i+1)});
  $t->size->out("t: ", " ");
  $a->used->out("u: ", " ");
  $a->freeChainSpace->out("f: ", " ");
  $a->size->outNL;
  $t->clear;
  $t->size->out("t: ", " ");
  $a->used->out("u: ", " ");
  $a->freeChainSpace->out("f: ", " ");
  $a->size->outNL;

  $N->for(sub {my ($i) = @_; $t->push($i+1)});
  $t->free;
  $a->used->out("Clear tree:            u: ");
  $a->freeChainSpace->out(" f: ", " ");
  $a->size->outNL;

  $a->clear;
  $a->used->out("Clear area:            u: ");
  $a->freeChainSpace->out(" f: ", " ");
  $a->size->outNL;

  ok Assemble eq => <<END, avx512=>1;
t: .... .... .... ..10 u: .... .... .... .B80 f: .... .... .... .... size of area: .... .... .... 10..
t: .... .... .... .... u: .... .... .... .B80 f: .... .... .... .B40 size of area: .... .... .... 10..
t: .... .... .... ..10 u: .... .... .... .B80 f: .... .... .... .... size of area: .... .... .... 10..
t: .... .... .... .... u: .... .... .... .B80 f: .... .... .... .B40 size of area: .... .... .... 10..
Clear tree:            u: .... .... .... .B80 f: .... .... .... .B40 size of area: .... .... .... 10..
Clear area:            u: .... .... .... .... f: .... .... .... .... size of area: .... .... .... 10..
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Area::allocZmmBlock #TNasm::X86::Area::freeZmmBlock #TNasm::X86::Area::getZmmBlock #TNasm::X86::Area::putZmmBlock #TNasm::X86::Area::clearZmmBlock #TNasm::X86::Area::dump
  my $a = CreateArea;

  my $m = $a->allocZmmBlock;
  K(K => Rd(1..16))->loadZmm(31);

  $a->putZmmBlock  ($m, 31);
  $a->dump("A");

  $a->getZmmBlock  ($m, 30);
  $a->clearZmmBlock($m);
  $a->getZmmBlock  ($m, 29);

  $a->clearZmmBlock($m);
  PrintOutRegisterInHex 31, 30, 29;

  ok Assemble eq => <<END, avx512=>1;
A
Area     Size:     4096    Used:      128
.... .... .... .... | __10 ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | .1__ ____ .2__ ____  .3__ ____ .4__ ____  .5__ ____ .6__ ____  .7__ ____ .8__ ____  .9__ ____ .A__ ____  .B__ ____ .C__ ____  .D__ ____ .E__ ____  .F__ ____ 10__ ____
.... .... .... ..80 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
 zmm31: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm30: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm29: .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... .... + .... .... .... ....  .... .... .... .... - .... .... .... ....  .... .... .... ....
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Area::allocZmmBlock #TNasm::X86::Area::freeZmmBlock #TNasm::X86::Area::getZmmBlock #TNasm::X86::Area::putZmmBlock  #TNasm::X86::Area::dump
  my $a = CreateArea;

  K(loop => 3)->for(sub
   {my ($i, $start, $next, $end) = @_;
    $i->outNL;
    my $m1 = $a->allocZmmBlock;
    my $m2 = $a->allocZmmBlock;

    K(K => Rd(1..16))->loadZmm(31);
    K(K => Rd(17..32))->loadZmm(30);
    PrintOutRegisterInHex 31, 30;

    $a->putZmmBlock($m1, 31);
    $a->putZmmBlock($m2, 30);
    $a->dump("A");

    $a->getZmmBlock($m1, 30);
    $a->getZmmBlock($m2, 31);
    PrintOutRegisterInHex 31, 30;

    $a->clearZmmBlock($m1);
    $a->freeZmmBlock($m1);
    $a->dump("B");

    $a->freeZmmBlock($m2);
    $a->dump("C");
   });

  ok Assemble eq => <<END, avx512=>1;
index: .... .... .... ....
 zmm31: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1C .... ..1B  .... ..1A .... ..19 + .... ..18 .... ..17  .... ..16 .... ..15 - .... ..14 .... ..13  .... ..12 .... ..11
A
Area     Size:     4096    Used:      192
.... .... .... .... | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | .1__ ____ .2__ ____  .3__ ____ .4__ ____  .5__ ____ .6__ ____  .7__ ____ .8__ ____  .9__ ____ .A__ ____  .B__ ____ .C__ ____  .D__ ____ .E__ ____  .F__ ____ 10__ ____
.... .... .... ..80 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
 zmm31: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1C .... ..1B  .... ..1A .... ..19 + .... ..18 .... ..17  .... ..16 .... ..15 - .... ..14 .... ..13  .... ..12 .... ..11
 zmm30: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
B
Area     Size:     4096    Used:      192
.... .... .... .... | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
C
Area     Size:     4096    Used:      192
.... .... .... .... | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
index: .... .... .... ...1
 zmm31: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1C .... ..1B  .... ..1A .... ..19 + .... ..18 .... ..17  .... ..16 .... ..15 - .... ..14 .... ..13  .... ..12 .... ..11
A
Area     Size:     4096    Used:      192
.... .... .... .... | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
.... .... .... ..80 | .1__ ____ .2__ ____  .3__ ____ .4__ ____  .5__ ____ .6__ ____  .7__ ____ .8__ ____  .9__ ____ .A__ ____  .B__ ____ .C__ ____  .D__ ____ .E__ ____  .F__ ____ 10__ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
 zmm31: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1C .... ..1B  .... ..1A .... ..19 + .... ..18 .... ..17  .... ..16 .... ..15 - .... ..14 .... ..13  .... ..12 .... ..11
 zmm30: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
B
Area     Size:     4096    Used:      192
.... .... .... .... | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
.... .... .... ..80 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
C
Area     Size:     4096    Used:      192
.... .... .... .... | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | 80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
index: .... .... .... ...2
 zmm31: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
 zmm30: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1C .... ..1B  .... ..1A .... ..19 + .... ..18 .... ..17  .... ..16 .... ..15 - .... ..14 .... ..13  .... ..12 .... ..11
A
Area     Size:     4096    Used:      192
.... .... .... .... | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | .1__ ____ .2__ ____  .3__ ____ .4__ ____  .5__ ____ .6__ ____  .7__ ____ .8__ ____  .9__ ____ .A__ ____  .B__ ____ .C__ ____  .D__ ____ .E__ ____  .F__ ____ 10__ ____
.... .... .... ..80 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
 zmm31: .... ..20 .... ..1F  .... ..1E .... ..1D - .... ..1C .... ..1B  .... ..1A .... ..19 + .... ..18 .... ..17  .... ..16 .... ..15 - .... ..14 .... ..13  .... ..12 .... ..11
 zmm30: .... ..10 .... ...F  .... ...E .... ...D - .... ...C .... ...B  .... ...A .... ...9 + .... ...8 .... ...7  .... ...6 .... ...5 - .... ...4 .... ...3  .... ...2 .... ...1
B
Area     Size:     4096    Used:      192
.... .... .... .... | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | 11__ ____ 12__ ____  13__ ____ 14__ ____  15__ ____ 16__ ____  17__ ____ 18__ ____  19__ ____ 1A__ ____  1B__ ____ 1C__ ____  1D__ ____ 1E__ ____  1F__ ____ 20__ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
C
Area     Size:     4096    Used:      192
.... .... .... .... | __10 ____ ____ ____  C0__ ____ ____ ____  ____ ____ ____ ____  80__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..40 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..80 | 40__ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
.... .... .... ..C0 | ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____  ____ ____ ____ ____
END
 }

#latest:
if (1) {                                                                        #Tconvert_rax_from_utf32_to_utf8
# $ 	U+0024                 010 0100                00100100                     24
#  	U+00A3 	          000 1010 0011                11000010 10100011            C2 A3
#  	  U+0939    	0000 1001 0011 1001                11100000 10100100 10111001   E0 A4 B9
#  	U+20AC    	0010 0000 1010 1100                11100010 10000010 10101100   E2 82 AC
#  	U+D55C     	1101 0101 0101 1100                11101101 10010101 10011100   ED 95 9C
#    	U+10348 	0 0001 0000 0011 0100 1000 	11110000 10010000 10001101 10001000   F0 90 8D 88
  Mov rax, 0x40;                                                                # 0x40
  convert_rax_from_utf32_to_utf8;
  PrintOutRegisterInHex rax;

  Mov rax, 0x03b1;                                                              # 0xCE 0xB1
  convert_rax_from_utf32_to_utf8;
  PrintOutRegisterInHex rax;

  Mov rax, 0x20ac;                                                              # 0xE2 0x82 0xAC;
  convert_rax_from_utf32_to_utf8;
  PrintOutRegisterInHex rax;

  Mov rax, 0x10348;                                                             # 0xf0 0x90 0x8d 0x88
  convert_rax_from_utf32_to_utf8;
  PrintOutRegisterInHex rax;

  ok Assemble eq => <<END, avx512=>1;
   rax: .... .... .... ..40
   rax: .... .... .... B1CE
   rax: .... .... ..AC 82E2
   rax: .... .... 888D 90F0
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::outAsUtf8 #TNasm::X86::Tree::append
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);

  $t->push(K alpha => 0x03b1);
  $t->push(K beta  => 0x03b2);
  $t->push(K gamma => 0x03b3);
  $t->push(K delta => 0x03b4);

  $t->outAsUtf8NL;

  $t->append($t);
  $t->outAsUtf8NL;

  $t->append($t);
  $t->outAsUtf8NL;

  my $T = $t->substring(K(key => 4), K(key => 8));
  $T->outAsUtf8NL;

  my $r = $T->reverse;
  $r->outAsUtf8NL;

  ok Assemble eq => <<END, avx512=>1;





END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::m
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $b = Rb(0x41..0x51);
  $t->m(K(address=> $b), K(size => 1));
  $t->outAsUtf8NL;

  my $T = $a->CreateTree(length => 3);
  $T->push($t);
  $T->dump("T");
  ok Assemble eq => <<END, avx512=>1;
A
T
At:  180                    length:    1,  data:  1C0,  nodes:  200,  first:  140, root, leaf,  trees:   1
  Index:    0
  Keys :    0
  Data :   8*
     At:   80               length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
       Index:    0
       Keys :    0
       Data :   65
     end
end
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::m
  my $a = CreateArea;
  my $t = $a->CreateTree(length => 3);
  my $b = Rb(0x41..0x51);
  $t->m(K(address=> $b), K(size => 1));
  $t->outAsUtf8NL;

  my $T = $a->CreateTree(length => 3);
  $T->push($t);
  $T->push($t);
  $T->push($t);
  $T->push($t);
  $T->dump("T");
  $T->pop;
  $T->pop;
  $T->dump("D");
  ok Assemble eq => <<END, avx512=>1;
A
T
At:  300                    length:    1,  data:  340,  nodes:  380,  first:  140, root, parent,  trees:   1
  Index:    0
  Keys :    1
  Data :   8*
  Nodes:  180  240
     At:   80               length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
       Index:    0
       Keys :    0
       Data :   65
     end
    At:  180                length:    1,  data:  1C0,  nodes:  200,  first:  140,  up:  300, leaf,  trees:   1
      Index:    0
      Keys :    0
      Data :   8*
         At:   80           length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
           Index:    0
           Keys :    0
           Data :   65
         end
    end
    At:  240                length:    2,  data:  280,  nodes:  2C0,  first:  140,  up:  300, leaf,  trees:  11
      Index:    0    1
      Keys :    2    3
      Data :   8*   8*
         At:   80           length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
           Index:    0
           Keys :    0
           Data :   65
         end
         At:   80           length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
           Index:    0
           Keys :    0
           Data :   65
         end
    end
end
D
At:  180                    length:    2,  data:  1C0,  nodes:  200,  first:  140, root, leaf,  trees:  11
  Index:    0    1
  Keys :    0    1
  Data :   8*   8*
     At:   80               length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
       Index:    0
       Keys :    0
       Data :   65
     end
     At:   80               length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
       Index:    0
       Keys :    0
       Data :   65
     end
end
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::m
  my $b = Rb(0x41..0x51);
  my $a = CreateArea;
  my $T;
  for my $i(1..8)
   {my $t = $a->CreateTree(length => 3);
    $t->m(K(address=> $b), K(size => 1));
    $t->push($T) if $T;
    $T = $t;
   }

  $T->dump("T");
  ok Assemble eq => <<END, avx512=>1;
T
At:  780                    length:    2,  data:  7C0,  nodes:  800,  first:  740, root, leaf,  trees:  10
  Index:    0    1
  Keys :    0    1
  Data :   65  68*
     At:  680               length:    2,  data:  6C0,  nodes:  700,  first:  640, root, leaf,  trees:  10
       Index:    0    1
       Keys :    0    1
       Data :   65  58*
          At:  580          length:    2,  data:  5C0,  nodes:  600,  first:  540, root, leaf,  trees:  10
            Index:    0    1
            Keys :    0    1
            Data :   65  48*
               At:  480     length:    2,  data:  4C0,  nodes:  500,  first:  440, root, leaf,  trees:  10
                 Index:    0    1
                 Keys :    0    1
                 Data :   65  38*
                    At:  380length:    2,  data:  3C0,  nodes:  400,  first:  340, root, leaf,  trees:  10
                      Index:    0    1
                      Keys :    0    1
                      Data :   65  28*
                         At:  280length:    2,  data:  2C0,  nodes:  300,  first:  240, root, leaf,  trees:  10
                           Index:    0    1
                           Keys :    0    1
                           Data :   65  18*
                              At:  180length:    2,  data:  1C0,  nodes:  200,  first:  140, root, leaf,  trees:  10
                                Index:    0    1
                                Keys :    0    1
                                Data :   65   8*
                                   At:   80length:    1,  data:   C0,  nodes:  100,  first:   40, root, leaf
                                     Index:    0
                                     Keys :    0
                                     Data :   65
                                   end
                              end
                         end
                    end
               end
          end
     end
end
END
 }

latest:
if (1) {                                                                        #TNasm::X86::Tree::outAsUtf8 #TNasm::X86::Tree::append
  my $a = CreateArea;
  my $p = $a->CreateTree(length => 3);
  my $q = $a->CreateTree(length => 3);
  my $r = $a->CreateTree(length => 3);
  my $s = $a->CreateTree(length => 3);
  my $t = $a->CreateTree(length => 3);

  $s->push(K char => ord $_) for split //, 'abc1';
  $r->push(K char => ord $_) for split //, 'abd2';
  $q->push(K char => ord $_) for split //, 'abe3';
  $p->push(K char => ord $_) for split //, 'abf4';

  $t->putString($_) for $s, $r, $q, $p;
  $t->dump('t = abcd');

  $t->find(K key => 0x61);
  for my $f(qw(found key data subTree offset))
   {$t->{$f}->outNL(sprintf("%-8s", $f));
   }

  $t->getString($s); $t->found->outNL;
  $s->pop;
  $t->getString($s); $t->found->outNL;

  ok Assemble eq => <<END, avx512=>1;
t = abcd
At:  AC0                    length:    1,  data:  B00,  nodes:  B40,  first:  140, root, leaf,  trees:   1
  Index:    0
  Keys :   61
  Data :  BC*
     At:  BC0               length:    1,  data:  C00,  nodes:  C40,  first:  A80, root, leaf,  trees:   1
       Index:    0
       Keys :   62
       Data :  E0*
          At:  E00          length:    1,  data:  E40,  nodes:  E80,  first:  B80, root, parent
            Index:    0
            Keys :   64
            Data :   50
            Nodes:  C80  D40
              At:  C80      length:    1,  data:  CC0,  nodes:  D00,  first:  B80,  up:  E00, leaf
                Index:    0
                Keys :   63
                Data :   49
              end
              At:  D40      length:    2,  data:  D80,  nodes:  DC0,  first:  B80,  up:  E00, leaf
                Index:    0    1
                Keys :   65   66
                Data :   51   52
              end
          end
     end
end
found   .... .... .... ...1
key     .... .... .... ..61
data    .... .... .... .A80
subTree .... .... .... ...1
offset  .... .... .... .AC0
END
 }

#latest:
if (1) {                                                                        #TNasm::X86::Tree::union #TNasm::X86::Tree::intersection
  my $a = CreateArea;
  my $r = $a->CreateTree(length => 3);
  my $s = $a->CreateTree(length => 3);
  my $t = $a->CreateTree(length => 3);

  $r->put(K(key => 1), K(data => 1));
  $r->put(K(key => 2), K(data => 2));

  $s->put(K(key => 1), K(data => 1));
  $s->put(K(key => 3), K(data => 3));

  $t->push($r);
  $t->push($s);

  my $u = $t->union;
  $t->dump('input 1 2  1 3');
  $u->dump('union 1 2    3');

  my $i = $t->intersection;
  $i->dump('intersection 1');

  ok Assemble eq => <<END, avx512=>1;
input 1 2  1 3
At:  280                    length:    2,  data:  2C0,  nodes:  300,  first:   C0, root, leaf,  trees:  11
  Index:    0    1
  Keys :    0    1
  Data :  10*  1C*
     At:  100               length:    2,  data:  140,  nodes:  180,  first:   40, root, leaf
       Index:    0    1
       Keys :    1    2
       Data :    1    2
     end
     At:  1C0               length:    2,  data:  200,  nodes:  240,  first:   80, root, leaf
       Index:    0    1
       Keys :    1    3
       Data :    1    3
     end
end
union 1 2    3
At:  380                    length:    3,  data:  3C0,  nodes:  400,  first:  340, root, leaf
  Index:    0    1    2
  Keys :    1    2    3
  Data :    1    2    3
end
intersection 1
At:  480                    length:    1,  data:  4C0,  nodes:  500,  first:  440, root, leaf
  Index:    0
  Keys :    1
  Data :    1
end
END
 }

#latest:
if (0) {                                                                        #
  ok Assemble eq => <<END, avx512=>1;
END
 }

done_testing;

=pod

Status:

Need to make a subroutine out of the insert into key/data/node block

=cut

#unlink $_ for qw(hash print2 sde-log.txt sde-ptr-check.out.txt z.txt);         # Remove incidental files
#unlink $_ for qw(hash print2 pin-log.txt pin-tool-log.txt sde-footprint.txt sde-log.txt clear hash signal z.o);
unlink $_ for qw(sde-footprint.txt sde-log.txt z.txt);

say STDERR sprintf("# Time: %.2fs, bytes: %s, execs: %s",
  time - $start,
  map {numberWithCommas $_} totalBytesAssembled, $instructionsExecuted);
